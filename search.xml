<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android拍照适配到Android7.0</title>
    <url>/2018/04/19/Android%E6%8B%8D%E7%85%A7%EF%BC%8C%E9%80%82%E9%85%8D%E5%88%B0Android7.0/</url>
    <content><![CDATA[<h3 id="获得相机权限"><a href="#获得相机权限" class="headerlink" title="获得相机权限"></a>获得相机权限</h3><p>因为需要用到camera，所以需要在manifest 文件里面声明设备 <code>需要安装</code>有camera程序。</p>
<span id="more"></span>

<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">...</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-feature</span> <span class="attr">android:name</span>=<span class="string">&quot;android.hardware.camera&quot;</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">android:required</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="获得缩略图"><a href="#获得缩略图" class="headerlink" title="获得缩略图"></a>获得缩略图</h3><p>Anroid相机程序将通过<code>onActivityResult()</code> 返回 <code>Bitmap</code>缩略图</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onActivityResult</span><span class="params">(<span class="type">int</span> requestCode, <span class="type">int</span> resultCode, Intent data)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (requestCode == REQUEST_IMAGE_CAPTURE &amp;&amp; resultCode == RESULT_OK)     &#123;</span><br><span class="line">        <span class="type">Bundle</span> <span class="variable">extras</span> <span class="operator">=</span> data.getExtras();</span><br><span class="line">        <span class="type">Bitmap</span> <span class="variable">imageBitmap</span> <span class="operator">=</span> (Bitmap) extras.get(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">        mImageView.setImageBitmap(imageBitmap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>注意：</strong> 从“<strong>data</strong>”从获取来的缩略图只适合作为icon，不适合其他用途。</p>
<h3 id="保存大尺寸图片"><a href="#保存大尺寸图片" class="headerlink" title="保存大尺寸图片"></a>保存大尺寸图片</h3><p>一般用户应该将通过相机拍摄的照片保存在公共外部存储目录，这样可以方便其他应用程序访问。 <code>getExternalStoragePublicDirectory()</code>方法和 <code>DIRECTORY_PICTURES</code>参数可以将公共照片保存在正确的目录，因为这种方法提供的目录是所有应用程序之间共享，各自需要<code>READ_EXTERNAL_STORAGE</code>和<code>WRITE_EXTERNAL_STORAGE</code>权限。如果允许了写的权限，那么读的权限也将被隐式允许。所以，如果你需要读写外部存取目录，你只需要声明一个权限。</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span></span></span><br><span class="line"><span class="tag">	<span class="attr">android:name</span>=<span class="string">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<p>然而，如果你想将照片保存到私有目录只供你的app使用，那么你可以使用<code>getExternalFilesDir()</code>方法。在Android4.3及以下，仍需要<code>WRITE_EXTERNAL_STORAGE</code> 权限；但是从Android4.4开始，就不再需要声明此权限了，因为这个目录无法被其他app访问。因此你可以这样声明权限，仅仅只在较低的版本上添加<code>maxSdkVersion</code>属性：</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">android:maxSdkVersion</span>=<span class="string">&quot;18&quot;</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<p><strong>注意：</strong> 用<code>getExternalFilesDir()</code>和 <code>getFilesDir()</code>方法保存在目录的文件，会随着用户卸载app而一并删除。</p>
<ul>
<li>以下是谷歌提供的生成唯一文件名的一种方法</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">String mCurrentPhotoPath;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> File <span class="title function_">createImageFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// Create an image file name</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">timeStamp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyyMMdd_HHmmss&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    <span class="type">String</span> <span class="variable">imageFileName</span> <span class="operator">=</span> <span class="string">&quot;JPEG_&quot;</span> + timeStamp + <span class="string">&quot;_&quot;</span>;</span><br><span class="line">    <span class="type">File</span> <span class="variable">storageDir</span> <span class="operator">=</span> getExternalFilesDir(Environment.DIRECTORY_PICTURES);</span><br><span class="line">    <span class="type">File</span> <span class="variable">image</span> <span class="operator">=</span> File.createTempFile(</span><br><span class="line">        imageFileName,  <span class="comment">/* prefix */</span></span><br><span class="line">        <span class="string">&quot;.jpg&quot;</span>,         <span class="comment">/* suffix */</span></span><br><span class="line">        storageDir      <span class="comment">/* directory */</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save a file: path for use with ACTION_VIEW intents</span></span><br><span class="line">    mCurrentPhotoPath = image.getAbsolutePath();</span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>然后调用<code>Intent</code> 启动相机</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">REQUEST_TAKE_PHOTO</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dispatchTakePictureIntent</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Intent</span> <span class="variable">takePictureIntent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(MediaStore.ACTION_IMAGE_CAPTURE);</span><br><span class="line">    <span class="comment">// Ensure that there&#x27;s a camera activity to handle the intent</span></span><br><span class="line">    <span class="keyword">if</span> (takePictureIntent.resolveActivity(getPackageManager()) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Create the File where the photo should go</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">photoFile</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            photoFile = createImageFile();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="comment">// Error occurred while creating the File</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Continue only if the File was successfully created</span></span><br><span class="line">        <span class="keyword">if</span> (photoFile != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Uri</span> <span class="variable">photoURI</span> <span class="operator">=</span> FileProvider.getUriForFile(<span class="built_in">this</span>,</span><br><span class="line">                                                  <span class="string">&quot;com.example.android.fileprovider&quot;</span>,</span><br><span class="line">                                                  photoFile);</span><br><span class="line">            takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT, photoURI);</span><br><span class="line">            startActivityForResult(takePictureIntent, REQUEST_TAKE_PHOTO);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>注意：</strong> 从Android7.0开始，通过<code>getUriForFile(Context, String, File)</code> 返回的<code>content://</code> URI来访问数据，使用过去的<code>file://</code>URI将产生<code>FileUriExposedException</code>异常，现在一般使用<code>FileProvider</code>这种更加通用的方式来存储文件。</p>
<ul>
<li>配置<code>FileProvider</code><br> 在清单文件中：<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span>&gt;</span></span><br><span class="line">   ...</span><br><span class="line">   <span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;android.support.v4.content.FileProvider&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:authorities</span>=<span class="string">&quot;com.example.android.fileprovider&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:grantUriPermissions</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;android.support.FILE_PROVIDER_PATHS&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:resource</span>=<span class="string">&quot;@xml/file_paths&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">meta-data</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
必须确保<code>android:authorities</code>里面的值和class文件中的 <code>getUriForFile(Context, String, File)</code> 方法的值保持一致。<code>exported:</code>要求必须为<code>false</code>，为<code>true</code>则会报安全异常。<code>grantUriPermissions:true</code>，表示授予 URI 临时访问权限。<br>为了指定共享的目录我们需要在资源(res)目录下创建一个xml目录，然后创建一个名为“file_paths”(名字可以随便起，只要和在manifest注册的provider所引用的resource保持一致即可)的资源文件。</li>
</ul>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">paths</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">external-path</span> <span class="attr">name</span>=<span class="string">&quot;my_images&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">path</span>=<span class="string">&quot;Android/data/com.example.package.name/files/Pictures&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">paths</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<p>上述代码中<code>path=&quot;&quot;</code>，是有特殊意义的，它代码根目录，也就是说你可以向其它的应用共享根目录及其子目录下任何一个文件了，如果你将<code>path</code>设为<code>path=&quot;pictures&quot;</code>，<br>那么它代表着根目录下的<strong>pictures</strong>目录(eg:&#x2F;storage&#x2F;emulated&#x2F;0&#x2F;pictures)，如果你向其它应用分享<strong>pictures</strong>目录范围之外的文件是不行的。</p>
<h3 id="将图片保存到相册"><a href="#将图片保存到相册" class="headerlink" title="将图片保存到相册"></a>将图片保存到相册</h3><p><strong>注意：</strong> 如果你是用<code>getExternalFilesDir()</code>方法保存的文件，那么媒体将无法扫描到，因为它只对你的app私有化。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">galleryAddPic</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">Intent</span> <span class="variable">mediaScanIntent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE);</span><br><span class="line">    <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(mCurrentPhotoPath);</span><br><span class="line">    <span class="type">Uri</span> <span class="variable">contentUri</span> <span class="operator">=</span> Uri.fromFile(f);</span><br><span class="line">    mediaScanIntent.setData(contentUri);</span><br><span class="line">    <span class="built_in">this</span>.sendBroadcast(mediaScanIntent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="按比例缩小图片"><a href="#按比例缩小图片" class="headerlink" title="按比例缩小图片"></a>按比例缩小图片</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setPic</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the dimensions of the View</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">targetW</span> <span class="operator">=</span> mImageView.getWidth();</span><br><span class="line">    <span class="type">int</span> <span class="variable">targetH</span> <span class="operator">=</span> mImageView.getHeight();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the dimensions of the bitmap</span></span><br><span class="line">    BitmapFactory.<span class="type">Options</span> <span class="variable">bmOptions</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BitmapFactory</span>.Options();</span><br><span class="line">    bmOptions.inJustDecodeBounds = <span class="literal">true</span>;</span><br><span class="line">    BitmapFactory.decodeFile(mCurrentPhotoPath, bmOptions);</span><br><span class="line">    <span class="type">int</span> <span class="variable">photoW</span> <span class="operator">=</span> bmOptions.outWidth;</span><br><span class="line">    <span class="type">int</span> <span class="variable">photoH</span> <span class="operator">=</span> bmOptions.outHeight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Determine how much to scale down the image</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">scaleFactor</span> <span class="operator">=</span> Math.min(photoW/targetW, photoH/targetH);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decode the image file into a Bitmap sized to fill the View</span></span><br><span class="line">    bmOptions.inJustDecodeBounds = <span class="literal">false</span>;</span><br><span class="line">    bmOptions.inSampleSize = scaleFactor;</span><br><span class="line">    bmOptions.inPurgeable = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">Bitmap</span> <span class="variable">bitmap</span> <span class="operator">=</span> BitmapFactory.decodeFile(mCurrentPhotoPath, bmOptions);</span><br><span class="line">    mImageView.setImageBitmap(bitmap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android的Activities四种启动模式</title>
    <url>/2018/07/25/Android%E7%9A%84Activities%E5%9B%9B%E7%A7%8D%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>Android的Activities四种启动模式：<code>Standerd</code>、<code>SingleTop</code>、<code>SingleTask</code>、<code>SingleInstance</code>。</p>
<span id="more"></span>

<h3 id="Standard-默认标准启动模式"><a href="#Standard-默认标准启动模式" class="headerlink" title="Standard(默认标准启动模式)"></a>Standard(默认标准启动模式)</h3><p>每次启动都重新创建一个新的实例，不管它是否存在。且谁启动了这个Acitivity,那么这个Acitivity就运行在启动它的那个Acitivity的任务栈中。</p>
<h3 id="SingleTop-栈顶复用模式"><a href="#SingleTop-栈顶复用模式" class="headerlink" title="SingleTop(栈顶复用模式)"></a>SingleTop(栈顶复用模式)</h3><p>如果新的Activity已经位于任务栈的栈顶，那么不会被重新创建，而是回调onNewIntent()方法，通过此方法的参数可以取出当前请求的信息。</p>
<h3 id="SingleTask-栈内复用模式"><a href="#SingleTask-栈内复用模式" class="headerlink" title="SingleTask(栈内复用模式)"></a>SingleTask(栈内复用模式)</h3><p>这是一种单例模式，在这种模式下，只要Acitivity在一个栈中存在，那么多次启动此Acitivity都不会重建实例，而是回调onNewIntent方法。同时由于SingleTask模式有ClearTop功能，因此会导致所要求的Acitivity上方的Acitivity全部销毁。</p>
<h3 id="SingleInstance-单实例模式"><a href="#SingleInstance-单实例模式" class="headerlink" title="SingleInstance(单实例模式)"></a>SingleInstance(单实例模式)</h3><p>和栈内复用类似，此种模式的Acitivity只能单独位于一个任务栈中。全局唯一性。单例实例，不是创建，而是重用。独占性，一个Acitivity单独运行在一个工作栈中。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android的adb调试命令集合</title>
    <url>/2018/03/17/Android%E7%9A%84adb%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<p>记录下一些实用的<strong>adb</strong>命令</p>
<h3 id="发送广播关闭USB"><a href="#发送广播关闭USB" class="headerlink" title="发送广播关闭USB"></a>发送广播关闭USB</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell am broadcast -a android.hardware.usb.action.USB_STATE --ez connected &quot;false&quot;</span><br></pre></td></tr></table></figure></div>
 <span id="more"></span>

<h3 id="关闭gyroscope-陀螺仪"><a href="#关闭gyroscope-陀螺仪" class="headerlink" title="关闭gyroscope(陀螺仪)"></a>关闭gyroscope(陀螺仪)</h3><blockquote>
<p>硬件相关，可能有变动</p>
</blockquote>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell echo 0 &gt; /sys/class/sensors/bmg160/enable</span><br></pre></td></tr></table></figure></div>

<h3 id="无线adb连接手机"><a href="#无线adb连接手机" class="headerlink" title="无线adb连接手机"></a>无线adb连接手机</h3><p>Connect the device to the computer with a USB cable → The computer recognize the device</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb devices</span><br></pre></td></tr></table></figure></div>

<p>Make sure device’s Wifi is ON, and set device’s tcpip port → To change the adb port</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb tcpip 12443</span><br></pre></td></tr></table></figure></div>

<p>Write down the device IP (Connect to wifi):<br>   Go to settings → about phone → Status → IP address<br>Example: 192.168.8.81</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb connect 192.168.8.81:12443</span><br></pre></td></tr></table></figure></div>

<p>Disconnect the cable</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb disconnect 192.168.8.81:12443</span><br></pre></td></tr></table></figure></div>

<h3 id="查看系统时间"><a href="#查看系统时间" class="headerlink" title="查看系统时间"></a>查看系统时间</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell date</span><br></pre></td></tr></table></figure></div>

<h3 id="开机跳过setupWizard正常使用"><a href="#开机跳过setupWizard正常使用" class="headerlink" title="开机跳过setupWizard正常使用"></a>开机跳过setupWizard正常使用</h3><h4 id="disable-SetupWizard"><a href="#disable-SetupWizard" class="headerlink" title="disable SetupWizard:"></a>disable SetupWizard:</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell pm list packages | grep setup</span><br><span class="line">adb shell pm disable</span><br></pre></td></tr></table></figure></div>

<p>→ Example: com.google.android.setupwizard</p>
<h4 id="build-Provision-and-push-into-handset"><a href="#build-Provision-and-push-into-handset" class="headerlink" title="build Provision and push into handset:"></a>build Provision and push into handset:</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">mmm packages/apps/Provision/</span><br><span class="line">adb push out/target/product/flash3/system/app/Provision/Provision.apk /system/app/Provision/</span><br></pre></td></tr></table></figure></div>

<h4 id="reboot"><a href="#reboot" class="headerlink" title="reboot"></a>reboot</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb reboot</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>Provision就是无界面版的SetupWizard，快速设置并初始化手机，是SetupWizard的替代版。</p>
</blockquote>
<p>可断开USB还执行adb命令，例如通过如下命令记录event log到sdcard</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell &quot;getevent -ltr &gt; sdcard/getevent.log&amp;&quot;  (linux common function)</span><br></pre></td></tr></table></figure></div>

<p>在执行此命令之后可拔掉USB进行测试</p>
<h3 id="查看Notification：“找出状态栏广告的主人”"><a href="#查看Notification：“找出状态栏广告的主人”" class="headerlink" title="查看Notification：“找出状态栏广告的主人”"></a>查看Notification：“找出状态栏广告的主人”</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys statusbar</span><br></pre></td></tr></table></figure></div>

<h2 id="debug相关的命令"><a href="#debug相关的命令" class="headerlink" title="debug相关的命令"></a>debug相关的命令</h2><h3 id="过滤log篇"><a href="#过滤log篇" class="headerlink" title="过滤log篇"></a>过滤log篇</h3><h4 id="只查看某个TAG的某个priority的log："><a href="#只查看某个TAG的某个priority的log：" class="headerlink" title="只查看某个TAG的某个priority的log："></a>只查看某个TAG的某个priority的log：</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb logcat ActivityManager:I MyApp:D *:S</span><br></pre></td></tr></table></figure></div>

<p><code>*:S</code>: sets the priority level for all tags to “silent”, thus ensuring only log messages with “ActivityManager” and “MyApp” are displayed.</p>
<h4 id="只显示Error级别的log："><a href="#只显示Error级别的log：" class="headerlink" title="只显示Error级别的log："></a>只显示Error级别的log：</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb logcat *:E</span><br></pre></td></tr></table></figure></div>

<h4 id="直接看Exception的命令："><a href="#直接看Exception的命令：" class="headerlink" title="直接看Exception的命令："></a>直接看Exception的命令：</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb logcat -s */E</span><br></pre></td></tr></table></figure></div>

<h4 id="logcat时可以查看某个tag的所有log"><a href="#logcat时可以查看某个tag的所有log" class="headerlink" title="logcat时可以查看某个tag的所有log:"></a>logcat时可以查看某个tag的所有log:</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb logcat -v threadtime -s [TAG]</span><br></pre></td></tr></table></figure></div>

<h4 id="打开某个class的log："><a href="#打开某个class的log：" class="headerlink" title="打开某个class的log："></a>打开某个class的log：</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell setprop log.tag.MyAppTag VERBOSE</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>or:<br>  Creating a local.prop file as described in the original question:<br>  log.tag.MY_TAG&#x3D;VERBOSE</p>
<p>  And then pushing it onto the device as follows seems to do the trick:<br>  adb push local.prop &#x2F;data&#x2F;local.prop<br>  adb shell chmod 644 &#x2F;data&#x2F;local.prop<br>  adb shell chown root.root &#x2F;data&#x2F;local.prop<br>  adb reboot</p>
<p>You can double check to make sure that the values in local.prop were read by executing:<br>adb shell getprop | grep log.tag</p>
</blockquote>
<h4 id="抓取kernel-log："><a href="#抓取kernel-log：" class="headerlink" title="抓取kernel log："></a>抓取kernel log：</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell cat /proc/kmsg &gt; kernel.log</span><br></pre></td></tr></table></figure></div>

<h3 id="强制让进程gc"><a href="#强制让进程gc" class="headerlink" title="强制让进程gc"></a>强制让进程gc</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell kill -10 PIDXXX</span><br></pre></td></tr></table></figure></div>

<h3 id="强制生成trace"><a href="#强制生成trace" class="headerlink" title="强制生成trace"></a>强制生成trace</h3><blockquote>
<p>&#x2F;data&#x2F;anr&#x2F;traces.txt</p>
</blockquote>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell kill -3 PIDxxx</span><br></pre></td></tr></table></figure></div>

<h3 id="强制生成进程的内存镜像"><a href="#强制生成进程的内存镜像" class="headerlink" title="强制生成进程的内存镜像"></a>强制生成进程的内存镜像</h3><blockquote>
<p>分析OOM</p>
</blockquote>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell am dumpheap PIDxxx /data/xxx.hprof</span><br></pre></td></tr></table></figure></div>

<h3 id="打印调用顺序"><a href="#打印调用顺序" class="headerlink" title="打印调用顺序"></a>打印调用顺序</h3><blockquote>
<p>在java代码中加入，可知道该函数被谁调用</p>
</blockquote>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">Debug.getCallers(4)</span><br></pre></td></tr></table></figure></div>

<h3 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h3><blockquote>
<p>每隔1秒执行top命令显示10行数据，能够实时查看后台哪些进程或者线程在执 行，消耗cpu</p>
</blockquote>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell top -d 1 -m 10 -t</span><br></pre></td></tr></table></figure></div>

<h3 id="软重新启动"><a href="#软重新启动" class="headerlink" title="软重新启动"></a>软重新启动</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell stop; adb shell start</span><br></pre></td></tr></table></figure></div>

<h3 id="monkey-test的命令"><a href="#monkey-test的命令" class="headerlink" title="monkey test的命令"></a>monkey test的命令</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell monkey -v -p [package name] [times]</span><br><span class="line">adb shell monkey -v -p com.jrdcom.lockscreen 1000000</span><br></pre></td></tr></table></figure></div>

<h3 id="查看cpu频率"><a href="#查看cpu频率" class="headerlink" title="查看cpu频率"></a>查看cpu频率</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_cur_freq</span><br><span class="line">adb shell cat /sys/devices/system/cpu/cpu1/cpufreq/scaling_cur_freq</span><br><span class="line">adb shell cat /sys/devices/system/cpu/cpu2/cpufreq/scaling_cur_freq</span><br><span class="line">adb shell cat /sys/devices/system/cpu/cpu3/cpufreq/scaling_cur_freq</span><br></pre></td></tr></table></figure></div>

<h3 id="打开CPU-loading-log"><a href="#打开CPU-loading-log" class="headerlink" title="打开CPU loading log"></a>打开CPU loading log</h3><blockquote>
<p>分析ANR（MTK）</p>
</blockquote>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell setprop events.cpu true</span><br></pre></td></tr></table></figure></div>

<p>在events log中实时打印cpu信息。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb logcat -b events | grep cpu</span><br><span class="line">   I/cpu     (  743): [16,4,12,0,0,0]</span><br><span class="line">   I/cpu     (  743): [15,2,13,0,0,0]</span><br><span class="line">   I/cpu     (  743): [16,2,14,0,0,0]</span><br><span class="line"></span><br><span class="line">数字都是百分比，分别为：[total, user, system, iouat, irq, softlrq]</span><br></pre></td></tr></table></figure></div>

<h3 id="终端输入play-pause事件模拟按键"><a href="#终端输入play-pause事件模拟按键" class="headerlink" title="终端输入play pause事件模拟按键"></a>终端输入play pause事件模拟按键</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell media</span><br><span class="line">  usage: media [subcommand] [options]</span><br><span class="line">  media dispatch KEY</span><br><span class="line">  media remote-display</span><br><span class="line"></span><br><span class="line">    media dispatch:    dispatch a media key to the current media client.</span><br><span class="line">    KEY may be:        play, pause, play-pause, mute, headsethook, stop, next, previous, rewind, recordm fast-forword.</span><br><span class="line">    media remote-display: 	 monitor remote display updates.</span><br></pre></td></tr></table></figure></div>

<h2 id="系列核心命令"><a href="#系列核心命令" class="headerlink" title="系列核心命令"></a>系列核心命令</h2><h3 id="模拟输入事件"><a href="#模拟输入事件" class="headerlink" title="模拟输入事件"></a>模拟输入事件</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell input text &lt;string&gt;   input a string to device</span><br><span class="line">adb shell input keyevent &lt;event_code&gt;   send a Key Event to device</span><br><span class="line"></span><br><span class="line">如: adb shell input keyevent 26      (PowerKey)</span><br></pre></td></tr></table></figure></div>

<h3 id="模拟启动activity"><a href="#模拟启动activity" class="headerlink" title="模拟启动activity"></a>模拟启动activity</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell am start  &lt;INTENT&gt; : start an Activity</span><br><span class="line">如：am start -n com.android.calculator/com.android.calculator2.Calculator</span><br><span class="line">adb shell am broadcast &lt;INTENT&gt;</span><br></pre></td></tr></table></figure></div>

<h3 id="得到设置的settings数据库键值"><a href="#得到设置的settings数据库键值" class="headerlink" title="得到设置的settings数据库键值"></a>得到设置的settings数据库键值</h3><blockquote>
<p><strong>usage:</strong> settings [–user NUM] get namespace key</p>
<p>​					settings [–user NUM] put namespace key value</p>
<p>​					settings [–user NUM] delete namespace key</p>
<p> ‘namespace’ is one of {system, secure, global}, case-insensitive</p>
<p>If ‘–user NUM’ is not given, the operations are performed on the owner user.</p>
</blockquote>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell settings get/set Global airplane_mode_on</span><br></pre></td></tr></table></figure></div>

<h4 id="修改数据库的键值"><a href="#修改数据库的键值" class="headerlink" title="修改数据库的键值"></a>修改数据库的键值</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell settings put system/global [key] [value]</span><br><span class="line">adb shell settings put system navigation_bar_key_mode 1</span><br></pre></td></tr></table></figure></div>

<h4 id="得到数据库的键值"><a href="#得到数据库的键值" class="headerlink" title="得到数据库的键值"></a>得到数据库的键值</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell settings get system/global [key]</span><br></pre></td></tr></table></figure></div>

<h3 id="查看Service信息"><a href="#查看Service信息" class="headerlink" title="查看Service信息"></a>查看Service信息</h3><h4 id="查看Service列表"><a href="#查看Service列表" class="headerlink" title="查看Service列表"></a>查看Service列表</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell service list</span><br><span class="line">   Found 1 services:</span><br><span class="line">0 phone: [com.android.internal.telephony.ITelephony]</span><br></pre></td></tr></table></figure></div>

<h4 id="检查Service是否存在"><a href="#检查Service是否存在" class="headerlink" title="检查Service是否存在"></a>检查Service是否存在</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell service check phone</span><br><span class="line">Service phone: found</span><br></pre></td></tr></table></figure></div>

<h4 id="使用Service"><a href="#使用Service" class="headerlink" title="使用Service"></a>使用Service</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell service call phone 2 s16 &quot;10086&quot;</span><br></pre></td></tr></table></figure></div>

<h3 id="手机屏幕相关设置-wm命令"><a href="#手机屏幕相关设置-wm命令" class="headerlink" title="手机屏幕相关设置-wm命令"></a>手机屏幕相关设置-wm命令</h3><blockquote>
<p>adb shell wm</p>
<p>usage: wm [subcommand] [options]</p>
<p>​             wm size [reset | WxH]</p>
<p>​             wm density [reset | DENSITY]</p>
<p>​             wm overscan [reset | LEFT,TOP,RIGHT,BOTTOM]</p>
</blockquote>
<h4 id="wm-overscan-reset-LEFT-TOP-RIGHT-BOTTOM"><a href="#wm-overscan-reset-LEFT-TOP-RIGHT-BOTTOM" class="headerlink" title="wm overscan [reset|LEFT,TOP,RIGHT,BOTTOM]"></a>wm overscan [reset|LEFT,TOP,RIGHT,BOTTOM]</h4><p>wm overscan: set overscan area for display.</p>
<p>重新设置屏幕大小、尺寸:</p>
<p>让界面显示在靠左200，靠上300，靠右400，靠下500的显示区域</p>
<p>width &#x3D; displaywidth - left - right</p>
<p>height &#x3D; displayheight - top - bottom</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell wm overscan 200,300,400,500</span><br><span class="line">                      left,top,right,bottom</span><br></pre></td></tr></table></figure></div>

<h4 id="wm-size-return-or-override-display-size"><a href="#wm-size-return-or-override-display-size" class="headerlink" title="wm size: return or override display size"></a>wm size: return or override display size</h4><p>查看屏幕分辨率</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell wm size</span><br><span class="line">    Physical size: 720x1280</span><br></pre></td></tr></table></figure></div>

<h4 id="wm-density-override-display-density"><a href="#wm-density-override-display-density" class="headerlink" title="wm density: override display density"></a>wm density: override display density</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell wm density</span><br><span class="line">    Physical density: 480</span><br></pre></td></tr></table></figure></div>

<p>强制设置手机dpi为320</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell wm density 320</span><br><span class="line">adb shell wm density reset</span><br></pre></td></tr></table></figure></div>

<h3 id="svc命令"><a href="#svc命令" class="headerlink" title="svc命令"></a>svc命令</h3><h4 id="Turn-on-x2F-off-Wi-Fi"><a href="#Turn-on-x2F-off-Wi-Fi" class="headerlink" title="Turn on&#x2F;off Wi-Fi"></a>Turn on&#x2F;off Wi-Fi</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">svc wifi [enable|disable]</span><br></pre></td></tr></table></figure></div>

<h4 id="Turn-on-x2F-off-mobile-data"><a href="#Turn-on-x2F-off-mobile-data" class="headerlink" title="Turn on&#x2F;off mobile data"></a>Turn on&#x2F;off mobile data</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">svc data [enable|disable]</span><br></pre></td></tr></table></figure></div>

<h4 id="手机重启"><a href="#手机重启" class="headerlink" title="手机重启"></a>手机重启</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">svc power reboot [reason]</span><br><span class="line">    Perform a runtime shutdown and reboot device with specified reason.</span><br></pre></td></tr></table></figure></div>

<h4 id="手机关机"><a href="#手机关机" class="headerlink" title="手机关机"></a>手机关机</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">svc power shutdown</span><br><span class="line">    Perform a runtime shutdown and power off the device.</span><br></pre></td></tr></table></figure></div>

<h3 id="pm-命令大全"><a href="#pm-命令大全" class="headerlink" title="pm 命令大全"></a>pm 命令大全</h3><blockquote>
<p>pm命令用于分析手机中apk和包名</p>
</blockquote>
<h4 id="查看当前安装的所有apk"><a href="#查看当前安装的所有apk" class="headerlink" title="查看当前安装的所有apk"></a>查看当前安装的所有apk</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell pm list packages</span><br></pre></td></tr></table></figure></div>

<h4 id="查看包名和文件名对应表"><a href="#查看包名和文件名对应表" class="headerlink" title="查看包名和文件名对应表"></a>查看包名和文件名对应表</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell pm list packages -f</span><br><span class="line">  package:/system/priv-app/DefaultContainerService.apk=com.android.defcontainer</span><br><span class="line">  package:/data/app/com.tencent.mm-1.apk=com.tencent.mm</span><br><span class="line">  package:/system/app/JrdGallery.apk=com.jrdcom.gallery3d</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></div>

<h4 id="查看disable-packagename"><a href="#查看disable-packagename" class="headerlink" title="查看disable packagename"></a>查看disable packagename</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell pm list packages -d</span><br></pre></td></tr></table></figure></div>

<h4 id="查看enable-packagename"><a href="#查看enable-packagename" class="headerlink" title="查看enable packagename"></a>查看enable packagename</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell pm list packages -e</span><br></pre></td></tr></table></figure></div>

<h4 id="查看system-app-packagename"><a href="#查看system-app-packagename" class="headerlink" title="查看system app packagename"></a>查看system app packagename</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell pm list packages -s</span><br></pre></td></tr></table></figure></div>

<h4 id="查看第三方app-packagename"><a href="#查看第三方app-packagename" class="headerlink" title="查看第三方app packagename"></a>查看第三方app packagename</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell pm list packages -3</span><br></pre></td></tr></table></figure></div>

<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell pm list features</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Enable/Disable package</span></span><br><span class="line">adb shell pm enable [packagename]</span><br><span class="line">adb shell pm disable [packagename]</span><br></pre></td></tr></table></figure></div>

<h3 id="am-命令大全"><a href="#am-命令大全" class="headerlink" title="am 命令大全"></a>am 命令大全</h3><h4 id="强制dump某个进程的内存镜像"><a href="#强制dump某个进程的内存镜像" class="headerlink" title="强制dump某个进程的内存镜像"></a>强制dump某个进程的内存镜像</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1044是Launcher的pid</span></span><br><span class="line">adb shell am dumpheap 1044 /data/aa.hprof</span><br></pre></td></tr></table></figure></div>

<h4 id="Dalvik’s-sampling-profiler-定时抓取java-call-stack"><a href="#Dalvik’s-sampling-profiler-定时抓取java-call-stack" class="headerlink" title="Dalvik’s sampling profiler 定时抓取java call stack"></a>Dalvik’s sampling profiler 定时抓取java call stack</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell am profile start [--user &lt;USER_ID&gt; current] [--sampling INTERVAL] &lt;PROCESS&gt; &lt;FILE&gt;</span><br><span class="line">adb shell am profile stop [--user &lt;USER_ID&gt; current] [&lt;PROCESS&gt;]</span><br><span class="line">persist.sys.profiler_ms 		时间频率 默认0</span><br><span class="line">persist.sys.profiler_depth	 call stack depth 默认4</span><br><span class="line">抓取的文件保存于/data/snapshots/&lt;pid&gt;-&lt;time&gt;.snapshot</span><br></pre></td></tr></table></figure></div>

<h4 id="List-all-of-the-activity-stacks-and-their-sizes"><a href="#List-all-of-the-activity-stacks-and-their-sizes" class="headerlink" title="List all of the activity stacks and their sizes"></a>List all of the activity stacks and their sizes</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell am stack list</span><br></pre></td></tr></table></figure></div>

<h4 id="Display-the-information-about-activity-stack"><a href="#Display-the-information-about-activity-stack" class="headerlink" title="Display the information about activity stack"></a>Display the information about activity stack</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell am stack info &lt;STACK_ID&gt;</span><br></pre></td></tr></table></figure></div>

<h3 id="dumpsys相关命令"><a href="#dumpsys相关命令" class="headerlink" title="dumpsys相关命令"></a>dumpsys相关命令</h3><h4 id="查看activity的provider信息"><a href="#查看activity的provider信息" class="headerlink" title="查看activity的provider信息"></a>查看activity的provider信息</h4><p>查看activity每个数据库的调用信息查询 打印所有provider信息 可以查看数据库某个时间点的增删改查的次数, 监测应用的IO操作:</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys activity provider all</span><br><span class="line">PROVIDER ContentProviderRecord&#123;19861e6e u0 com.android.providers.media/.MediaProvider&#125; pid=31295</span><br><span class="line">    Client:</span><br><span class="line">      internal.db: version 700, 68 rows, 0 inserts, 0 updates, 0 deletes, 120 queries,</span><br><span class="line">      1970-02-07 10:49:01.893 : Database upgraded from version 63 to 700 in 0 seconds</span><br><span class="line">												               插入62次，0次更新，0次删除，105次查询</span><br><span class="line">      1970-02-07 10:49:03.852 : internal.db: version 700, 54 rows, 62 inserts, 0 updates, 0 deletes, 105 queries, scan started Feb 7, 10:49 AM (00:02)</span><br><span class="line">      1970-02-07 10:54:06.555 : internal.db: version 700, 54 rows, 0 inserts, 0 updates, 0 deletes, 55 queries, scan started 2月7日 下午6:54 (00:00)</span><br><span class="line">      2013-12-26 05:41:19.318 : internal.db: version 700, 54 rows, 0 inserts, 4 updates, 0 deletes, 58 queries, scan started Dec 26, 1:41 PM (00:00)</span><br><span class="line">      2013-12-27 07:45:37.775 : internal.db: version 700, 59 rows, 0 inserts, 0 updates, 0 deletes, 55 queries, scan started Dec 27, 3:45 PM (00:00)</span><br></pre></td></tr></table></figure></div>

<h4 id="查看provider的Connections，谁在连接数据库"><a href="#查看provider的Connections，谁在连接数据库" class="headerlink" title="查看provider的Connections，谁在连接数据库"></a>查看provider的Connections，谁在连接数据库</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">dumpsys activity providers</span><br></pre></td></tr></table></figure></div>

<h4 id="查看手机disk状态"><a href="#查看手机disk状态" class="headerlink" title="查看手机disk状态"></a>查看手机disk状态</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys diskstats</span><br><span class="line">    &gt;&gt; Latency: 5ms [512B Data Write]</span><br><span class="line">    &gt;&gt; Data-Free: 362888K / 1161104K total = 31% free</span><br><span class="line">    &gt;&gt; Cache-Free: 116756K / 120900K total = 96% free</span><br><span class="line">    &gt;&gt; System-Free: 133036K / 806284K total = 16% free</span><br></pre></td></tr></table></figure></div>

<h4 id="Get-the-list-of-services-available"><a href="#Get-the-list-of-services-available" class="headerlink" title="Get the list of services available"></a>Get the list of services available</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell service list</span><br></pre></td></tr></table></figure></div>

<h4 id="查看可用的SERVICE列表"><a href="#查看可用的SERVICE列表" class="headerlink" title="查看可用的SERVICE列表"></a>查看可用的SERVICE列表</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys | grep &#x27;DUMP OF SERVICE&#x27; | awk &#x27;&#123;print $4&#125;&#x27; | tr -d &#x27;:&#x27;</span><br><span class="line"></span><br><span class="line">ACTIVITY MANAGER PENDING INTENTS (adb shell dumpsys activity intents)</span><br><span class="line">ACTIVITY MANAGER BROADCAST STATE (adb shell dumpsys activity broadcasts)</span><br><span class="line">ACTIVITY MANAGER CONTENT PROVIDERS (adb shell dumpsys activity providers)</span><br><span class="line">ACTIVITY MANAGER SERVICES (adb shell dumpsys activity services)</span><br><span class="line">ACTIVITY MANAGER ACTIVITIES (adb shell dumpsys activity activities)</span><br><span class="line">ACTIVITY MANAGER RUNNING PROCESSES (adb shell dumpsys activity processes)</span><br><span class="line">INPUT MANAGER (adb shell dumpsys input)</span><br><span class="line">WINDOW MANAGER LAST ANR (adb shell dumpsys window lastanr)</span><br><span class="line">WINDOW MANAGER POLICY STATE (adb shell dumpsys window policy)</span><br><span class="line">WINDOW MANAGER SESSIONS (adb shell dumpsys window sessions)</span><br><span class="line">WINDOW MANAGER TOKENS (adb shell dumpsys window tokens)</span><br><span class="line">WINDOW MANAGER WINDOWS (adb shell dumpsys window windows)</span><br></pre></td></tr></table></figure></div>

<h4 id="查看某个应用的内存使用信息"><a href="#查看某个应用的内存使用信息" class="headerlink" title="查看某个应用的内存使用信息"></a>查看某个应用的内存使用信息</h4><blockquote>
<p>getting memory usage informations</p>
</blockquote>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys meminfo &#x27;your apps package name&#x27;</span><br><span class="line">adb shell dumpsys meminfo com.google.android.apps.maps</span><br></pre></td></tr></table></figure></div>

<h4 id="查看TaskStack"><a href="#查看TaskStack" class="headerlink" title="查看TaskStack"></a>查看TaskStack</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys activity activities</span><br></pre></td></tr></table></figure></div>

<h4 id="查看Alarm列表"><a href="#查看Alarm列表" class="headerlink" title="查看Alarm列表"></a>查看Alarm列表</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys alarm</span><br></pre></td></tr></table></figure></div>

<h4 id="查看surface-flinger"><a href="#查看surface-flinger" class="headerlink" title="查看surface flinger"></a>查看surface flinger</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys SurfaceFlinger</span><br></pre></td></tr></table></figure></div>

<h4 id="dumpsys其他一些信息"><a href="#dumpsys其他一些信息" class="headerlink" title="dumpsys其他一些信息"></a>dumpsys其他一些信息</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys SurfaceFlinger | grep &quot;Layer\|z=&quot;</span><br><span class="line">adb shell dumpsys activity log a on</span><br><span class="line">adb shell dumpsys window -d enable 26</span><br><span class="line">adb shell dumpsys alarm log on</span><br><span class="line">adb shell dumpsys alarm log off</span><br><span class="line">adb shell dumpsys window policy</span><br><span class="line">adb shell dumpsys activity log anr 2   可以打开anr的messagequeue</span><br><span class="line">adb shell dumpsys activity a           查看activity详细信息，如显示大小，布局等等</span><br><span class="line">adb shell dumpsys activity processes   进程信息 trimmemory</span><br><span class="line">adb shell dumpsys activity recents</span><br><span class="line">adb shell dumpsys activity broadcasts  可以查看前台和后台broadcast详细信息(发送时间，</span><br><span class="line">                                       所有应用处理时间，监听广播的所有列表)</span><br><span class="line">adb shell dumpsys activity intents</span><br><span class="line">adb shell dumpsys activity oom</span><br><span class="line">adb shell dumpsys input | grep Focus   查看焦点窗口</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Container 的布局表现行为</title>
    <url>/2021/06/24/Container%20%E7%9A%84%E5%B8%83%E5%B1%80%E8%A1%A8%E7%8E%B0%E8%A1%8C%E4%B8%BA/</url>
    <content><![CDATA[<p>因为 Container 包含多个子组件，并且每个子组件都有自己的布局表现，所以Container的布局表现有些复杂。</p>
<span id="more"></span>

<p>简单来说，Container 会按照以下<strong>顺序</strong>进行尝试：</p>
<ol>
<li>根据 alignment；</li>
<li>根据子组件调整自己的大小；</li>
<li>根据自身的 width 、height 和  constraints；</li>
<li>尝试扩大自身的大小以适应父组件；</li>
<li>尽可能的缩小。</li>
</ol>
<p>特别的：</p>
<ol>
<li>如果没有子组件、没有 height 、没有 width 、没有 constraints 、父组件没有提供 constraints，则 Container 的尺寸会尽可能的小；</li>
<li>如果没有子组件、没有 alignment 、但提供了 height 、width 、或者 constraints，则 Container 会在给定的自身约束和父约束的前提下的尺寸会尽可能的小；</li>
<li>如果没有子组件、没有 alignment 、没有 height 、没有 width 、没有 constraints，但父组件提供了 constraints，则 Container 的尺寸会和父组件的尺寸一样；</li>
<li>如果有 alignment 、父组件没有提供 constraints，则 Container 的尺寸会和子组件的尺寸一样；</li>
<li>如果有 alignment 、父组件提供了 constraints，则 Container 的尺寸会和父组件的尺寸一样，然后根据 alignment 放置子组件；</li>
<li>如果没有 alignment 、没有 height 、没有 width 、没有 constraints，则子组件、Container、父组件三者的尺寸一样大。</li>
</ol>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Studio配置</title>
    <url>/2023/01/11/Android%20Studio%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>当我首次使用Android Studio的时候，会采用如下配置，下面的一些配置技巧或许对你有一定的帮助。</p>
<span id="more"></span>

<h3 id="显示行号"><a href="#显示行号" class="headerlink" title="显示行号"></a>显示行号</h3><ol>
<li>File | Settings 打开设置</li>
<li>选择 Editor | General | Appearance</li>
<li>勾选 Show line numbers</li>
</ol>
<h3 id="命名前缀"><a href="#命名前缀" class="headerlink" title="命名前缀"></a>命名前缀</h3><ol>
<li>File | Settings 打开设置</li>
<li>选择 Editor | Code Style | Java</li>
<li>选择 Code Generation 标签</li>
<li>给普通 Field 添加一个 <code>m</code> 前缀，给 Static filed 添加一个 <code>s</code> 前缀</li>
</ol>
<h3 id="快速导包"><a href="#快速导包" class="headerlink" title="快速导包"></a>快速导包</h3><ol>
<li>File | Settings 打开设置</li>
<li>选择 Editor | General | Auto Import</li>
<li>勾选 Optimize imports on the fly</li>
<li>勾选 Add unambiguous imports on the fly</li>
</ol>
<h3 id="Logcat-颜色"><a href="#Logcat-颜色" class="headerlink" title="Logcat 颜色"></a>Logcat 颜色</h3><ol>
<li>File | Settings 打开设置</li>
<li>选择 Editor | Color &amp; Fonts | Android Logcat</li>
<li>点击 Click on Save As…按钮创建一个新的配色 Scheme</li>
<li>按照下面的表格修改对应的颜色(修改之前需要取消勾选 Use inherited attributes)</li>
</ol>
<table>
<thead>
<tr>
<th>Logcat级别</th>
<th>颜色</th>
</tr>
</thead>
<tbody><tr>
<td>Assert</td>
<td>#AA66CC</td>
</tr>
<tr>
<td>Debug</td>
<td>#33B5E5</td>
</tr>
<tr>
<td>Error</td>
<td>#FF4444</td>
</tr>
<tr>
<td>Info</td>
<td>#99CC00</td>
</tr>
<tr>
<td>Verbose</td>
<td>#BBBBBB</td>
</tr>
<tr>
<td>Warning</td>
<td>#FFBB33</td>
</tr>
</tbody></table>
<h3 id="取消代码注释中的显示"><a href="#取消代码注释中的显示" class="headerlink" title="取消代码注释中的显示"></a>取消代码注释中的<p>显示</h3><ol>
<li>File | Settings 打开设置</li>
<li>选择 Editor | Code Style | Java | JavaDoc</li>
<li>打开 Other 节点</li>
<li>取消勾选 Generate “<p>“ on empty lines</li>
</ol>
<h3 id="代码配色"><a href="#代码配色" class="headerlink" title="代码配色"></a>代码配色</h3><ol>
<li>File | Settings 打开设置</li>
<li>选择 Editor | Color &amp; Fonts | Java</li>
<li>点击 Click on Save As…按钮创建一个新的配色 Scheme</li>
<li>展开下方的 Variables 选择 Local variable</li>
<li>设置右侧的 Foreground 颜色 <code>#68B5EE</code></li>
</ol>
<h3 id="字体设置"><a href="#字体设置" class="headerlink" title="字体设置"></a>字体设置</h3><ol>
<li>File | Settings 打开设置</li>
<li>选择 Editor | Font</li>
<li>设置右侧的 Font 选择<code>Consolas</code>，Size选择<code>14</code></li>
</ol>
<h3 id="文件编码设置"><a href="#文件编码设置" class="headerlink" title="文件编码设置"></a>文件编码设置</h3><ol>
<li>File | Settings 打开设置</li>
<li>选择 Editor | File Encodings</li>
<li>设置右侧的 Global Encoding、Project Encoding、Default encoding for properties files 为 <code>UTF-8</code></li>
</ol>
<h3 id="显示快速文档"><a href="#显示快速文档" class="headerlink" title="显示快速文档"></a>显示快速文档</h3><ol>
<li>File | Settings 打开设置</li>
<li>选择 Editor | General</li>
<li>勾选 Show quick documentation on mouse move</li>
</ol>
<h3 id="设置启动项"><a href="#设置启动项" class="headerlink" title="设置启动项"></a>设置启动项</h3><ol>
<li>File | Settings 打开设置</li>
<li>选择 Appearance &amp; Behavior | System Settings</li>
<li>取消勾选 Reopen last project on startup 和 Confirm application exit</li>
<li>选择 Open project in new window</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>EditText显示明文与密码</title>
    <url>/2018/05/12/EditText%E6%98%BE%E7%A4%BA%E6%98%8E%E6%96%87%E4%B8%8E%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<h4 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h4><span id="more"></span>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initListener</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line">        mCbDisplayPassword.setOnCheckedChangeListener(<span class="keyword">new</span> <span class="title class_">CompoundButton</span>.OnCheckedChangeListener()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCheckedChanged</span><span class="params">(CompoundButton buttonView, <span class="type">boolean</span> isChecked)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (isChecked)</span><br><span class="line">                &#123;</span><br><span class="line">                    mEtPassword.setInputType(InputType.TYPE_TEXT_VARIATION_VISIBLE_PASSWORD);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    mEtPassword.setInputType(InputType.TYPE_CLASS_TEXT|InputType.TYPE_NUMBER_VARIATION_PASSWORD);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initListener</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">       mCbDisplayPassword.setOnCheckedChangeListener(<span class="keyword">new</span> <span class="title class_">CompoundButton</span>.OnCheckedChangeListener()</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCheckedChanged</span><span class="params">(CompoundButton buttonView, <span class="type">boolean</span> isChecked)</span></span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">if</span> (isChecked)</span><br><span class="line">               &#123;</span><br><span class="line">                   mEtPassword.setTransformationMethod(HideReturnsTransformationMethod.getInstance());</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">               &#123;</span><br><span class="line">                   mEtPassword.setTransformationMethod(PasswordTransformationMethod.getInstance());</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言文件操作详解</title>
    <url>/2019/05/20/C%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>C语言中没有输入输出语句，所有的输入输出功能都用 <code>ANSI C</code> 提供的一组标准库函数来实现。文件操作标准库函数有：</p>
<span id="more"></span>
<ul>
<li>文件的打开操作 <code>fopen</code> 打开一个文件</li>
<li>文件的关闭操作 <code>fclose</code> 关闭一个文件</li>
<li>文件的读写操作：<ol>
<li><code>fgetc</code> 从文件中读取一个字符</li>
<li><code>fputc</code> 写一个字符到文件中去</li>
<li><code>fgets</code> 从文件中读取一个字符串</li>
<li><code>fputs</code> 写一个字符串到文件中去</li>
<li><code>fprintf</code> 往文件中写格式化数据</li>
<li><code>fscanf</code> 格式化读取文件中数据</li>
<li><code>fread</code> 以二进制形式读取文件中的数据</li>
<li><code>fwrite</code> 以二进制形式写数据到文件中去</li>
<li><code>getw</code> 以二进制形式读取一个整数</li>
<li><code>putw</code> 以二进制形式存贮一个整数</li>
</ol>
</li>
<li>文件状态检查函数<ol>
<li><code>feof</code> 文件结束</li>
<li><code>ferror</code> 文件读、写出错</li>
<li><code>clearerr</code> 清除文件错误标志</li>
<li><code>ftell</code> 了解文件指针的当前位置</li>
</ol>
</li>
<li>文件定位函数<ol>
<li><code>rewind</code> 反绕</li>
<li><code>fseek</code> 随机定位</li>
</ol>
</li>
</ul>
<h3 id="文件的打开"><a href="#文件的打开" class="headerlink" title="文件的打开"></a>文件的打开</h3><h4 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">char</span> *pname,<span class="type">char</span> *mode)</span></span><br></pre></td></tr></table></figure></div>

<h4 id="功能说明"><a href="#功能说明" class="headerlink" title="功能说明"></a>功能说明</h4><p>按照 <code>mode</code> 规定的方式，打开由 <code>pname</code> 指定的文件。若找不到由 <code>pname</code> 指定的相应文件，就按以下方式之一处理：</p>
<ol>
<li>此时如 <code>mode</code> 规定按写方式打开文件，就按由 <code>pname</code> 指定的名字建立一个新文件；</li>
<li>此时如 <code>mode</code> 规定按读方式打开文件，就会产生一个错误。</li>
</ol>
<p>打开文件的作用是：</p>
<ol>
<li>分配给打开文件一个 <code>FILE</code> 类型的文件结构体变量，并将有关信息填入文件结构体变量；</li>
<li>开辟一个缓冲区；</li>
<li>调用操作系统提供的打开文件或建立新文件功能，打开或建立指定文件；</li>
</ol>
<p>**FILE ***：指出 <code>fopen</code> 是一个返回文件类型的指针函数；</p>
<h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><p><strong>pname</strong>：是一个字符指针，它将指向要打开或建立的文件的文件名字符串。<br><strong>mode</strong>：是一个指向文件处理方式字符串的字符指针。</p>
<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p><strong>正常返回</strong>：被打开文件的文件指针。<br><strong>异常返回</strong>：NULL，表示打开操作不成功。</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个名叫fp文件指针</span></span><br><span class="line">FILE *fp；</span><br><span class="line"><span class="comment">//判断按读方式打开一个名叫test的文件是否失败</span></span><br><span class="line"><span class="keyword">if</span>((fp=fopen（<span class="string">&quot;test&quot;</span>，<span class="string">&quot;r&quot;</span>）) == <span class="literal">NULL</span>)<span class="comment">//打开操作不成功</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The file can not be opened.\n&quot;</span>)；    　</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);<span class="comment">//结束程序的执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>要说明的是：C 语言将计算机的输入输出设备都看作是文件。例如，键盘文件、屏幕文件等。<code>ANSI C</code> 标准规定，在执行程序时系统先自动打开键盘、屏幕、错误三个文件。这三个文件的文件指针分别是：标准输入 <code>stdin</code>、标准输出 <code>stdout</code> 和标准出错 <code>stderr</code>。</p>
<h3 id="文件的关闭"><a href="#文件的关闭" class="headerlink" title="文件的关闭"></a>文件的关闭</h3><h4 id="函数原型-1"><a href="#函数原型-1" class="headerlink" title="函数原型"></a>函数原型</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">(FILE *fp)</span>；</span><br></pre></td></tr></table></figure></div>

<h4 id="功能说明-1"><a href="#功能说明-1" class="headerlink" title="功能说明"></a>功能说明</h4><p>关闭由 <code>fp</code> 指出的文件。此时调用操作系统提供的文件关闭功能，关闭由 <code>fp-&gt;fd</code> 指出的文件；释放由 <code>fp</code> 指出的文件类型结构体变量；返回操作结果，即 <code>0</code> 或 <code>EOF</code> 。</p>
<h4 id="参数说明-1"><a href="#参数说明-1" class="headerlink" title="参数说明"></a>参数说明</h4><p><strong>fp</strong>：一个已打开文件的文件指针。</p>
<h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><p><strong>正常返回</strong>：0。<br><strong>异常返回</strong>：<code>EOF</code>，表示文件在关闭时发生错误。</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n=fclose(fp);</span><br></pre></td></tr></table></figure></div>

<h3 id="文件的读写操作"><a href="#文件的读写操作" class="headerlink" title="文件的读写操作"></a>文件的读写操作</h3><p>从文件中读取一个字符</p>
<h4 id="函数原型-2"><a href="#函数原型-2" class="headerlink" title="函数原型"></a>函数原型</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(FILE *fp)</span>；</span><br></pre></td></tr></table></figure></div>

<h4 id="功能说明-2"><a href="#功能说明-2" class="headerlink" title="功能说明"></a>功能说明</h4><p>从 <code>fp</code> 所指文件中读取一个字符。</p>
<h4 id="参数说明-2"><a href="#参数说明-2" class="headerlink" title="参数说明"></a>参数说明</h4><p><strong>fp</strong>：这是个文件指针，它指出要从中读取字符的文件。</p>
<h4 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h4><p><strong>正常返回</strong>： 返回读取字符的代码。<br><strong>非正常返回</strong>：返回 <code>EOF</code> 。例如，要从”写打开”文件中读取一个字符时，会发生错误而返回一个 <code>EOF</code> 。</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>显示指定文件的内容：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//程序名为：display.c</span></span><br><span class="line"><span class="comment">//执行时可用：display filename1 形式的命令行运行。显示文件filename1中的内容。例如，执行命令行display display.c将在屏幕上显示display的原代码。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//File display program.</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span> <span class="comment">//命令行参数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ch;<span class="comment">//定义文件类型指针</span></span><br><span class="line">    FILE *fp;<span class="comment">//判断命令行是否正确</span></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error format,Usage: display filename1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">//键入了错误的命令行，结束程序的执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//按读方式打开由argv[1]指出的文件</span></span><br><span class="line">    <span class="keyword">if</span>((fp=fopen(argv[<span class="number">1</span>],<span class="string">&quot;r&quot;</span>))==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The file &lt;%s&gt; can not be opened.\n&quot;</span>,argv[<span class="number">1</span>]);<span class="comment">//打开操作不成功</span></span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">//结束程序的执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//成功打开了argv[1]所指文件</span></span><br><span class="line">    ch=fgetc(fp); <span class="comment">//从fp所指文件的当前指针位置读取一个字符</span></span><br><span class="line">    <span class="keyword">while</span>(ch!=EOF) <span class="comment">//判断刚读取的字符是否是文件结束符</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(ch); <span class="comment">//若不是结束符，将它输出到屏幕上显示</span></span><br><span class="line">        ch=fgetc(fp); <span class="comment">//继续从fp所指文件中读取下一个字符</span></span><br><span class="line">    &#125; <span class="comment">//完成将fp所指文件的内容输出到屏幕上显示</span></span><br><span class="line">    fclose(fp); <span class="comment">//关闭fp所指文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="写一个字符到文件中去"><a href="#写一个字符到文件中去" class="headerlink" title="写一个字符到文件中去"></a>写一个字符到文件中去</h3><h4 id="函数原型-3"><a href="#函数原型-3" class="headerlink" title="函数原型"></a>函数原型</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch,FILE *fp)</span></span><br></pre></td></tr></table></figure></div>
<h4 id="功能说明-3"><a href="#功能说明-3" class="headerlink" title="功能说明"></a>功能说明</h4><p>把 <code>ch</code> 中的字符写入由 <code>fp</code> 指出的文件中去。</p>
<h4 id="参数说明-3"><a href="#参数说明-3" class="headerlink" title="参数说明"></a>参数说明</h4><p><strong>ch</strong>：是一个整型变量，内存要写到文件中的字符（C语言中整型量和字符量可以通用）。<br><strong>fp</strong>：这是个文件指针，指出要在其中写入字符的文件。</p>
<h4 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h4><p><strong>正常返回</strong>： 要写入字符的代码。<br><strong>非正常返回</strong>：返回 <code>EOF</code> 。例如，要往”读打开”文件中写一个字符时，会发生错误而返回一个 <code>EOF</code> 。</p>
<h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><p>将一个文件的内容复制到另一个文件中去：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//程序名为：copyfile.c</span></span><br><span class="line"><span class="comment">//执行时可用：copyfile filename1 filename2形式的命令行运行，将文件filename1中的内容复制到文件filename2中去。</span></span><br><span class="line"><span class="comment">//file copy program.</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span> <span class="comment">//命令行参数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ch;</span><br><span class="line">    FILE *in,*out; <span class="comment">//定义in和out两个文件类型指针</span></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">3</span>) <span class="comment">//判断命令行是否正确</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error in format,Usage: copyfile filename1 filename2\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">//命令行错，结束程序的执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//按读方式打开由argv[1]指出的文件</span></span><br><span class="line">    <span class="keyword">if</span>((in=fopen(argv[<span class="number">1</span>],<span class="string">&quot;r&quot;</span>))==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The file &lt;%s&gt; can not be opened.\n&quot;</span>,argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">//打开失败，结束程序的执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//成功打开了argv[1]所指文件，再</span></span><br><span class="line">    <span class="comment">//按写方式打开由argv[2]指出的文件</span></span><br><span class="line">    <span class="keyword">if</span>((out=fopen(argv[<span class="number">2</span>],<span class="string">&quot;w&quot;</span>))==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The file %s can not be opened.\n&quot;</span>,argv[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">//打开失败，结束程序的执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//成功打开了argv[2]所指文件</span></span><br><span class="line">    ch=fgetc(in); <span class="comment">//从in所指文件的当前指针位置读取一个字符</span></span><br><span class="line">    <span class="keyword">while</span>(ch!=EOF) <span class="comment">//判断刚读取的字符是否是文件结束符</span></span><br><span class="line">    &#123;</span><br><span class="line">        fputc(ch,out); <span class="comment">//若不是结束符，将它写入out所指文件</span></span><br><span class="line">        ch=fgetc(in); <span class="comment">//继续从in所指文件中读取下一个字符</span></span><br><span class="line">    &#125; <span class="comment">//完成将in所指文件的内容写入（复制）到out所指文件中</span></span><br><span class="line">    fclose(in); <span class="comment">//关闭in所指文件</span></span><br><span class="line">    fclose(out); <span class="comment">//关闭out所指文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h4><p>按十进制和字符显示文件代码，若遇不可示字符就用井号”#”字符代替之：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//程序名为：dumpf.c</span></span><br><span class="line"><span class="comment">//执行时可用：dumpf filename1 形式的命令行运行。</span></span><br><span class="line"><span class="comment">// File dump program.</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">9</span>];</span><br><span class="line">    <span class="type">int</span> ch,count,i;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error format,Usage: dumpf filename\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((fp=fopen(argv[<span class="number">1</span>],<span class="string">&quot;r&quot;</span>))==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The file %s can not be opened.\n&quot;</span>,argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        i=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//按八进制输出第一列，作为一行八个字节的首地址</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%06o: &quot;</span>,count*<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="comment">// 从打开的文件中读取一个字符</span></span><br><span class="line">            ch=fgetc(fp);</span><br><span class="line">            <span class="comment">// 按十进制方式输出这个字符的ASCII码</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%4d&quot;</span>,ch);</span><br><span class="line">            <span class="comment">// 如果是不可示字符就用&quot;#&quot;字符代替</span></span><br><span class="line">            <span class="keyword">if</span>(ch&lt;<span class="string">&#x27; &#x27;</span>||ch&gt;<span class="string">&#x27;~&#x27;</span>) str[i]=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">            <span class="comment">// 如果是可示字符，就将它存入数组str以便形成字符串</span></span><br><span class="line">            <span class="keyword">else</span> str[i]=ch;</span><br><span class="line">            <span class="comment">// 保证每一行输出八个字符</span></span><br><span class="line">            <span class="keyword">if</span>(++i==<span class="number">8</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">while</span>(ch!=EOF); <span class="comment">// 遇到文件尾标志，结束读文件操作</span></span><br><span class="line">        str[i]=<span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 在数组str加字符串结束标志</span></span><br><span class="line">        <span class="keyword">for</span>(;i&lt;<span class="number">8</span>;i++) <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>); <span class="comment">// 一行不足八个字符用空格填充</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %s\n&quot;</span>,str); <span class="comment">// 输出字符串</span></span><br><span class="line">        count++; <span class="comment">// 准备输出下一行</span></span><br><span class="line">    &#125;<span class="keyword">while</span>(ch!=EOF); <span class="comment">// 直到文件结束</span></span><br><span class="line">    fclose(fp); <span class="comment">// 关闭fp所指文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="从文件中读取一个字符串"><a href="#从文件中读取一个字符串" class="headerlink" title="从文件中读取一个字符串"></a>从文件中读取一个字符串</h3><h4 id="函数原型-4"><a href="#函数原型-4" class="headerlink" title="函数原型"></a>函数原型</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">fgets</span><span class="params">(<span class="type">char</span> *str,<span class="type">int</span> n,FILE *fp)</span></span><br></pre></td></tr></table></figure></div>

<h4 id="功能说明-4"><a href="#功能说明-4" class="headerlink" title="功能说明"></a>功能说明</h4><p>从由 <code>fp</code> 指出的文件中读取 <code>n-1</code> 个字符，并把它们存放到由 <code>str</code> 指出的字符数组中去，最后加上一个字符串结束符 <code>&#39;\0&#39;</code> 。</p>
<h4 id="参数说明-4"><a href="#参数说明-4" class="headerlink" title="参数说明"></a>参数说明</h4><p><strong>str</strong>：接收字符串的内存地址，可以是数组名，也可以是指针。<br><strong>n</strong>： 指出要读取字符的个数。<br><strong>fp</strong>：这是个文件指针，指出要从中读取字符的文件。</p>
<h4 id="返回值-4"><a href="#返回值-4" class="headerlink" title="返回值"></a>返回值</h4><p><strong>正常返回</strong>：返回字符串的内存首地址，即 <code>str</code> 的值。<br><strong>非正常返回</strong>：返回一个 <code>NULL</code> 值，此时应当用 <code>feof()</code> 或 <code>ferror()</code> 函数来判别是读取到了文件尾，还是发生了错误。例如，要从”写打开”文件中读取字符串，将发生错误而返回一个 <code>NULL</code> 值。</p>
<h3 id="写一个字符串到文件中去"><a href="#写一个字符串到文件中去" class="headerlink" title="写一个字符串到文件中去"></a>写一个字符串到文件中去</h3><h4 id="函数原型-5"><a href="#函数原型-5" class="headerlink" title="函数原型"></a>函数原型</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">(<span class="type">char</span> *str,FILE *fp)</span></span><br></pre></td></tr></table></figure></div>

<h4 id="功能说明-5"><a href="#功能说明-5" class="headerlink" title="功能说明"></a>功能说明</h4><p>把由 <code>str</code> 指出的字符串写入到 <code>fp</code> 所指的文件中去。</p>
<h4 id="参数说明-5"><a href="#参数说明-5" class="headerlink" title="参数说明"></a>参数说明</h4><p><strong>str</strong>：指出要写到文件中去的字符串。<br><strong>fp</strong>：这是个文件指针，指出字符串要写入其中的文件。</p>
<h4 id="返回值-5"><a href="#返回值-5" class="headerlink" title="返回值"></a>返回值</h4><p><strong>正常返回</strong>： 写入文件的字符个数，即字符串的长度。<br><strong>非正常返回</strong>：返回一个 <code>NULL</code> 值，此时应当用 <code>feof()</code> 或 <code>ferror()</code> 函数来判别是读取到了文件尾，还是发生了错误。例如，要往一个”读打开” 文件中写字符串时，会发生错误而返回一个 <code>NULL</code> 值。</p>
<h4 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h4><p>以下程序将一个文件的内容附加到另一个文件中去：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//程序名：linkfile.c</span></span><br><span class="line"><span class="comment">//执行时可用：linkfile filename1 filename2形式的命令行运行，将文件filename2的内容附加在文件filename1之后。</span></span><br><span class="line"><span class="comment">// file linked program.</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 512</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buffer[SIZE];</span><br><span class="line">    FILE *fp1,*fp2;</span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: linkfile filename1 filename2\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 按追加方式打开argv[1] 所指文件</span></span><br><span class="line">    <span class="keyword">if</span>((fp1=fopen(argv[<span class="number">1</span>],<span class="string">&quot;a&quot;</span>))==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The file %s can not be opened.\n&quot;</span>,argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((fp2=fopen(argv[<span class="number">2</span>],<span class="string">&quot;r&quot;</span>))==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The file %s can not be opened.\n&quot;</span>,argv[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读入一行立即写出，直到文件结束</span></span><br><span class="line">    <span class="keyword">while</span>(fgets(buffer,SIZE,fp1)!=<span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buffer);</span><br><span class="line">    <span class="keyword">while</span>(fgets(buffer,SIZE,fp2)!=<span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">fputs</span>(buffer,fp1);</span><br><span class="line">    fclose(fp1);</span><br><span class="line">    fclose(fp2);</span><br><span class="line">    <span class="keyword">if</span>((fp1=fopen(argv[<span class="number">1</span>],<span class="string">&quot;r&quot;</span>))==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The file %s can not be opened.\n&quot;</span>,argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(fgets(buffer,SIZE,fp1)!=<span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buffer);</span><br><span class="line">    fclose(fp1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="往文件中写格式化数据"><a href="#往文件中写格式化数据" class="headerlink" title="往文件中写格式化数据"></a>往文件中写格式化数据</h3><h4 id="函数原型-6"><a href="#函数原型-6" class="headerlink" title="函数原型"></a>函数原型</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(FILE *fp,<span class="type">char</span> *format,arg_list)</span></span><br></pre></td></tr></table></figure></div>

<h4 id="功能说明-6"><a href="#功能说明-6" class="headerlink" title="功能说明"></a>功能说明</h4><p>将变量表列<code>（arg_list）</code>中的数据，按照 <code>format</code> 指出的格式，写入由 <code>fp</code> 指定的文件。<code>fprintf()</code> 函数与 <code>printf()</code> 函数的功能相同，只是 <code>printf()</code> 函数是将数据写入屏幕文件<code>（stdout）</code>。</p>
<h4 id="参数说明-6"><a href="#参数说明-6" class="headerlink" title="参数说明"></a>参数说明</h4><p><strong>fp</strong>：这是个文件指针，指出要将数据写入的文件。<br><strong>format</strong>：这是个指向字符串的字符指针，字符串中含有要写出数据的格式，所以该字符串成为格式串。格式串描述的规则与 <code>printf()</code> 函数中的格式串相同。<br><strong>arg_list</strong>：是要写入文件的变量表列，各变量之间用逗号分隔。</p>
<h4 id="返回值-6"><a href="#返回值-6" class="headerlink" title="返回值"></a>返回值</h4><p>无。</p>
<h4 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h4><p>下列程序的执行文件为 <code>display.exe</code> ，执行时键入命令行：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">display [-i][-s] filename</span><br></pre></td></tr></table></figure></div>

<p>下面的表格列出了命令行参数的含义及其功能：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//存储文件名：save.txt</span></span><br><span class="line"><span class="comment">//程序代码如下：</span></span><br><span class="line"><span class="comment">// file display program.</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> nAge,nClass;</span><br><span class="line">    <span class="type">long</span> number;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">if</span>((fp=fopen(<span class="string">&quot;student.txt&quot;</span>,<span class="string">&quot;w&quot;</span>))==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The file %s can not be opened.\n&quot;</span>,<span class="string">&quot;student.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fscanf</span>(<span class="built_in">stdin</span>,<span class="string">&quot;%s %d %d %ld&quot;</span>,name,&amp;nClass,&amp;nAge,&amp;number);</span><br><span class="line">    <span class="built_in">fprintf</span>(fp,<span class="string">&quot;%s %5d %4d %8ld&quot;</span>,name,nClass,nAge,number);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">if</span>((fp=fopen(<span class="string">&quot;student.txt&quot;</span>,<span class="string">&quot;r&quot;</span>))==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The file %s can not be opened.\n&quot;</span>,<span class="string">&quot;student.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fscanf</span>(fp,<span class="string">&quot;%s %d %d %ld&quot;</span>,name,&amp;nClass,&amp;nAge,&amp;number);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name nClass nAge number\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">&quot;%-10s%-8d%-6d%-8ld\n&quot;</span>,name,nClass,nAge,number);</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="以二进制形式读取文件中的数据"><a href="#以二进制形式读取文件中的数据" class="headerlink" title="以二进制形式读取文件中的数据"></a>以二进制形式读取文件中的数据</h3><h4 id="函数原型-7"><a href="#函数原型-7" class="headerlink" title="函数原型"></a>函数原型</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> *buffer,<span class="type">unsigned</span> sife,<span class="type">unsigned</span> count,FILE *fp)</span></span><br></pre></td></tr></table></figure></div>

<h4 id="功能说明-7"><a href="#功能说明-7" class="headerlink" title="功能说明"></a>功能说明</h4><p>从由 <code>fp</code> 指定的文件中，按二进制形式将 <code>sife*count</code> 个数据读到由 <code>buffer</code> 指出的数据区中。</p>
<h4 id="参数说明-7"><a href="#参数说明-7" class="headerlink" title="参数说明"></a>参数说明</h4><p><strong>buffer</strong>：这是一个 <code>void</code> 型指针，指出要将读入数据存放在其中的存储区首地址。<br><strong>sife</strong>：指出一个数据块的字节数，即一个数据块的大小尺寸。<br><strong>count</strong>：指出一次读入多少个数据块<code>（sife）</code>。<br><strong>fp</strong>：这是个文件指针，指出要从其中读出数据的文件。</p>
<h4 id="返回值-7"><a href="#返回值-7" class="headerlink" title="返回值"></a>返回值</h4><p><strong>正常返回</strong>：实际读取数据块的个数，即 <code>count</code> 。<br><strong>异常返回</strong>：如果文件中剩下的数据块个数少于参数中 <code>count</code> 指出的个数，或者发生了错误，返回0值。此时可以用 <code>feof()</code> 和 <code>ferror()</code> 来判定到底出现了什么情况。</p>
<h3 id="以二进制形式写数据到文件中去"><a href="#以二进制形式写数据到文件中去" class="headerlink" title="以二进制形式写数据到文件中去"></a>以二进制形式写数据到文件中去</h3><h4 id="函数原型-8"><a href="#函数原型-8" class="headerlink" title="函数原型"></a>函数原型</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">void</span> *buffer,<span class="type">unsigned</span> sife,<span class="type">unsigned</span> count,FILE *fp)</span></span><br></pre></td></tr></table></figure></div>

<h4 id="功能说明-8"><a href="#功能说明-8" class="headerlink" title="功能说明"></a>功能说明</h4><p>按二进制形式，将由 <code>buffer</code> 指定的数据缓冲区内的 <code>sife*count</code> 个数据写入由 <code>fp</code> 指定的文件中去。</p>
<h4 id="参数说明-8"><a href="#参数说明-8" class="headerlink" title="参数说明"></a>参数说明</h4><p><strong>buffer</strong>：这是一个 <code>void</code> 型指针，指出要将其中数据输出到文件的缓冲区首地址。<br><strong>sife</strong>：指出一个数据块的字节数，即一个数据块的大小尺寸。<br><strong>count</strong>：一次输出多少个数据块<code>（sife）</code>。<br><strong>fp</strong>：这是个文件指针，指出要从其中读出数据的文件。</p>
<h4 id="返回值-8"><a href="#返回值-8" class="headerlink" title="返回值"></a>返回值</h4><p><strong>正常返回</strong>：实际输出数据块的个数，即 <code>count</code> 。<br><strong>异常返回</strong>：返回0值，表示输出结束或发生了错误。</p>
<h4 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 4</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker</span></span></span><br><span class="line"><span class="class">&#123;</span> <span class="type">int</span> number;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">worker</span> <span class="title">wk</span>;</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    FILE *in,*out;</span><br><span class="line">    <span class="keyword">if</span>((in=fopen(<span class="string">&quot;file1.txt&quot;</span>,<span class="string">&quot;rb&quot;</span>))==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The file %s can not be opened.\n&quot;</span>,<span class="string">&quot;file1.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((out=fopen(<span class="string">&quot;file2.txt&quot;</span>,<span class="string">&quot;wb&quot;</span>))==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The file %s can not be opened.\n&quot;</span>,<span class="string">&quot;file2.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(fread(&amp;wk,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> worker),<span class="number">1</span>,in)==<span class="number">1</span>)</span><br><span class="line">        fwrite(&amp;wk,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> worker),<span class="number">1</span>,out);</span><br><span class="line">    fclose(in);</span><br><span class="line">    fclose(out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="以二进制形式读取一个整数"><a href="#以二进制形式读取一个整数" class="headerlink" title="以二进制形式读取一个整数"></a>以二进制形式读取一个整数</h3><h4 id="函数原型-9"><a href="#函数原型-9" class="headerlink" title="函数原型"></a>函数原型</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getw</span><span class="params">(FILE *fp)</span></span><br></pre></td></tr></table></figure></div>

<h4 id="功能说明-9"><a href="#功能说明-9" class="headerlink" title="功能说明"></a>功能说明</h4><p>从由 <code>fp</code> 指定的文件中，以二进制形式读取一个整数。</p>
<h4 id="参数说明-9"><a href="#参数说明-9" class="headerlink" title="参数说明"></a>参数说明</h4><p><strong>fp</strong>：是文件指针。</p>
<h4 id="返回值-9"><a href="#返回值-9" class="headerlink" title="返回值"></a>返回值</h4><p><strong>正常返回</strong>：所读取整数的值。<br><strong>异常返回</strong>：返回 <code>EOF</code> ，即 <code>-1</code> 。由于读取的整数值有可能是 <code>-1</code> ，所以必须用 <code>feof()</code> 或 <code>ferror()</code> 来判断是到了文件结束，还是出现了一个出错。</p>
<h4 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,sum=<span class="number">0</span>;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Command error,Usage: readfile filename\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!(fp=fopen(argv[<span class="number">1</span>],<span class="string">&quot;rb&quot;</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The file %s can not be opened.\n&quot;</span>,argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++) sum+=getw(fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The sum is %d\n&quot;</span>,sum);</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="以二进制形式存贮一个整数"><a href="#以二进制形式存贮一个整数" class="headerlink" title="以二进制形式存贮一个整数"></a>以二进制形式存贮一个整数</h3><h4 id="函数原型-10"><a href="#函数原型-10" class="headerlink" title="函数原型"></a>函数原型</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">putw</span><span class="params">(<span class="type">int</span> n,FILE *fp)</span></span><br></pre></td></tr></table></figure></div>

<h4 id="功能说明-10"><a href="#功能说明-10" class="headerlink" title="功能说明"></a>功能说明</h4><p>以二进制形式把由变量 <code>n</code> 指出的整数值存放到由 <code>fp</code> 指定的文件中。</p>
<h4 id="参数说明-10"><a href="#参数说明-10" class="headerlink" title="参数说明"></a>参数说明</h4><p><strong>n</strong>：要存入文件的整数。<br><strong>fp</strong>：是文件指针。</p>
<h4 id="返回值-10"><a href="#返回值-10" class="headerlink" title="返回值"></a>返回值</h4><p><strong>正常返回</strong>：所输出的整数值。<br><strong>异常返回</strong>：返回 <code>EOF</code> ，即 <code>-1</code> 。由于输出的整数值有可能是 <code>-1</code>，所以必须用 <code>feof()</code> 或 <code>ferror()</code> 来判断是到了文件结束，还是出现了一个出错。</p>
<h4 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a>实例</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Command error,Usage: writefile filename\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!(fp=fopen(argv[<span class="number">1</span>],<span class="string">&quot;wb&quot;</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The file %s can not be opened.\n&quot;</span>,argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, putw(i,fp));</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="文件状态检查"><a href="#文件状态检查" class="headerlink" title="文件状态检查"></a>文件状态检查</h3><p>文件结束</p>
<h4 id="函数原型-11"><a href="#函数原型-11" class="headerlink" title="函数原型"></a>函数原型</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">feof</span><span class="params">(FILE *fp)</span></span><br></pre></td></tr></table></figure></div>

<h4 id="功能说明-11"><a href="#功能说明-11" class="headerlink" title="功能说明"></a>功能说明</h4><p>该函数用来判断文件是否结束。</p>
<h4 id="参数说明-11"><a href="#参数说明-11" class="headerlink" title="参数说明"></a>参数说明</h4><p><strong>fp</strong>：文件指针。</p>
<h4 id="返回值-11"><a href="#返回值-11" class="headerlink" title="返回值"></a>返回值</h4><p><strong>0</strong>：假值，表示文件未结束。<br><strong>1</strong>：真值，表示文件结束。</p>
<h4 id="实例-8"><a href="#实例-8" class="headerlink" title="实例"></a>实例</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *in,*out;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: copyfile filename1 filename2\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((in=fopen(argv[<span class="number">1</span>],<span class="string">&quot;rb&quot;</span>))==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The file %s can not be opened.\n&quot;</span>,argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((out=fopen(argv[<span class="number">2</span>],<span class="string">&quot;wb&quot;</span>))==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The file %s can not be opened.\n&quot;</span>,argv[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!feof(in))</span><br><span class="line">    &#123;</span><br><span class="line">        ch=fgetc(in);</span><br><span class="line">        <span class="keyword">if</span>(ferror(in))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read error!\n&quot;</span>);</span><br><span class="line">            clearerr(in);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            fputc(ch,out);</span><br><span class="line">            <span class="keyword">if</span>(ferror(out))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;write error!\n&quot;</span>);</span><br><span class="line">                clearerr(out);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(in);</span><br><span class="line">    fclose(out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="文件读-x2F-写出错"><a href="#文件读-x2F-写出错" class="headerlink" title="文件读&#x2F;写出错"></a>文件读&#x2F;写出错</h3><h4 id="函数原型-12"><a href="#函数原型-12" class="headerlink" title="函数原型"></a>函数原型</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ferror</span><span class="params">(FILE *fp)</span></span><br></pre></td></tr></table></figure></div>

<h4 id="功能说明-12"><a href="#功能说明-12" class="headerlink" title="功能说明"></a>功能说明</h4><p>检查由 <code>fp</code> 指定的文件在读写时是否出错。</p>
<h4 id="参数说明-12"><a href="#参数说明-12" class="headerlink" title="参数说明"></a>参数说明</h4><p><strong>fp</strong>：文件指针。</p>
<h4 id="返回值-12"><a href="#返回值-12" class="headerlink" title="返回值"></a>返回值</h4><p><strong>0</strong>：假值，表示无错误。<br><strong>1</strong>：真值，表示出错。</p>
<h3 id="清除文件错误标志"><a href="#清除文件错误标志" class="headerlink" title="清除文件错误标志"></a>清除文件错误标志</h3><h4 id="函数原型-13"><a href="#函数原型-13" class="headerlink" title="函数原型"></a>函数原型</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">clearerr</span><span class="params">(FILE *fp)</span></span><br></pre></td></tr></table></figure></div>

<h4 id="功能说明-13"><a href="#功能说明-13" class="headerlink" title="功能说明"></a>功能说明</h4><p>清除由 <code>fp</code> 指定文件的错误标志。</p>
<h4 id="参数说明-13"><a href="#参数说明-13" class="headerlink" title="参数说明"></a>参数说明</h4><p><strong>fp</strong>：文件指针。</p>
<h4 id="返回值-13"><a href="#返回值-13" class="headerlink" title="返回值"></a>返回值</h4><p>无。</p>
<h4 id="实例-9"><a href="#实例-9" class="headerlink" title="实例"></a>实例</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *in,*out;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: copyfile filename1 filename2\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((in=fopen(argv[<span class="number">1</span>],<span class="string">&quot;rb&quot;</span>))==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The file %s can not be opened.\n&quot;</span>,argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((out=fopen(argv[<span class="number">2</span>],<span class="string">&quot;wb&quot;</span>))==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The file %s can not be opened.\n&quot;</span>,argv[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!feof(in))</span><br><span class="line">    &#123;</span><br><span class="line">        ch=fgetc(in);</span><br><span class="line">        <span class="keyword">if</span>(ferror(in))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read error!\n&quot;</span>);</span><br><span class="line">            clearerr(in);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            fputc(ch,out);</span><br><span class="line">            <span class="keyword">if</span>(ferror(out))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;write error!\n&quot;</span>);</span><br><span class="line">                clearerr(out);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(in);</span><br><span class="line">    fclose(out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="了解文件指针的当前位置"><a href="#了解文件指针的当前位置" class="headerlink" title="了解文件指针的当前位置"></a>了解文件指针的当前位置</h3><h4 id="函数原型-14"><a href="#函数原型-14" class="headerlink" title="函数原型"></a>函数原型</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">ftell</span><span class="params">(FILE *fp)</span></span><br></pre></td></tr></table></figure></div>

<h4 id="功能说明-14"><a href="#功能说明-14" class="headerlink" title="功能说明"></a>功能说明</h4><p>取得由 <code>fp</code> 指定文件的当前读&#x2F;写位置，该位置值用相对于文件开头的位移量来表示。</p>
<h4 id="参数说明-14"><a href="#参数说明-14" class="headerlink" title="参数说明"></a>参数说明</h4><p><strong>fp</strong>：文件指针。</p>
<h4 id="返回值-14"><a href="#返回值-14" class="headerlink" title="返回值"></a>返回值</h4><p><strong>正常返回</strong>：位移量（这是个长整数）。<br><strong>异常返回</strong>：-1，表示出错。</p>
<h3 id="文件定位"><a href="#文件定位" class="headerlink" title="文件定位"></a>文件定位</h3><p>反绕</p>
<h4 id="函数原型-15"><a href="#函数原型-15" class="headerlink" title="函数原型"></a>函数原型</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rewind</span><span class="params">(FILE *fp)</span></span><br></pre></td></tr></table></figure></div>

<h4 id="功能说明-15"><a href="#功能说明-15" class="headerlink" title="功能说明"></a>功能说明</h4><p>使由文件指针 <code>fp</code> 指定的文件的位置指针重新指向文件的开头位置。</p>
<h4 id="参数说明-15"><a href="#参数说明-15" class="headerlink" title="参数说明"></a>参数说明</h4><p><strong>fp</strong>：文件指针。</p>
<h4 id="返回值-15"><a href="#返回值-15" class="headerlink" title="返回值"></a>返回值</h4><p>无。</p>
<h4 id="实例-10"><a href="#实例-10" class="headerlink" title="实例"></a>实例</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *in,*out;</span><br><span class="line">    in=fopen(<span class="string">&quot;filename1&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    out=fopen(<span class="string">&quot;filename2&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(!feof(in)) fputc(fgetc(in),out);</span><br><span class="line">    rewind(out);</span><br><span class="line">    <span class="keyword">while</span>(!feof(in)) <span class="built_in">putchar</span>(fgetc(in));</span><br><span class="line">    fclose(in);</span><br><span class="line">    fclose(out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="随机定位"><a href="#随机定位" class="headerlink" title="随机定位"></a>随机定位</h3><h4 id="函数原型-16"><a href="#函数原型-16" class="headerlink" title="函数原型"></a>函数原型</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fseek</span><span class="params">(FILE *fp,<span class="type">long</span> offset,<span class="type">int</span> base)</span></span><br></pre></td></tr></table></figure></div>

<h4 id="功能说明-16"><a href="#功能说明-16" class="headerlink" title="功能说明"></a>功能说明</h4><p>使文件指针 <code>fp</code> 移到基于 <code>base</code> 的相对位置 <code>offset</code> 处。</p>
<h4 id="参数说明-16"><a href="#参数说明-16" class="headerlink" title="参数说明"></a>参数说明</h4><p><strong>fp</strong>：文件指针。<br><strong>offset</strong>：相对 <code>base</code> 的字节位移量。这是个长整数，用以支持大于 <code>64KB</code> 的文件。<br><strong>base</strong>：文件位置指针移动的基准位置，是计算文件位置指针位移的基点。<code>ANSI C</code> 定义了<code>base</code>的可能取值，以及这些取值的符号常量。</p>
<h4 id="返回值-16"><a href="#返回值-16" class="headerlink" title="返回值"></a>返回值</h4><p><strong>正常返回</strong>：当前指针位置。<br><strong>异常返回</strong>：-1，表示定位操作出错。</p>
<h4 id="实例-11"><a href="#实例-11" class="headerlink" title="实例"></a>实例</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">std_type</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> <span class="class"><span class="keyword">class</span>;</span></span><br><span class="line">&#125;stud;</span><br><span class="line"><span class="type">int</span> <span class="title function_">cstufile</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">if</span>((fp=fopen(<span class="string">&quot;stufile&quot;</span>,<span class="string">&quot;wb&quot;</span>))==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The file can&#x27;t be opened for write.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        stud.num=i;</span><br><span class="line">        <span class="built_in">strcpy</span>(stud.name,<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">        stud.age=<span class="number">17</span>;</span><br><span class="line">        stud.class=<span class="string">&#x27;8&#x27;</span>;</span><br><span class="line">        fwrite(&amp;stud,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> std_type),<span class="number">1</span>,fp);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">if</span>(cstufile()==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>((fp=fopen(<span class="string">&quot;stufile&quot;</span>,<span class="string">&quot;rb&quot;</span>))==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The file can not be opened.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(n=<span class="number">0</span>;n&lt;<span class="number">100</span>;n+=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fseek(fp,n*<span class="keyword">sizeof</span>(<span class="keyword">struct</span> std_type),SEEK_SET);</span><br><span class="line">        fread(&amp;stud,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> std_type),<span class="number">1</span>,fp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%10d%20s%10d%4c\n&quot;</span>,stud.num,stud.name,stud.age,stud.class);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="关于exit-函数"><a href="#关于exit-函数" class="headerlink" title="关于exit()函数"></a>关于exit()函数</h3><h4 id="函数原型-17"><a href="#函数原型-17" class="headerlink" title="函数原型"></a>函数原型</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span></span><br></pre></td></tr></table></figure></div>

<h4 id="功能说明-17"><a href="#功能说明-17" class="headerlink" title="功能说明"></a>功能说明</h4><p><code>exit()</code> 函数使程序立即终止执行，同时将缓冲区中剩余的数据输出并关闭所有已经打开的文件。</p>
<h4 id="参数说明-17"><a href="#参数说明-17" class="headerlink" title="参数说明"></a>参数说明</h4><p><strong>status</strong>：为0值表示程序正常终止，为非0值表示一个定义错误。</p>
<h4 id="返回值-17"><a href="#返回值-17" class="headerlink" title="返回值"></a>返回值</h4><p>无。</p>
<h3 id="关于feof-函数"><a href="#关于feof-函数" class="headerlink" title="关于feof()函数"></a>关于feof()函数</h3><h4 id="函数原型-18"><a href="#函数原型-18" class="headerlink" title="函数原型"></a>函数原型</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">feof</span><span class="params">(FILE *fp)</span></span><br></pre></td></tr></table></figure></div>

<h4 id="功能说明-18"><a href="#功能说明-18" class="headerlink" title="功能说明"></a>功能说明</h4><p>在文本文件（ASCII文件）中可以用值为 <code>-1</code> 的符号常量 <code>EOF</code> 来作为文件的结束符。但是在二进制文件中 <code>-1</code> 往往可能是一个有意义的数据，因此不能用它来作为文件的结束标志。为了能有效判别文件是否结束，<code>ANSI C</code> 提供了标准函数 <code>feof()</code> ，用来识别文件是否结束。</p>
<h4 id="参数说明-18"><a href="#参数说明-18" class="headerlink" title="参数说明"></a>参数说明</h4><p><strong>fp</strong>：文件指针。</p>
<h4 id="返回值-18"><a href="#返回值-18" class="headerlink" title="返回值"></a>返回值</h4><p><strong>返回为非0值</strong>：已到文件尾。<br><strong>返回为0值</strong>：表示还未到文件尾。</p>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Git使用笔记</title>
    <url>/2018/03/17/Git%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="设置配置"><a href="#设置配置" class="headerlink" title="设置配置"></a>设置配置</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global user.name <span class="string">&quot;Your Name&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global user.email <span class="string">&quot;email@example.com&quot;</span></span></span><br></pre></td></tr></table></figure></div>
 <span id="more"></span>
<p><strong>注意git config命令的–global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址</strong></p>
<h3 id="创建SSH-Key"><a href="#创建SSH-Key" class="headerlink" title="创建SSH Key"></a>创建SSH Key</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh-keygen -t ed25519 -C <span class="string">&quot;youremail@example.com&quot;</span></span></span><br></pre></td></tr></table></figure></div>
<p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。<br>如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</p>
<h3 id="测试是否可以正常连接"><a href="#测试是否可以正常连接" class="headerlink" title="测试是否可以正常连接"></a>测试是否可以正常连接</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ssh -T git@git.coding.net  #Coding</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com  #Github</span><br></pre></td></tr></table></figure></div>
<h3 id="设置Git代理"><a href="#设置Git代理" class="headerlink" title="设置Git代理"></a>设置Git代理</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy http://127.0.0.1:1080</span><br><span class="line">git config --global https.proxy https://127.0.0.1:1080</span><br></pre></td></tr></table></figure></div>
<h3 id="取消Git代理"><a href="#取消Git代理" class="headerlink" title="取消Git代理"></a>取消Git代理</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure></div>

<h3 id="忽略文件名大小写"><a href="#忽略文件名大小写" class="headerlink" title="忽略文件名大小写"></a>忽略文件名大小写</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">git config core.ignorecase true</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中==和equals和hashCode的区别</title>
    <url>/2019/03/13/Java%E4%B8%AD==%E5%92%8Cequals%E5%92%8ChashCode%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h3 id="Java中的数据类型"><a href="#Java中的数据类型" class="headerlink" title="Java中的数据类型"></a>Java中的数据类型</h3><ol>
<li>基本数据类型，也称原始数据类型</li>
</ol>
<p>byte、short、char、int、long、float、double、boolean 他们之间的比较，应用双等号（&#x3D;&#x3D;），比较的是他们的值。</p>
<span id="more"></span>

<ol start="2">
<li>引用类型(类、接口、数组)</li>
</ol>
<p>当他们用（&#x3D;&#x3D;）进行比较的时候，比较的是他们在内存中的存放地址，所以，除非是同一个new出来的对象，他们的比较后的结果为true，否则比较后结果为false。</p>
<p>对象是放在堆中的，栈中存放的是对象的引用（地址）。由此可见“&#x3D;&#x3D;”是对栈中的值进行比较的。如果要比较堆中对象的内容是否相同，那么就要重写equals方法了。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">int1</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">int2</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">Integer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">12</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">Integer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">12</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">Integer3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">127</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;str&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;str&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;int1==int2:&quot;</span> + (int1 == int2));</span><br><span class="line">        System.out.println(<span class="string">&quot;int1==Integer1:&quot;</span> + (int1 == Integer1));</span><br><span class="line">        System.out.println(<span class="string">&quot;Integer1==Integer2:&quot;</span> + (Integer1 == Integer2));</span><br><span class="line">        System.out.println(<span class="string">&quot;Integer3==b1:&quot;</span> + (Integer3 == b1));</span><br><span class="line">        System.out.println(<span class="string">&quot;a1==b1:&quot;</span> + (a1 == b1));</span><br><span class="line">        System.out.println(<span class="string">&quot;a==b:&quot;</span> + (a == b));</span><br><span class="line">        System.out.println(<span class="string">&quot;s1==s2:&quot;</span> + (s1 == s2));</span><br><span class="line">        System.out.println(<span class="string">&quot;s1==str1:&quot;</span> + (s1 == str1));</span><br><span class="line">        System.out.println(<span class="string">&quot;str1==str2:&quot;</span> + (str1 == str2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>输出：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">int1==int2:true</span><br><span class="line">int1==Integer1:true   //Integer会自动拆箱为int，所以为true</span><br><span class="line">Integer1==Integer2:false   //不同对象，在内存存放地址不同，所以为false</span><br><span class="line">Integer3==b1:false   //Integer3指向new的对象地址，b1指向缓存中127地址，地址不同，所以为false</span><br><span class="line">a1==b1:true</span><br><span class="line">a==b:false</span><br><span class="line">s1==s2:true</span><br><span class="line">s1==str1:false</span><br><span class="line">str1==str2:false</span><br></pre></td></tr></table></figure></div>

<p>Integer b1 &#x3D; 127；java在编译的时候，被翻译成-&gt;Integer b1 &#x3D; Integer.valueOf(127)；</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">     <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">     <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">         <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>

<p>对于-128到127之间的数，会进行缓存，Integer b1 &#x3D; 127时，会将127进行缓存，下次再写Integer i6 &#x3D; 127时，就会直接从缓存中取，就不会new了。所以 a1&#x3D;&#x3D;b1:true    a&#x3D;&#x3D;b:false。</p>
<h3 id="Java中的equals方法解析"><a href="#Java中的equals方法解析" class="headerlink" title="Java中的equals方法解析"></a>Java中的equals方法解析</h3><p>默认情况（没有覆盖equals方法）下equals方法都是调用Object类的equals方法，而Object的equals方法主要用于判断对象的内存地址引用是不是同一个地址（是不是同一个对象）。下面是Object类中equals方法，</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>定义的equals与&#x3D;&#x3D;是等效的</p>
<p>要是类中覆盖了equals方法，那么就要根据具体的代码来确定equals方法的作用了，覆盖后一般都是通过对象的内容是否相等来判断对象是否相等。下面是String类对equals进行了重写；</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object anObject)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">anotherString</span> <span class="operator">=</span> (String)anObject;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> count;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.count) &#123;</span><br><span class="line">        <span class="type">char</span> v1[] = value;</span><br><span class="line">        <span class="type">char</span> v2[] = anotherString.value;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> offset;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> anotherString.offset;</span><br><span class="line">        <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v1[i++] != v2[j++])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>即String中equals方法判断相等的步骤是：</strong></p>
<ol>
<li>若A&#x3D;&#x3D;B 即是同一个String对象 返回true</li>
<li>若对比对象是String类型则继续，否则返回false</li>
<li>判断A、B长度是否一样，不一样的话返回false</li>
<li>逐个字符比较，若有不相等字符，返回false</li>
</ol>
<p><strong>这里对equals重新需要注意五点：</strong></p>
<ol>
<li>自反性：对任意引用值x，x.equals(x)的返回值一定为true。</li>
<li>对称性：对于任何引用值x、y，当且仅当y.equals(x)返回值为true时，x.equals(y)的返回值一定为true。</li>
<li>传递性：如果x.equals(y)&#x3D;true， y.equals(z)&#x3D;true，则x.equals(z)&#x3D;true。</li>
<li>一致性：如果参与比较的对象没任何改变，则对象比较的结果也不应该有任何改变。</li>
<li>非空性：任何非空的引用值X，x.equals(null)的返回值一定为false。</li>
</ol>
<p><strong>实现高质量equals方法的诀窍：</strong></p>
<blockquote>
<ol>
<li>使用&#x3D;&#x3D;符号检查“参数是否为这个对象的引用”。如果是，则返回true。这只不过是一种性能优化，如果比较操作有可能很昂贵，就值得这么做。</li>
<li>使用instanceof操作符检查“参数是否为正确的类型”。如果不是，则返回false。一般来说，所谓“正确的类型”是指equals方法所在的那个类。</li>
<li>把参数转换成正确的类型。因为转换之前进行过instanceof测试，所以确保会成功。</li>
<li>对于该类中的每个“关键”域，检查参数中的域是否与该对象中对应的域相匹配。如果这些测试全部成功，则返回true;否则返回false。</li>
<li>当编写完成了equals方法之后，检查“对称性”、“传递性”、“一致性”。</li>
</ol>
</blockquote>
<h3 id="hashCode方法解析"><a href="#hashCode方法解析" class="headerlink" title="hashCode方法解析"></a>hashCode方法解析</h3><p>hashCode()方法返回的就是一个数值，从方法的名称上就可以看出，其目的是生成一个hash码。hash码的主要用途就是在对对象进行散列的时候作为key输入，据此很容易推断出，我们需要每个对象的hash码尽可能不同，这样才能保证散列的存取性能。事实上，Object类提供的默认实现确实保证每个对象的hash码不同（在对象的内存地址基础上经过特定算法返回一个hash码）。Java采用了哈希表的原理。哈希（Hash）实际上是个人名，由于他提出一哈希算法的概念，所以就以他的名字命名了。 哈希算法也称为散列算法，是将数据依特定算法直接指定到一个地址上。初学者可以这样理解，hashCode方法实际上返回的就是对象存储的物理地址（实际可能并不是）。</p>
<h3 id="散列函数、散列算法、哈希函数"><a href="#散列函数、散列算法、哈希函数" class="headerlink" title="散列函数、散列算法、哈希函数"></a>散列函数、散列算法、哈希函数</h3><p>是一种从任何一种数据中创建小的数字“指纹”的方法。 散列函数将任意长度的二进制值映射为较短的固定长度的二进制值，这个小的二进制值称为哈希值。 好的散列函数在输入域中很少出现散列冲突。 所有散列函数都有如下一个基本特性：</p>
<ul>
<li>如果a&#x3D;b，则h(a) &#x3D; h(b)。</li>
<li>如果a!&#x3D;b，则h(a)与h(b)可能得到相同的散列值。</li>
</ul>
<p>Object 的hashCode方法：返回一个int类型</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></div>

<p>hashCode的作用 想要明白，必须要先知道Java中的集合。总的来说，Java中的集合（Collection）有两类，一类是List，再有一类是Set。前者集合内的元素是有序的，元素可以重复；后者元素无序，但元素不可重复。</p>
<p>那么这里就有一个比较严重的问题了：要想保证元素不重复，可两个元素是否重复应该依据什么来判断呢？</p>
<p>这就是Object.equals方法了。但是，如果每增加一个元素就检查一次，那么当元素很多时，后添加到集合中的元素比较的次数就非常多了。也就是说，如果集合中现在已经有1000个元素，那么第1001个元素加入集合时，它就要调用1000次equals方法。这显然会大大降低效率。 于是，Java采用了哈希表的原理。</p>
<p>这样一来，当集合要添加新的元素时，</p>
<p>先调用这个元素的hashCode方法，就一下子能定位到它应该放置的物理位置上。 如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存，不相同就散列其它的地址。所以这里存在一个冲突解决的问题。这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。</p>
<h3 id="eqauls方法和hashCode方法关系"><a href="#eqauls方法和hashCode方法关系" class="headerlink" title="eqauls方法和hashCode方法关系"></a>eqauls方法和hashCode方法关系</h3><p>Java对于eqauls方法和hashCode方法是这样规定的：</p>
<ul>
<li>同一对象上多次调用hashCode()方法，总是返回相同的整型值。</li>
<li>如果a.equals(b)，则一定有a.hashCode() 一定等于 b.hashCode()。</li>
<li>如果!a.equals(b)，则a.hashCode() 不一定等于b.hashCode()。此时如果a.hashCode() 总是不等于 b.hashCode()，会提高hashtables的性能。</li>
<li>a.hashCode()&#x3D;&#x3D;b.hashCode() 则 a.equals(b)可真可假。</li>
<li>a.hashCode()！&#x3D; b.hashCode() 则 a.equals(b)为假。</li>
</ul>
<p><strong>上面结论简记：</strong></p>
<blockquote>
<ul>
<li>如果两个对象equals，Java运行时环境会认为他们的hashcode一定相等。</li>
<li>如果两个对象不equals，他们的hashcode有可能相等。</li>
<li>如果两个对象hashcode相等，他们不一定equals。</li>
<li>如果两个对象hashcode不相等，他们一定不equals。</li>
</ul>
</blockquote>
<p><strong>关于这两个方法的重要规范：</strong></p>
<blockquote>
<ol>
<li>若重写equals(Object obj)方法，有必要重写hashcode()方法，确保通过equals(Object obj)方法判断结果为true的两个对象具备相等的hashcode()返回值。说得简单点就是：“如果两个对象相同，那么他们的hashcode应该相等”。不过请注意：这个只是规范，如果你非要写一个类让equals(Object obj)返回true而hashcode()返回两个不相等的值，编译和运行都是不会报错的。不过这样违反了Java规范，程序也就埋下了BUG。</li>
<li>如果equals(Object obj)返回false，即两个对象“不相同”，并不要求对这两个对象调用hashcode()方法得到两个不相同的数。说的简单点就是：“如果两个对象不相同，他们的hashcode可能相同”。</li>
</ol>
</blockquote>
<h3 id="为什么覆盖equals时总要覆盖hashCode"><a href="#为什么覆盖equals时总要覆盖hashCode" class="headerlink" title="为什么覆盖equals时总要覆盖hashCode"></a>为什么覆盖equals时总要覆盖hashCode</h3><p>一个很常见的错误根源在于没有覆盖hashCode方法。在每个覆盖了equals方法的类中，也必须覆盖hashCode方法。如果不这样做的话，就会违反Object.hashCode的通用约定，从而导致该类无法结合所有基于散列的集合一起正常运作，这样的集合包括HashMap、HashSet和Hashtable。</p>
<blockquote>
<ol>
<li>在应用程序的执行期间，只要对象的equals方法的比较操作所用到的信息没有被修改，那么对这同一个对象调用多次，hashCode方法都必须始终如一地返回同一个整数。在同一个应用程序的多次执行过程中，每次执行所返回的整数可以不一致。</li>
<li>如果两个对象根据equals()方法比较是相等的，那么调用这两个对象中任意一个对象的hashCode方法都必须产生同样的整数结果。</li>
<li>如果两个对象根据equals()方法比较是不相等的，那么调用这两个对象中任意一个对象的hashCode方法，则不一定要产生相同的整数结果。但是程序员应该知道，给不相等的对象产生截然不同的整数结果，有可能提高散列表的性能。</li>
</ol>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>equals方法用于比较对象的内容是否相等（覆盖以后）</li>
<li>hashcode方法只有在集合中用到</li>
<li>当覆盖了equals方法时，比较对象是否相等将通过覆盖后的equals方法进行比较（判断对象的内容是否相等）</li>
<li>将对象放入到集合中时，首先判断要放入对象的hashcode值与集合中的任意一个元素的hashcode值是否相等，如果不相等直接将该对象放入集合中。如果hashcode值相等，然后再通过equals方法判断要放入对象与集合中的任意一个对象是否相等，如果equals判断不相等，直接将该元素放入到集合中，否则不放入。</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java NIO工作原理及代码示例</title>
    <url>/2019/03/14/Java%20NIO%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<p>简介：本文主要介绍了JAVA NIO中的Buffer, Channel, Selector的工作原理以及使用它们的若干注意事项，最后是利用它们实现服务器和客户端通信的代码实例。</p>
<span id="more"></span>

<h2 id="ByteBuffer"><a href="#ByteBuffer" class="headerlink" title="ByteBuffer"></a>ByteBuffer</h2><h3 id="直接缓冲区和非直接缓冲区"><a href="#直接缓冲区和非直接缓冲区" class="headerlink" title="直接缓冲区和非直接缓冲区"></a>直接缓冲区和非直接缓冲区</h3><p>下面是创建<code>ByteBuffer</code>对象的几种方式</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> ByteBuffer <span class="title function_">allocate</span><span class="params">(<span class="type">int</span> capacity)</span></span><br><span class="line"><span class="keyword">static</span> ByteBuffer <span class="title function_">allocateDirect</span><span class="params">(<span class="type">int</span> capacity)</span></span><br><span class="line"><span class="keyword">static</span> ByteBuffer <span class="title function_">wrap</span><span class="params">(<span class="type">byte</span>[] array)</span></span><br><span class="line"><span class="keyword">static</span> ByteBuffer <span class="title function_">wrap</span><span class="params">(<span class="type">byte</span>[] array, <span class="type">int</span> offset, <span class="type">int</span> length)</span>    </span><br></pre></td></tr></table></figure></div>

<p>allocate方式创建的ByteBuffer对象我们称之为非直接缓冲区，这个ByteBuffer对象(和对象包含的缓冲数组)都位于JVM的堆区。wrap方式和allocate方式创建的ByteBuffer没有本质区别，都创建的是非直接缓冲区。</p>
<p>allocateDirect方法创建的ByteBuffer我们称之为直接缓冲区，此时ByteBuffer对象本身在堆区，而缓冲数组位于非堆区， ByteBuffer对象内部存储了这个非堆缓冲数组的地址。在非堆区的缓冲数组可以通过JNI（内部还是系统调用）方式进行IO操作，JNI不受gc影响，机器码执行速度也比较快，同时还避免了JVM堆区与操作系统内核缓冲区的数据拷贝，所以IO速度比非直接缓冲区快。然而allocateDirect方式创建ByteBuffer对象花费的时间和回收该对象花费的时间比较多，所以这个方法适用于创建那些需要重复使用的缓冲区对象。</p>
<h3 id="重要属性和方法"><a href="#重要属性和方法" class="headerlink" title="重要属性和方法"></a>重要属性和方法</h3><p>ByteBuffer对象三个重要属性 position, limit和capacity。其中capacity表示了缓冲区的总容量，始终保持不变，初始时候position 等于 0 , limit 等于 capacity</p>
<h4 id="put：向缓冲区放入数据"><a href="#put：向缓冲区放入数据" class="headerlink" title="put：向缓冲区放入数据"></a>put：向缓冲区放入数据</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> ByteBuffer <span class="title function_">put</span><span class="params">(<span class="type">byte</span> b)</span></span><br><span class="line">ByteBuffer <span class="title function_">put</span><span class="params">(<span class="type">byte</span>[] src)</span></span><br><span class="line">ByteBuffer <span class="title function_">put</span><span class="params">(<span class="type">byte</span>[] src, <span class="type">int</span> offset, <span class="type">int</span> length)</span></span><br></pre></td></tr></table></figure></div>

<p>调用put方法前，limit应该等于capacity，如果不等于，几乎可以肯定我们对缓冲区的操作有误。在put方法中0到position-1的区域表示有效数据,position到limit之间区域表示空闲区域。put方法会从position的当前位置放入数据，每放入一个数据position增加1，当position等于limit（即空闲区域使用完）时还继续放入数据就会抛出BufferUnderflowException异常</p>
<h4 id="get：从缓冲区读取数据"><a href="#get：从缓冲区读取数据" class="headerlink" title="get：从缓冲区读取数据"></a>get：从缓冲区读取数据</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="type">byte</span> <span class="title function_">get</span><span class="params">()</span></span><br><span class="line">ByteBuffer <span class="title function_">get</span><span class="params">(<span class="type">byte</span>[] dst)</span></span><br><span class="line">ByteBuffer <span class="title function_">get</span><span class="params">(<span class="type">byte</span>[] dst, <span class="type">int</span> offset, <span class="type">int</span> length)</span></span><br></pre></td></tr></table></figure></div>

<p>在get方法中， 0到position-1的区域表示已读数据,position到limit之间的区域表示未读取的数据。每读取一个数据position增加1，当position等于limit时继续读取数据就会抛出BufferUnderflowException异常。</p>
<h4 id="flip-：将写模式转换成读模式"><a href="#flip-：将写模式转换成读模式" class="headerlink" title="flip ：将写模式转换成读模式"></a>flip ：将写模式转换成读模式</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">flip</span><span class="params">()</span> &#123;</span><br><span class="line">    limit = position;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="clear：清空缓冲区，将读模式转换写模式"><a href="#clear：清空缓冲区，将读模式转换写模式" class="headerlink" title="clear：清空缓冲区，将读模式转换写模式"></a>clear：清空缓冲区，将读模式转换写模式</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    limit = capacity;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="compact：保留未读取的数据，将读模式转换写模式"><a href="#compact：保留未读取的数据，将读模式转换写模式" class="headerlink" title="compact：保留未读取的数据，将读模式转换写模式"></a>compact：保留未读取的数据，将读模式转换写模式</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ByteBuffer <span class="title function_">compact</span><span class="params">()</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> position();</span><br><span class="line">    <span class="type">int</span> <span class="variable">lim</span> <span class="operator">=</span> limit();</span><br><span class="line">    <span class="keyword">assert</span> (pos &lt;= lim);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rem</span> <span class="operator">=</span> (pos &lt;= lim ? lim - pos : <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    unsafe.copyMemory(ix(pos), ix(<span class="number">0</span>), (<span class="type">long</span>)rem &lt;&lt; <span class="number">0</span>);</span><br><span class="line">    position(rem);</span><br><span class="line">    limit(capacity());</span><br><span class="line">    discardMark();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="mark：保存当前position的位置到mark变量"><a href="#mark：保存当前position的位置到mark变量" class="headerlink" title="mark：保存当前position的位置到mark变量"></a>mark：保存当前position的位置到mark变量</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">mark</span><span class="params">()</span> &#123;</span><br><span class="line">    mark = position;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="rest：将position置为mark变量中的值"><a href="#rest：将position置为mark变量中的值" class="headerlink" title="rest：将position置为mark变量中的值"></a>rest：将position置为mark变量中的值</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">reset</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> mark;</span><br><span class="line">    <span class="keyword">if</span> (m &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidMarkException</span>();</span><br><span class="line">    position = m;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>mark方法和rest方法联合使用可实现从指定位置的重读。</p>
<h4 id="rewind：从头开始重读"><a href="#rewind：从头开始重读" class="headerlink" title="rewind：从头开始重读"></a>rewind：从头开始重读</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">rewind</span><span class="params">()</span> &#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>ByteBuffer对象使用时又很多需要注意的地方，自认为这个API设计的不是很友好。比如一定不能连续两次调用flip和compact方法,flip方法调用以后不能再调用put方法，等等。要避免这些错误，只能在使用ByteBuffer前弄清楚当前缓冲区中0到position-1以及position到limit中数据表示的含义，这才是避免bug的根本办法。</p>
<p>从上面的介绍中我们可以看出，ByteBuffer对象既可以读，也可以写。除非我们能保证在读操作一次性使用完ByteBuffer对象中的所有数据，并且保证写入ByteBuffer对象向中的内容全部写入完成，否则同时用于读写的ByteBuffer对象会造成数据的混乱和错误。<strong>一般来说，我们都会创建两个ByteBuffer对象向，一个用于接收数据，另一个用于发送数据。</strong></p>
<h4 id="其它方法"><a href="#其它方法" class="headerlink" title="其它方法"></a>其它方法</h4><p>ByteBuffer是面向字节的，为方便基本数据类型的读取，ByteBuffer中还提供getInt，putInt，getFloat，putFloat等方法，这些方法方便我们在缓冲区存取单个基本数据类型。如果需要从基本数据类型数组中写入到ByteBuffer中，或者从ByteBuffer中读取到基本数据类型的数组中，那么我们可以通过已创建好的ByteBuffer对象的asXxxBuffer方法创建基本数据类型的Buffer。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> CharBuffer <span class="title function_">asCharBuffer</span><span class="params">()</span></span><br><span class="line"><span class="keyword">abstract</span> DoubleBuffer <span class="title function_">asDoubleBuffer</span><span class="params">()</span></span><br><span class="line"><span class="keyword">abstract</span> FloatBuffer <span class="title function_">asFloatBuffer</span><span class="params">()</span></span><br><span class="line"><span class="keyword">abstract</span> IntBuffer <span class="title function_">asIntBuffer</span><span class="params">()</span></span><br><span class="line"><span class="keyword">abstract</span> LongBuffer <span class="title function_">asLongBuffer</span><span class="params">()</span></span><br></pre></td></tr></table></figure></div>

<p>假设有如下代码</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">IntBuffer</span> <span class="variable">intBufferObj</span> <span class="operator">=</span> byteBufferObj.asIntBuffer();</span><br></pre></td></tr></table></figure></div>

<p>此时intBufferObj和byteBufferObj对象共享底层的数组。但是比较坑爹的是两个buffer的position，limit是独立的，这样极易产生bug，需要引起我们注意。</p>
<h3 id="ByteBuffer的编码和解码"><a href="#ByteBuffer的编码和解码" class="headerlink" title="ByteBuffer的编码和解码"></a>ByteBuffer的编码和解码</h3><p>数据传输中我们使用的是ByteBuffer对象作为缓冲区，如果在通道两端我们通信的内容是文本数据，这就涉及到ByteBuffer与CharBuffer的转换。我们可以使用Charset类实现这个转换的功能。</p>
<h4 id="解码示例"><a href="#解码示例" class="headerlink" title="解码示例"></a>解码示例</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">byteBuffer.put(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;-<span class="number">26</span>, -<span class="number">120</span>, -<span class="number">111</span>, -<span class="number">25</span>, -<span class="number">120</span>, -<span class="number">79</span>, -<span class="number">28</span>, -<span class="number">67</span>, -<span class="number">96</span>&#125;);</span><br><span class="line">byteBuffer.flip();</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*对获取utf8的编解码器*/</span></span><br><span class="line"><span class="type">Charset</span> <span class="variable">utf8</span> <span class="operator">=</span> Charset.forName(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="type">CharBuffer</span> <span class="variable">charBuffer</span> <span class="operator">=</span> utf8.decode(byteBuffer);<span class="comment">/*对bytebuffer中的内容解码*/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*array()返回的就是内部的数组引用，编码以后的有效长度是0~limit*/</span></span><br><span class="line"><span class="type">char</span>[] charArr = Arrays.copyOf(charBuffer.array(), charBuffer.limit());</span><br><span class="line">System.out.println(charArr); <span class="comment">/*运行结果：我爱你*/</span></span><br></pre></td></tr></table></figure></div>

<h4 id="编码示例"><a href="#编码示例" class="headerlink" title="编码示例"></a>编码示例</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CharBuffer</span> <span class="variable">charBuffer</span> <span class="operator">=</span> CharBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">charBuffer.append(<span class="string">&quot;我爱你&quot;</span>);</span><br><span class="line">charBuffer.flip();</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*对获取utf8的编解码器*/</span></span><br><span class="line"><span class="type">Charset</span> <span class="variable">utf8</span> <span class="operator">=</span> Charset.forName(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> utf8.encode(charBuffer); <span class="comment">/*对charbuffer中的内容解码*/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*array()返回的就是内部的数组引用，编码以后的有效长度是0~limit*/</span></span><br><span class="line"><span class="type">byte</span>[] bytes = Arrays.copyOf(byteBuffer.array(), byteBuffer.limit());</span><br><span class="line">System.out.println(Arrays.toString(bytes));</span><br><span class="line"><span class="comment">/*运行结果：[-26, -120, -111, -25, -120, -79, -28, -67, -96] */</span></span><br></pre></td></tr></table></figure></div>

<p>我们还可以通过代码中的utf8编解码器分别获取编码器对象和解码器对象</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CharsetEncoder</span> <span class="variable">utf8Encoder</span> <span class="operator">=</span> utf8.newEncoder();</span><br><span class="line"><span class="type">CharsetDecoder</span> <span class="variable">utf8Decoder</span> <span class="operator">=</span> utf8.newDecoder();</span><br></pre></td></tr></table></figure></div>

<p>然后通过下面编码器和解码器提供的方法进行编解码，其中一些方法可以使ByteBuffer和CharBuffer对象循环使用，不必每次都产生一个新的对象。</p>
<h4 id="解码器方法"><a href="#解码器方法" class="headerlink" title="解码器方法"></a>解码器方法</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Convenience method that decodes the remaining content of a single input byte buffer into a newly-allocated character buffer.*/</span></span><br><span class="line">CharBuffer <span class="title function_">decode</span><span class="params">(ByteBuffer in)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Decodes as many bytes as possible from the given input buffer, writing the results to the given output buffer.*/</span></span><br><span class="line">CoderResult <span class="title function_">decode</span><span class="params">(ByteBuffer in, CharBuffer out, <span class="type">boolean</span> endOfInput)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*Decodes one or more bytes into one or more characters.*/</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> CoderResult <span class="title function_">decodeLoop</span><span class="params">(ByteBuffer in, CharBuffer out)</span></span><br></pre></td></tr></table></figure></div>

<h4 id="编码器方法"><a href="#编码器方法" class="headerlink" title="编码器方法"></a>编码器方法</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Convenience method that encodes the remaining content of a single input character buffer into a newly-allocated byte buffer.*/</span></span><br><span class="line">ByteBuffer <span class="title function_">encode</span><span class="params">(CharBuffer in)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Encodes as many characters as possible from the given input buffer, writing the results to the given output buffer.*/</span></span><br><span class="line">CoderResult <span class="title function_">encode</span><span class="params">(CharBuffer in, ByteBuffer out, <span class="type">boolean</span> endOfInput)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Encodes one or more characters into one or more bytes.*/</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> CoderResult <span class="title function_">encodeLoop</span><span class="params">(CharBuffer in, ByteBuffer out)</span></span><br></pre></td></tr></table></figure></div>

<p>注意 <code>encode</code> 和 <code>decode</code> 方法都会改变源 <code>buffer</code> 中的 <code>position</code> 的位置，这点也是容易产生 Bug 的方法。</p>
<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>针对四种不同的应用场景，有四种不同类型的Channel对象。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">应用场景</th>
<th align="center">是否阻塞</th>
</tr>
</thead>
<tbody><tr>
<td align="center">FileChannel</td>
<td align="center">文件</td>
<td align="center">阻塞</td>
</tr>
<tr>
<td align="center">DatagramChannel</td>
<td align="center">UDP协议</td>
<td align="center">阻塞或非阻塞</td>
</tr>
<tr>
<td align="center">SocketChannel</td>
<td align="center">TCP协议</td>
<td align="center">阻塞或非阻塞</td>
</tr>
<tr>
<td align="center">ServerSocketChannel</td>
<td align="center">用于TCP服务器端的监听和链接</td>
<td align="center">阻塞或非阻塞</td>
</tr>
</tbody></table>
<p>Channel 对象的创建都是通过调用内部的open静态方法实现的，此方法是线程安全的。不论哪种类型的 Channel对象，都有read（要理解为从通道中读取，写入缓冲区中）和 write（要理解为从缓冲区中读取数据，写入到通道中）方法，而且read和write方法都只针对ByteBuffer对象。</p>
<p>当我们要获取由通道传输过来的数据时，先调用 channel.read（byteBufferObj）方法，这个方法在内部调用了byteBufferObj 对象的put方法，将通道中的数据写入缓冲区中。当我们要获取由通道传输来的数据时，调用byteBufferObj.flip() ，然后调用 byteBufferObj 的 get 方法获取通道传过来的数据，最后调用 clear 或 compact 方法转换成写模式，为下次 channel.read 做准备。</p>
<p>当我们要向通道发送数据时，先调 channel.write（byteBufferObj）方法,这个方法内部调用了 byteBufferObj 的get方法获取数据，然后将数据写入通道中。当写入完成后调用 clear 或 compact 方法转换成写模式，为下次channel.write写入缓冲区取做准备。</p>
<h3 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h3><p>在文件通道中 read 和 write 方法都是阻塞的，对于 read 方法，除非遇到文件结束，否则会把缓冲区的剩余空间读满再返回。对于 write 方法，会一次性把缓冲区中的内容全部写入到文件中才会返回。</p>
<p>下面的代码展示了 FileChannel 的功能，首先向文本文件中写入 UTF-8 格式的中英文混合字符，然后再读取出来。读写过程中都涉及到编解码问题。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> nioDemo;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">package</span> nioDemo;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.CharBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileChannelDemo</span> &#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123; </span><br><span class="line">         </span><br><span class="line">        <span class="comment">/*创建文件，向文件中写入数据*/</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">/*如果文件不存在，创建该文件,文件后缀是不是文本文件不重要*/</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:/noi_utf8.data&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">                file.createNewFile();</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">/*根据文件输出流创建与这个文件相关的通道*/</span></span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file);</span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">fc</span> <span class="operator">=</span> fos.getChannel();</span><br><span class="line">             </span><br><span class="line">            <span class="comment">/*创建ByteBuffer对象， position = 0, limit = 64*/</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">bb</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">64</span>);</span><br><span class="line">             </span><br><span class="line">            <span class="comment">/*向ByteBuffer中放入字符串UTF-8的字节, position = 17, limit = 64*/</span></span><br><span class="line">            bb.put(<span class="string">&quot;Hello,World 123 \n&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">             </span><br><span class="line">            <span class="comment">/*flip方法  position = 0, limit = 17*/</span></span><br><span class="line">            bb.flip();</span><br><span class="line">             </span><br><span class="line">            <span class="comment">/*write方法使得ByteBuffer的position到 limit中的元素写入通道中*/</span></span><br><span class="line">            fc.write(bb);</span><br><span class="line">             </span><br><span class="line">            <span class="comment">/*clear方法使得position = 0， limit = 64*/</span></span><br><span class="line">            bb.clear();</span><br><span class="line">             </span><br><span class="line">            <span class="comment">/*下面的代码同理*/</span></span><br><span class="line">            bb.put(<span class="string">&quot;你好，世界 456&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            bb.flip();</span><br><span class="line">             </span><br><span class="line">            fc.write(bb);</span><br><span class="line">            bb.clear();</span><br><span class="line">             </span><br><span class="line">            fos.close();</span><br><span class="line">            fc.close();</span><br><span class="line">             </span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">             </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line">        <span class="comment">/*从刚才的文件中读取字符序列*/</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">/*通过Path对象创建文件通道*/</span></span><br><span class="line">            <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;E:/noi_utf8.data&quot;</span>);</span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">fc</span> <span class="operator">=</span> FileChannel.open(path);</span><br><span class="line">             </span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">bb</span> <span class="operator">=</span> ByteBuffer.allocate((<span class="type">int</span>) fc.size()+<span class="number">1</span>);</span><br><span class="line">             </span><br><span class="line">            <span class="type">Charset</span> <span class="variable">utf8</span> <span class="operator">=</span> Charset.forName(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">             </span><br><span class="line">            <span class="comment">/*阻塞模式，读取完成才能返回*/</span></span><br><span class="line">            fc.read(bb);</span><br><span class="line">             </span><br><span class="line">            bb.flip();</span><br><span class="line">            <span class="type">CharBuffer</span> <span class="variable">cb</span> <span class="operator">=</span> utf8.decode(bb);</span><br><span class="line">            System.out.print(cb.toString());</span><br><span class="line">            bb.clear();</span><br><span class="line">             </span><br><span class="line"> </span><br><span class="line">            fc.close();</span><br><span class="line">             </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="ServerSocketChannel"><a href="#ServerSocketChannel" class="headerlink" title="ServerSocketChannel"></a>ServerSocketChannel</h3><p>服务器端用于创建TCP连接的通道，只能对 accept 事件感兴趣。 accept 方法会返回一个已和客户端连接好的SocketChannel 通道，它才服务器是真正传输数据的通道。</p>
<h3 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h3><p>TCP客户端和TCP服务器端都用它来传输数据。</p>
<p>客户端必须调用 connect 方法去连接服务器。在非阻塞通模式中，该方法将当前通道加入到选择器的已注册集合中，然后通过异步方式进行创建TCP连接，然后该方法立刻返回。注意调用该方法后并不表示已经创建好了TCP连接，如果这个方法返回false，稍后必须调用 finishConnect 方法来完成客户端到服务器的TCP连接。在阻塞方式中， connect 方法会阻塞直到创建好了TCP连接。</p>
<p> finishConnect 在非阻塞模式中仅仅是返回连接的状态。返回 true 时，表示连接创建好了。在阻塞模式下，直接调用方法 connect 即可完成连接，不需要使用 finishConnect 。</p>
<p>非阻塞模式下，读写操作要配合选择器一起使用。在阻塞模式下，创建好TCP连接后就可以直接对通道进行读写操作。</p>
<h3 id="DatagramChannel"><a href="#DatagramChannel" class="headerlink" title="DatagramChannel"></a>DatagramChannel</h3><p>connect 方法仅用于客户端到服务器端的连接，连接的作用仅仅是避免每次发送和接受数据时的安全检查，提高发送和接受数据的效率，而不是像TCP连接那样表示握手的意思。客户端通道只有调用了 connect 方法后，才能使用 read 和 write 方法读写数据。</p>
<p>客户端也可以不事先调用 connet 方法，而直接使用 receive 方法和 send 方法来实现数据的收发。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> SocketAddress <span class="title function_">receive</span><span class="params">(ByteBuffer dst)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">send</span><span class="params">(ByteBuffer src, SocketAddress target)</span> </span><br></pre></td></tr></table></figure></div>

<h3 id="服务器端DatagramChannel和SocketChannel的区别"><a href="#服务器端DatagramChannel和SocketChannel的区别" class="headerlink" title="服务器端DatagramChannel和SocketChannel的区别"></a>服务器端DatagramChannel和SocketChannel的区别</h3><p>对于服务器端 DatagramChannel（UDP）和 SocketChannel（TCP）有明显的区别，对于TCP连接，服务器端每创建一个连接就对应一个通道（不同的客户端ip：port 地址对应一个通道），而服务器端UDP的连接始终只有一个通道，所有客户端发送过来的报文都存放于同一个缓冲区中，这显然会降低服务器端的效率，好在  DatagramChannel 对象是线程安全的，可以用多个线程读写同一个 UDP 通道。</p>
<p>服务器端为什么只有一个通道呢？我猜想因为UDP是无状态的，不知道什么时客户端会发送数据，什么时候数据又发送完成，所以服务器端没有办法为每个客户端创建一个通道，就算服务器端根据客户端ip：port为每个客户端创建了通道，服务器端也不知道什么时候该释放这个通道，这就造成了资源的浪费。</p>
<h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><p>Selector 类表示选择器，通过这个类的对象可以选取已就绪的通道和这个通道感兴趣的事件。通过静态open方法创建。</p>
<h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>通道可以通过它的 register 方法，将通道注册到选择器上。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*Registers this channel with the given selector, returning a selection key.*/</span></span><br><span class="line">SelectionKey <span class="title function_">register</span><span class="params">(Selector sel, <span class="type">int</span> ops)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* Registers this channel with the given selector, returning a selection key. */</span></span><br><span class="line"><span class="keyword">abstract</span> SelectionKey <span class="title function_">register</span><span class="params">(Selector sel, <span class="type">int</span> ops, Object att)</span></span><br></pre></td></tr></table></figure></div>

<p>这个该方法会返回一个 SeletctKey 对象，但在这里我们通常忽略这个返回值。SeletctionKey 对象内部包含了这个注册的通道和这个通道感兴趣的事件（ops参数），以及附带的对象（由att参数传递），这个附带的对象通常就是和这个通道相关的读写缓冲区。</p>
<h3 id="通道的选择与取消"><a href="#通道的选择与取消" class="headerlink" title="通道的选择与取消"></a>通道的选择与取消</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Selects a set of keys whose corresponding channels are ready for I/O operations. */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">select</span><span class="params">()</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* Selects a set of keys whose corresponding channels are ready for I/O operations.*/</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">long</span> timeout)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* Selects a set of keys whose corresponding channels are ready for I/O operations.*/</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">selectNow</span><span class="params">()</span></span><br></pre></td></tr></table></figure></div>

<p>三个方法的返回值都表示就绪通道的数量。</p>
<p>select() 方法是个阻塞方法，有通道就绪才会返回。</p>
<p>select(long timeout) ，最多阻塞 timeout 毫秒，即使没有通道就绪也会返回，若超时返回，则当前线程中断标志位被设置。若阻塞时间内有通道就绪，就提前返回。</p>
<p>seletor.selectNow()，非阻塞方法。</p>
<p>一个 seletor 对象内部维护了三个集合。</p>
<ol>
<li>已注册集合：表示了所有已注册通道的SelectionKey对象。</li>
<li>就绪集合：表示了所有已就绪通道的SelectionKey对象。</li>
<li>取消集合：表示了所有需要取消注册关系的通道的SelectionKey对象。</li>
</ol>
<p>SelectionKey 的 cancel 方法用于取消通道和选择器的注册关系，这个方法只是把表示当前通道的 SelectionKey 放入取消集合中，下次调用 select 方法时才会真正取消注册关系。</p>
<p>select 方法每次会从已注册的通道集合中删除所有已取消的通道的 SelectionKey，然后清空已取消的通道集合，最后从更新过的已注册通道集合中选出就绪的通道，放入已就绪的集合中。每次调用 select 方法，会向已就绪的集合中放入已就绪通道的 SelectionKey 对象，调用 selectedKeys 方法就会返回这个已就绪通道集合的引用。当我们处理完一个已就绪通道，该通道对应的SelectionKey对象仍然位于已就绪的集合中，这就要求我们处理一个已就绪的通道后就必须手动从已就绪的集合中删除它，否则下次调用 selectedKeys 时，已处理过的通道还存在于这个集合中，导致线程空转。这里也是极易产生Bug的。</p>
<h3 id="通道的写方法注意事项"><a href="#通道的写方法注意事项" class="headerlink" title="通道的写方法注意事项"></a>通道的写方法注意事项</h3><h4 id="1、写方法什么时候就绪？"><a href="#1、写方法什么时候就绪？" class="headerlink" title="1、写方法什么时候就绪？"></a>1、写方法什么时候就绪？</h4><p>写操作的就绪条件为 socket 底层写缓冲区有空闲空间，此时并不代表我们这时有（或者需要将）数据写入通道。而底层写缓冲区绝大部分时间都是有空闲空间的，所以当你注册写事件后，写操作基本一直是就绪的。这就导致只要有一个通道对写事件感兴趣，select 方法几乎总是立刻返回的，但是实际上我们可能没有数据可写的，所以使得调用 select 方法的线程总是空转。对于客户端发送一些数据，客户端返回一些数据的模型，我们可以在读事件完成后，再设置通道对写事件感兴趣，写操作完成后再取消该通道对写事件的兴趣，这样就可以避免上述问题。</p>
<h4 id="2、如何正确的发送数据"><a href="#2、如何正确的发送数据" class="headerlink" title="2、如何正确的发送数据"></a>2、如何正确的发送数据</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(writeBuffer.hasRemaining())&#123;</span><br><span class="line">    channel.write(writeBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>上面发送数据的通常用的代码，当网络状况良好的情况下，这段代码能正常工作。 现在我们考虑一种极端情况，服务器端写事件就绪，我们向底层的写缓冲区写入一些数据后，服务器端到客户端的链路出现问题，服务器端没能把数据发送出去，此时底层的写缓冲区一直处于满的状态，假设 writeBuffer 中仍然还有没发送完的数据就会导致while 循环空转，浪费CPU资源，同时也妨碍这个selector管理的其它通道的读写。</p>
<p>为了解决个问题，我们应该使用下面的方法发送数据</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(writeBuffer.hasRemaining())&#123;</span><br><span class="line">    len = sc.write(writeBuffer);</span><br><span class="line">    <span class="comment">/*说明底层的socket写缓冲已满*/</span></span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>下面这个类，后面的代码都会用到，它只是两个缓冲区的包装</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> nioDemo;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*自定义Buffer类中包含读缓冲区和写缓冲区，用于注册通道时的附加对象*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Buffers</span> &#123;</span><br><span class="line"> </span><br><span class="line">    ByteBuffer readBuffer;</span><br><span class="line">    ByteBuffer writeBuffer;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Buffers</span><span class="params">(<span class="type">int</span> readCapacity, <span class="type">int</span> writeCapacity)</span>&#123;</span><br><span class="line">        readBuffer = ByteBuffer.allocate(readCapacity);</span><br><span class="line">        writeBuffer = ByteBuffer.allocate(writeCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> ByteBuffer <span class="title function_">getReadBuffer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> readBuffer;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> ByteBuffer <span class="title function_">gerWriteBuffer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> writeBuffer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="TCP非阻塞示例"><a href="#TCP非阻塞示例" class="headerlink" title="TCP非阻塞示例"></a>TCP非阻塞示例</h3><p>服务器端代码</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> nioDemo;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.CharBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*服务器端，:接收客户端发送过来的数据并显示，</span></span><br><span class="line"><span class="comment"> *服务器把上接收到的数据加上&quot;echo from service:&quot;再发送回去*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceSocketChannelDemo</span> &#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TCPEchoServer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">/*服务器地址*/</span></span><br><span class="line">        <span class="keyword">private</span> InetSocketAddress localAddress;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TCPEchoServer</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">            <span class="built_in">this</span>.localAddress = <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(port);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">             </span><br><span class="line">            <span class="type">Charset</span> <span class="variable">utf8</span> <span class="operator">=</span> Charset.forName(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">             </span><br><span class="line">            <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">             </span><br><span class="line">            <span class="type">Random</span> <span class="variable">rnd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">/*创建选择器*/</span></span><br><span class="line">                selector = Selector.open();</span><br><span class="line">                 </span><br><span class="line">                <span class="comment">/*创建服务器通道*/</span></span><br><span class="line">                ssc = ServerSocketChannel.open();</span><br><span class="line">                ssc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                 </span><br><span class="line">                <span class="comment">/*设置监听服务器的端口，设置最大连接缓冲数为100*/</span></span><br><span class="line">                ssc.bind(localAddress, <span class="number">100</span>);</span><br><span class="line">                 </span><br><span class="line">                <span class="comment">/*服务器通道只能对tcp链接事件感兴趣*/</span></span><br><span class="line">                ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">                 </span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;server start failed&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; </span><br><span class="line">             </span><br><span class="line">            System.out.println(<span class="string">&quot;server start with address : &quot;</span> + localAddress);</span><br><span class="line">             </span><br><span class="line">            <span class="comment">/*服务器线程被中断后会退出*/</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                 </span><br><span class="line">                <span class="keyword">while</span>(!Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                     </span><br><span class="line">                    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> selector.select();</span><br><span class="line">                    <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"> </span><br><span class="line">                    Set&lt;SelectionKey&gt; keySet = selector.selectedKeys();</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; it = keySet.iterator();</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                     </span><br><span class="line">                    <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">                             </span><br><span class="line">                        key = it.next();</span><br><span class="line">                        <span class="comment">/*防止下次select方法返回已处理过的通道*/</span></span><br><span class="line">                        it.remove();</span><br><span class="line">                         </span><br><span class="line">                        <span class="comment">/*若发现异常，说明客户端连接出现问题,但服务器要保持正常*/</span></span><br><span class="line">                        <span class="keyword">try</span>&#123;</span><br><span class="line">                            <span class="comment">/*ssc通道只能对链接事件感兴趣*/</span></span><br><span class="line">                            <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">                                 </span><br><span class="line">                                <span class="comment">/*accept方法会返回一个普通通道，</span></span><br><span class="line"><span class="comment">                                     每个通道在内核中都对应一个socket缓冲区*/</span></span><br><span class="line">                                <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> ssc.accept();</span><br><span class="line">                                sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                                 </span><br><span class="line">                                <span class="comment">/*向选择器注册这个通道和普通通道感兴趣的事件，同时提供这个新通道相关的缓冲区*/</span></span><br><span class="line">                                <span class="type">int</span> <span class="variable">interestSet</span> <span class="operator">=</span> SelectionKey.OP_READ;                             </span><br><span class="line">                                sc.register(selector, interestSet, <span class="keyword">new</span> <span class="title class_">Buffers</span>(<span class="number">256</span>, <span class="number">256</span>));</span><br><span class="line">                                 </span><br><span class="line">                                System.out.println(<span class="string">&quot;accept from &quot;</span> + sc.getRemoteAddress());</span><br><span class="line">                            &#125;</span><br><span class="line">                             </span><br><span class="line">                             </span><br><span class="line">                            <span class="comment">/*（普通）通道感兴趣读事件且有数据可读*/</span></span><br><span class="line">                            <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">                                 </span><br><span class="line">                                <span class="comment">/*通过SelectionKey获取通道对应的缓冲区*/</span></span><br><span class="line">                                <span class="type">Buffers</span>  <span class="variable">buffers</span> <span class="operator">=</span> (Buffers)key.attachment();</span><br><span class="line">                                <span class="type">ByteBuffer</span> <span class="variable">readBuffer</span> <span class="operator">=</span> buffers.getReadBuffer();</span><br><span class="line">                                <span class="type">ByteBuffer</span> <span class="variable">writeBuffer</span> <span class="operator">=</span> buffers.gerWriteBuffer();</span><br><span class="line">                                 </span><br><span class="line">                                <span class="comment">/*通过SelectionKey获取对应的通道*/</span></span><br><span class="line">                                <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                                 </span><br><span class="line">                                <span class="comment">/*从底层socket读缓冲区中读入数据*/</span></span><br><span class="line">                                sc.read(readBuffer);</span><br><span class="line">                                readBuffer.flip();</span><br><span class="line">                                 </span><br><span class="line">                                <span class="comment">/*解码显示，客户端发送来的信息*/</span></span><br><span class="line">                                <span class="type">CharBuffer</span> <span class="variable">cb</span> <span class="operator">=</span> utf8.decode(readBuffer);</span><br><span class="line">                                System.out.println(cb.array());</span><br><span class="line">                     </span><br><span class="line">                                readBuffer.rewind();</span><br><span class="line"> </span><br><span class="line">                                 </span><br><span class="line">                                <span class="comment">/*准备好向客户端发送的信息*/</span></span><br><span class="line">                                <span class="comment">/*先写入&quot;echo:&quot;，再写入收到的信息*/</span></span><br><span class="line">                                writeBuffer.put(<span class="string">&quot;echo from service:&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                                writeBuffer.put(readBuffer);</span><br><span class="line">                                 </span><br><span class="line">                                readBuffer.clear();</span><br><span class="line">                                 </span><br><span class="line">                                <span class="comment">/*设置通道写事件*/</span></span><br><span class="line">                                key.interestOps(key.interestOps() | SelectionKey.OP_WRITE);</span><br><span class="line">                                                                 </span><br><span class="line">                            &#125;</span><br><span class="line">                             </span><br><span class="line">                            <span class="comment">/*通道感兴趣写事件且底层缓冲区有空闲*/</span></span><br><span class="line">                            <span class="keyword">if</span>(key.isWritable())&#123;</span><br><span class="line">                                 </span><br><span class="line">                                <span class="type">Buffers</span>  <span class="variable">buffers</span> <span class="operator">=</span> (Buffers)key.attachment();</span><br><span class="line">                                 </span><br><span class="line">                                <span class="type">ByteBuffer</span> <span class="variable">writeBuffer</span> <span class="operator">=</span> buffers.gerWriteBuffer();</span><br><span class="line">                                writeBuffer.flip();</span><br><span class="line">                                 </span><br><span class="line">                                <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                                 </span><br><span class="line">                                <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                                <span class="keyword">while</span>(writeBuffer.hasRemaining())&#123;</span><br><span class="line">                                    len = sc.write(writeBuffer);</span><br><span class="line">                                    <span class="comment">/*说明底层的socket写缓冲已满*/</span></span><br><span class="line">                                    <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                                 </span><br><span class="line">                                writeBuffer.compact();</span><br><span class="line">                                 </span><br><span class="line">                                <span class="comment">/*说明数据全部写入到底层的socket写缓冲区*/</span></span><br><span class="line">                                <span class="keyword">if</span>(len != <span class="number">0</span>)&#123;</span><br><span class="line">                                    <span class="comment">/*取消通道的写事件*/</span></span><br><span class="line">                                    key.interestOps(key.interestOps() &amp; (~SelectionKey.OP_WRITE));</span><br><span class="line">                                &#125;</span><br><span class="line">                                 </span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;service encounter client error&quot;</span>);</span><br><span class="line">                            <span class="comment">/*若客户端连接出现异常，从Seletcor中移除这个key*/</span></span><br><span class="line">                            key.cancel();</span><br><span class="line">                            key.channel().close();</span><br><span class="line">                        &#125;</span><br><span class="line"> </span><br><span class="line">                    &#125;</span><br><span class="line">                         </span><br><span class="line">                    Thread.sleep(rnd.nextInt(<span class="number">500</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                 </span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;serverThread is interrupted&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;serverThread selecotr error&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    selector.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;selector close failed&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;server close&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, IOException&#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">TCPEchoServer</span>(<span class="number">8080</span>));</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">100000</span>);</span><br><span class="line">        <span class="comment">/*结束服务器线程*/</span></span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>客户端程序</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> nioDemo;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.CharBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*客户端:客户端每隔1~2秒自动向服务器发送数据，接收服务器接收到数据并显示*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientSocketChannelDemo</span> &#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TCPEchoClient</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">/*客户端线程名*/</span></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">Random</span> <span class="variable">rnd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">         </span><br><span class="line">        <span class="comment">/*服务器的ip地址+端口port*/</span></span><br><span class="line">        <span class="keyword">private</span> InetSocketAddress remoteAddress;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TCPEchoClient</span><span class="params">(String name, InetSocketAddress remoteAddress)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="built_in">this</span>.remoteAddress = remoteAddress;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">/*创建解码器*/</span></span><br><span class="line">            <span class="type">Charset</span> <span class="variable">utf8</span> <span class="operator">=</span> Charset.forName(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">             </span><br><span class="line">            Selector selector;</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                 </span><br><span class="line">                <span class="comment">/*创建TCP通道*/</span></span><br><span class="line">                <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">                 </span><br><span class="line">                <span class="comment">/*设置通道为非阻塞*/</span></span><br><span class="line">                sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                 </span><br><span class="line">                <span class="comment">/*创建选择器*/</span></span><br><span class="line">                selector = Selector.open();</span><br><span class="line">                 </span><br><span class="line">                <span class="comment">/*注册感兴趣事件*/</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">interestSet</span> <span class="operator">=</span> SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br><span class="line">                 </span><br><span class="line">                <span class="comment">/*向选择器注册通道*/</span></span><br><span class="line">                sc.register(selector, interestSet, <span class="keyword">new</span> <span class="title class_">Buffers</span>(<span class="number">256</span>, <span class="number">256</span>));</span><br><span class="line">                 </span><br><span class="line">                <span class="comment">/*向服务器发起连接,一个通道代表一条tcp链接*/</span></span><br><span class="line">                sc.connect(remoteAddress);</span><br><span class="line">                 </span><br><span class="line">                <span class="comment">/*等待三次握手完成*/</span></span><br><span class="line">                <span class="keyword">while</span>(!sc.finishConnect())&#123;</span><br><span class="line">                    ;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                System.out.println(name + <span class="string">&quot; &quot;</span> + <span class="string">&quot;finished connection&quot;</span>);</span><br><span class="line">                 </span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;client connect failed&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">/*与服务器断开或线程被中断则结束线程*/</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line"> </span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(!Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                     </span><br><span class="line">                    <span class="comment">/*阻塞等待*/</span></span><br><span class="line">                    selector.select();</span><br><span class="line">                     </span><br><span class="line">                    <span class="comment">/*Set中的每个key代表一个通道*/</span></span><br><span class="line">                    Set&lt;SelectionKey&gt; keySet = selector.selectedKeys();</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; it = keySet.iterator();</span><br><span class="line">                     </span><br><span class="line">                    <span class="comment">/*遍历每个已就绪的通道，处理这个通道已就绪的事件*/</span></span><br><span class="line">                    <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">                         </span><br><span class="line">                        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> it.next();</span><br><span class="line">                        <span class="comment">/*防止下次select方法返回已处理过的通道*/</span></span><br><span class="line">                        it.remove();</span><br><span class="line">                         </span><br><span class="line">                        <span class="comment">/*通过SelectionKey获取对应的通道*/</span></span><br><span class="line">                        <span class="type">Buffers</span>  <span class="variable">buffers</span> <span class="operator">=</span> (Buffers)key.attachment();</span><br><span class="line">                        <span class="type">ByteBuffer</span> <span class="variable">readBuffer</span> <span class="operator">=</span> buffers.getReadBuffer();</span><br><span class="line">                        <span class="type">ByteBuffer</span> <span class="variable">writeBuffer</span> <span class="operator">=</span> buffers.gerWriteBuffer();</span><br><span class="line">                         </span><br><span class="line">                        <span class="comment">/*通过SelectionKey获取通道对应的缓冲区*/</span></span><br><span class="line">                        <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                         </span><br><span class="line">                        <span class="comment">/*表示底层socket的读缓冲区有数据可读*/</span></span><br><span class="line">                        <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">                            <span class="comment">/*从socket的读缓冲区读取到程序定义的缓冲区中*/</span></span><br><span class="line">                            sc.read(readBuffer);</span><br><span class="line">                            readBuffer.flip();</span><br><span class="line">                            <span class="comment">/*字节到utf8解码*/</span></span><br><span class="line">                            <span class="type">CharBuffer</span> <span class="variable">cb</span> <span class="operator">=</span> utf8.decode(readBuffer);</span><br><span class="line">                            <span class="comment">/*显示接收到由服务器发送的信息*/</span></span><br><span class="line">                            System.out.println(cb.array());</span><br><span class="line">                            readBuffer.clear();</span><br><span class="line">                        &#125;</span><br><span class="line">                         </span><br><span class="line">                        <span class="comment">/*socket的写缓冲区可写*/</span></span><br><span class="line">                        <span class="keyword">if</span>(key.isWritable())&#123;</span><br><span class="line">                            writeBuffer.put((name + <span class="string">&quot;  &quot;</span> + i).getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                            writeBuffer.flip();</span><br><span class="line">                            <span class="comment">/*将程序定义的缓冲区中的内容写入到socket的写缓冲区中*/</span></span><br><span class="line">                            sc.write(writeBuffer);</span><br><span class="line">                            writeBuffer.clear();</span><br><span class="line">                            i++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                     </span><br><span class="line">                    Thread.sleep(<span class="number">1000</span> + rnd.nextInt(<span class="number">1000</span>));</span><br><span class="line">                &#125;</span><br><span class="line">             </span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                System.out.println(name + <span class="string">&quot; is interrupted&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                System.out.println(name + <span class="string">&quot; encounter a connect error&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    selector.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">                    System.out.println(name + <span class="string">&quot; close selector failed&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                    System.out.println(name + <span class="string">&quot;  closed&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">         </span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">remoteAddress</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;192.168.1.100&quot;</span>, <span class="number">8080</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">ta</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">TCPEchoClient</span>(<span class="string">&quot;thread a&quot;</span>, remoteAddress));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">tb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">TCPEchoClient</span>(<span class="string">&quot;thread b&quot;</span>, remoteAddress));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">tc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">TCPEchoClient</span>(<span class="string">&quot;thread c&quot;</span>, remoteAddress));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">td</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">TCPEchoClient</span>(<span class="string">&quot;thread d&quot;</span>, remoteAddress));</span><br><span class="line">         </span><br><span class="line">        ta.start();</span><br><span class="line">        tb.start();</span><br><span class="line">        tc.start();</span><br><span class="line">         </span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/*结束客户端a*/</span></span><br><span class="line">        ta.interrupt();</span><br><span class="line">         </span><br><span class="line">        <span class="comment">/*开始客户端d*/</span></span><br><span class="line">        td.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="UDP示例"><a href="#UDP示例" class="headerlink" title="UDP示例"></a>UDP示例</h3><p>客户端非阻塞模式，服务器端阻塞模式</p>
<p>服务器端代码（服务器端只有一个通道，对应一个读缓冲区，一个写缓冲区，所以使用非阻塞方式容易发生数据混乱）</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> nioDemo;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.CharBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.DatagramChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceDatagramChannelDemo</span> &#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UDPEchoService</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">UDPEchoService</span><span class="params">(<span class="type">int</span> port)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.port = port;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">             </span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">readBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">256</span>);</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">writeBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">256</span>);</span><br><span class="line"> </span><br><span class="line">            <span class="type">DatagramChannel</span> <span class="variable">dc</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                 </span><br><span class="line">                <span class="comment">/*服务器端使用默认的阻塞IO的方式*/</span></span><br><span class="line">                dc = DatagramChannel.open();</span><br><span class="line">                dc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(port));</span><br><span class="line">                 </span><br><span class="line">                System.out.println(<span class="string">&quot;service start&quot;</span>);</span><br><span class="line">                <span class="keyword">while</span>(!Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                     </span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                         </span><br><span class="line">                        <span class="comment">/*先读取客户端发送的消息，直到读取到消息才会返回*/</span></span><br><span class="line">                        <span class="comment">/*只能调用receive方法，因为不知道哪个地址给服务器发信息，没法实现调用connect方法*/</span></span><br><span class="line">                        <span class="comment">/*dc是阻塞的，所以receive方法要等到接收到数据才返回*/</span></span><br><span class="line">                        <span class="type">SocketAddress</span> <span class="variable">clientAddress</span> <span class="operator">=</span> dc.receive(readBuffer);</span><br><span class="line">                        readBuffer.flip();</span><br><span class="line">                        <span class="type">CharBuffer</span> <span class="variable">charBuffer</span> <span class="operator">=</span> Charset.defaultCharset().decode(readBuffer);</span><br><span class="line">                        System.out.println(charBuffer.array());</span><br><span class="line">                         </span><br><span class="line">                        <span class="comment">/*调用send方法向客户端发送的消息，</span></span><br><span class="line"><span class="comment">                         *dc是阻塞的,所以直到send方法把数据全部写入到socket缓冲区才返回*/</span></span><br><span class="line">                        writeBuffer.put(<span class="string">&quot;echo : &quot;</span>.getBytes());</span><br><span class="line">                        readBuffer.rewind();</span><br><span class="line">                        writeBuffer.put(readBuffer);</span><br><span class="line">                        writeBuffer.flip();</span><br><span class="line">                        dc.send(writeBuffer, clientAddress);</span><br><span class="line">                         </span><br><span class="line">                        readBuffer.clear();</span><br><span class="line">                        writeBuffer.clear();</span><br><span class="line">                         </span><br><span class="line">                    &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;receive from or send to client failed&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;server error&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(dc != <span class="literal">null</span>)&#123;</span><br><span class="line">                        dc.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"> </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">UDPEchoService</span>(<span class="number">8080</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>客户端代码</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> nioDemo;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.CharBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.DatagramChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientDatagramChannelDemo</span> &#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UDPEchoClient</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> InetSocketAddress serviceAddress;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">UDPEchoClient</span><span class="params">(String name, InetSocketAddress serviceAddress)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="built_in">this</span>.serviceAddress = serviceAddress;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="type">DatagramChannel</span> <span class="variable">dc</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                 </span><br><span class="line">                <span class="comment">/*每个实际上可以创建多个通道连接同一个服务器地址，</span></span><br><span class="line"><span class="comment">                我们这里为了演示方便，只创建了一个通道*/</span></span><br><span class="line">                dc = DatagramChannel.open();</span><br><span class="line">                 </span><br><span class="line">                <span class="comment">/*客户端采用非阻塞模式*/</span></span><br><span class="line">                dc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"> </span><br><span class="line">                <span class="comment">/*这里的连接不是指TCP的握手连接，因为UDP协议本身不需要连接，</span></span><br><span class="line"><span class="comment">                 *这里连接的意思大概是提前向操作系统申请好本地端口号，以及高速操作系统要发送的目的</span></span><br><span class="line"><span class="comment">                 *连接后的UDP通道可以提高发送的效率，还可以调用read和write方法接收和发送数据</span></span><br><span class="line"><span class="comment">                 *未连接的UDP通道只能调用receive和send方法接收和发送数据*/</span></span><br><span class="line">                dc.connect(serviceAddress);</span><br><span class="line">                 </span><br><span class="line">                <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">                <span class="type">int</span> <span class="variable">interest</span> <span class="operator">=</span> SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br><span class="line">                dc.register(selector, interest, <span class="keyword">new</span> <span class="title class_">Buffers</span>(<span class="number">256</span>, <span class="number">256</span>));</span><br><span class="line">                 </span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(!Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                     </span><br><span class="line">                    selector.select();</span><br><span class="line">                     </span><br><span class="line">                    Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();</span><br><span class="line">                    <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">                         </span><br><span class="line">                        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> it.next();</span><br><span class="line">                        it.remove();</span><br><span class="line">                         </span><br><span class="line">                        <span class="type">Buffers</span> <span class="variable">buffers</span> <span class="operator">=</span> (Buffers)key.attachment();</span><br><span class="line">                         </span><br><span class="line">                        <span class="type">ByteBuffer</span> <span class="variable">readBuffer</span> <span class="operator">=</span> buffers.getReadBuffer();</span><br><span class="line">                        <span class="type">ByteBuffer</span> <span class="variable">writeBuffer</span> <span class="operator">=</span> buffers.gerWriteBuffer();</span><br><span class="line">                         </span><br><span class="line">                        <span class="keyword">try</span>&#123;</span><br><span class="line">                             </span><br><span class="line">                            <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">                                dc.read(readBuffer);</span><br><span class="line">                                readBuffer.flip();</span><br><span class="line">                                <span class="type">CharBuffer</span> <span class="variable">charBuffer</span> <span class="operator">=</span> Charset.defaultCharset().decode(readBuffer);</span><br><span class="line">                                System.out.println(charBuffer.array());</span><br><span class="line">                                readBuffer.clear();</span><br><span class="line">                            &#125;</span><br><span class="line">                             </span><br><span class="line">                            <span class="keyword">if</span>(key.isWritable())&#123;</span><br><span class="line">                                writeBuffer.put((name + (i++)).getBytes());</span><br><span class="line">                                writeBuffer.flip();</span><br><span class="line">                                dc.write(writeBuffer);</span><br><span class="line">                                writeBuffer.clear();</span><br><span class="line">                                 </span><br><span class="line">                                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                         </span><br><span class="line">                        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                            key.cancel();</span><br><span class="line">                            key.channel().close();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                System.out.println(name + <span class="string">&quot;interrupted&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                System.out.println(name + <span class="string">&quot;encounter connect error&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    dc.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    System.out.println(name + <span class="string">&quot;encounter close error&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                    System.out.println(name + <span class="string">&quot;closed&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">         </span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">serviceAddress</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;192.168.1.100&quot;</span>, <span class="number">8080</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="type">UDPEchoClient</span> <span class="variable">clientA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UDPEchoClient</span>(<span class="string">&quot;thread a &quot;</span>, serviceAddress);</span><br><span class="line">        <span class="type">UDPEchoClient</span> <span class="variable">clientB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UDPEchoClient</span>(<span class="string">&quot;thread b &quot;</span>, serviceAddress);</span><br><span class="line">        <span class="type">UDPEchoClient</span> <span class="variable">clientC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UDPEchoClient</span>(<span class="string">&quot;thread c &quot;</span>, serviceAddress);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(clientA).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(clientB).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(clientC).start();</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2><p><a class="link"   href="http://www.importnew.com/26334.html" >堆外内存之 DirectByteBuffer 详解 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://blog.csdn.net/billluffy/article/details/78036998" >SocketChannel—各种注意点 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://docs.oracle.com/javase/8/docs/api/" >JDK 8 API 文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java单例模式</title>
    <url>/2018/07/16/Java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>这种模式涉及到一个<code>单一</code>的类，该类负责创建自己的对象，同时确保只有<code>单个对象</code>被创建。这个类提供了一种访问其<code>唯一</code>的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
</blockquote>
<span id="more"></span>

<p><strong><code>注意：</code></strong><br> 1.单例类只能有一个实例<br> 2.单例类必须自己创建自己的唯一实例<br> 3.单例类必须给所有其他对象提供这一实例</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong><code>意　　图：</code></strong> 保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br><strong><code>主要解决：</code></strong> 一个全局使用的类频繁地创建与销毁。<br>**<code>何时使用：</code>**当您想控制实例数目，节省系统资源的时候。<br><strong><code>如何解决：</code></strong> 判断系统是否已经有这个单例，如果有则返回，如果没有则创建。<br><strong><code>关键代码：</code></strong> 构造函数是私有的。<br><strong><code>应用实例：</code></strong>  1.一个党只能有一个主席。 2.Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。 3.一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。<br><strong><code>优点：</code></strong>  1.在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 2.避免对资源的多重占用（比如写文件操作）。<br><strong><code>缺点：</code></strong> 没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。<br><strong><code>使用场景：</code></strong>  1.要求生产唯一序列号。2.WEB中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。3.创建的一个对象需要消耗的资源过多，比如 I&#x2F;O 与数据库的连接等。<br><strong><code>注意事项：</code></strong> getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。<br><strong><code>核心知识点如下：</code></strong> 1.将采用单例设计模式的类的构造方法私有化（采用private修饰）。2.在其内部产生该类的实例化对象，并将其封装成private static类型。3.定义一个静态方法返回该类的实例。</p>
<h2 id="几种实现方式"><a href="#几种实现方式" class="headerlink" title="几种实现方式"></a>几种实现方式</h2><h3 id="懒汉式，线程不安全"><a href="#懒汉式，线程不安全" class="headerlink" title="懒汉式，线程不安全"></a>懒汉式，线程不安全</h3><p><strong><code>是否 Lazy 初始化：</code></strong> 是<br><strong><code>是否多线程安全：</code></strong> 否<br><strong><code>实现难度：</code></strong> 易<br><strong><code>描述：</code></strong> 这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。<br>这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;  </span><br><span class="line">    　　<span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;  </span><br><span class="line">    	　　instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">    　　&#125;  </span><br><span class="line">    　　<span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>
<h3 id="懒汉式，线程安全"><a href="#懒汉式，线程安全" class="headerlink" title="懒汉式，线程安全"></a>懒汉式，线程安全</h3><p><strong><code>是否 Lazy 初始化：</code></strong> 是<br><strong><code>是否多线程安全：</code></strong> 是<br><strong><code>实现难度：</code></strong> 易<br><strong><code>描述：</code></strong> 这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。<br><strong><code>优点：</code></strong> 第一次调用才初始化，避免内存浪费。<br><strong><code>缺点：</code></strong> 必须加锁 synchronized 才能保证单例，但加锁会影响效率。<br>getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123; &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;  </span><br><span class="line">    　　<span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;  </span><br><span class="line">    	　　instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">    　　&#125;  </span><br><span class="line">    　　<span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>
<h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p><strong><code>是否 Lazy 初始化：</code></strong> 否<br><strong><code>是否多线程安全：</code></strong> 是<br><strong><code>实现难度：</code></strong> 易<br><strong><code>描述：</code></strong> 这种方式比较常用，但容易产生垃圾对象。<br><strong><code>优点：</code></strong> 没有加锁，执行效率会提高。<br><strong><code>缺点：</code></strong> 类加载时就初始化，浪费内存。<br>它基于 classloder 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;  </span><br><span class="line">    	<span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>
<h3 id="双检锁-x2F-双重校验锁（DCL，即-double-checked-locking）"><a href="#双检锁-x2F-双重校验锁（DCL，即-double-checked-locking）" class="headerlink" title="双检锁&#x2F;双重校验锁（DCL，即 double-checked locking）"></a>双检锁&#x2F;双重校验锁（DCL，即 double-checked locking）</h3><p><strong><code>JDK 版本：</code></strong> JDK1.5 起<br><strong><code>是否 Lazy 初始化：</code></strong> 是<br><strong><code>是否多线程安全：</code></strong> 是<br><strong><code>实现难度：</code></strong> 较复杂<br><strong><code>描述：</code></strong> 这种方式采用双锁机制，安全且在多线程情况下能保持高性能。<br>getInstance() 的性能对应用程序很关键。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getSingleton</span><span class="params">()</span> &#123;  </span><br><span class="line">   	        <span class="keyword">if</span> (singleton != <span class="literal">null</span>) &#123;  </span><br><span class="line">		           <span class="keyword">return</span> singleton;  </span><br><span class="line">	        &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">    　　        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;  </span><br><span class="line">    　　　        　singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">    　　         &#125; </span><br><span class="line">	         &#125;</span><br><span class="line">　         <span class="keyword">return</span> singleton;    </span><br><span class="line">    &#125;  　</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>


<h3 id="登记式-x2F-静态内部类"><a href="#登记式-x2F-静态内部类" class="headerlink" title="登记式&#x2F;静态内部类"></a>登记式&#x2F;静态内部类</h3><p><strong><code>是否 Lazy 初始化：</code></strong> 是<br><strong><code>是否多线程安全：</code></strong> 是<br><strong><code>实现难度：</code></strong> 一般<br><strong><code>描述：</code></strong> 这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。<br>这种方式同样利用了 classloder 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有显示通过调用 getInstance 方法时，才会显示装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;  </span><br><span class="line">    	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;  </span><br><span class="line">    	<span class="keyword">return</span> SingletonHolder.INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><strong><code>JDK 版本：</code></strong> JDK1.5 起<br><strong><code>是否 Lazy 初始化：</code></strong> 否<br><strong><code>是否多线程安全：</code></strong> 是<br><strong><code>实现难度：</code></strong> 易<br><strong><code>描述：</code></strong> 这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。<br>这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。不能通过 reflection attack 来调用私有构造方法。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    INSTANCE;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whateverMethod</span><span class="params">()</span> &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>
<p><strong><code>经验之谈：</code></strong> 一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo的next主题个性化教程</title>
    <url>/2019/02/15/Hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="设置中文"><a href="#设置中文" class="headerlink" title="设置中文"></a>设置中文</h3><p>修改配置文件(_config.yml)</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">language: zh-Hans</span><br></pre></td></tr></table></figure></div>

<span id="more"></span>

<h3 id="酷炫的动态背景"><a href="#酷炫的动态背景" class="headerlink" title="酷炫的动态背景"></a>酷炫的动态背景</h3><p>打开<code>\themes\NexT\_config.yml</code>，修改以下内容：　　　</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">背景特效以下4项，是NexT主题集成的，只需将 <span class="literal">false</span> 改为 <span class="literal">true</span>，即可启用</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不用向网上说的，到模板文件里加引用js的脚本，NexT已经集成了，开启即用</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Canvas-nest 浮动线条</span></span><br><span class="line">canvas_nest:</span><br><span class="line">  enable: true</span><br><span class="line">  onmobile: true # display on mobile or not</span><br><span class="line">  color: &#x27;0,0,255&#x27; # RGB values, use &#x27;,&#x27; to separate</span><br><span class="line">  opacity: 0.5 # the opacity of line: 0~1</span><br><span class="line">  zIndex: -1 # z-index property of the background</span><br><span class="line">  count: 99 # the number of lines</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">three_waves 水波粒子</span></span><br><span class="line">three_waves: false</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">canvas_lines 这个是一根线连接两个小点，组成的一个随鼠标放大缩小的东西</span></span><br><span class="line">canvas_lines: false</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">canvas_sphere 这个是一个很多刺组成的一个球</span></span><br><span class="line">canvas_sphere: false</span><br></pre></td></tr></table></figure></div>

<h3 id="主页文章添加阴影效果"><a href="#主页文章添加阴影效果" class="headerlink" title="主页文章添加阴影效果"></a>主页文章添加阴影效果</h3><p>打开<code>themes/next/source/css/_custom/custom.styl</code>文件添加：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">.post &#123;</span><br><span class="line">   margin-top: 60px;</span><br><span class="line">   margin-bottom: 60px;</span><br><span class="line">   padding: 25px;</span><br><span class="line">   -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5);</span><br><span class="line">   -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="启用：页面加载过程中顶部的进度条"><a href="#启用：页面加载过程中顶部的进度条" class="headerlink" title="启用：页面加载过程中顶部的进度条"></a>启用：页面加载过程中顶部的进度条</h3><p>打开<code>\themes\NexT\_config.yml</code>，找到字段 <code>pace</code>，设为<code>true</code>。还可以将<code>pace_theme:</code>的值，改成相应的名字,变更不同样式的加载条。</p>
<h3 id="修改文章底部的那个带-号的标签"><a href="#修改文章底部的那个带-号的标签" class="headerlink" title="修改文章底部的那个带#号的标签"></a>修改文章底部的那个带#号的标签</h3><p>修改模板<code>/themes/next/layout/_macro/post.swig</code>，搜索 <code>rel=&quot;tag&quot;&gt;#</code>，将 <code>#</code> 换成<code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code></p>
<h3 id="在每篇文章末尾统一添加“本文结束”标记"><a href="#在每篇文章末尾统一添加“本文结束”标记" class="headerlink" title="在每篇文章末尾统一添加“本文结束”标记"></a>在每篇文章末尾统一添加“本文结束”标记</h3><p>在路径<code>\themes\next\layout\_macro</code>中新建 <code>passage-end-tag.swig</code> 文件，并添加以下内容：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;% if not is_index %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;text-align:center;color: #ccc;font-size:14px;&quot;</span>&gt;</span>-------------本文结束<span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-paw&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>感谢您的阅读-------------<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>接着打开<code>\themes\next\layout\_macro\post.swig</code>文件，在<code>post-body</code> 之后， <code>post-footer</code> 之前添加如下画红色部分代码（<code>post-footer</code>之前两个DIV），代码如下：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  &#123;% if not is_index %&#125;</span><br><span class="line">    &#123;% include &#x27;passage-end-tag.swig&#x27; %&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>然后打开主题配置文件（_config.yml)，在末尾添加：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文章末尾添加“本文结束”标记</span></span><br><span class="line">passage_end_tag:</span><br><span class="line">  enabled: true</span><br></pre></td></tr></table></figure></div>

<h3 id="主页文章添加阴影效果-1"><a href="#主页文章添加阴影效果-1" class="headerlink" title="主页文章添加阴影效果"></a>主页文章添加阴影效果</h3><p>打开<code>\themes\next\source\css\_custom\custom.styl</code>，向里面加入：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">// 主页文章添加阴影效果</span><br><span class="line"> .post &#123;</span><br><span class="line">   margin-top: 60px;</span><br><span class="line">   margin-bottom: 60px;</span><br><span class="line">   padding: 25px;</span><br><span class="line">   -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5);</span><br><span class="line">   -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="设置网站的图标Favicon"><a href="#设置网站的图标Favicon" class="headerlink" title="设置网站的图标Favicon"></a>设置网站的图标Favicon</h3><p>一张（32*32）的ico图标，或者去别的网站下载或者制作，并将图标名称改为favicon.ico，然后把图标放在<code>/themes/next/source/images</code>里，并且修改主题配置文件：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Put your favicon.ico into `hexo-site/source/` directory.</span></span><br><span class="line">favicon: /favicon.ico</span><br></pre></td></tr></table></figure></div>

<h3 id="在文章底部增加版权信息"><a href="#在文章底部增加版权信息" class="headerlink" title="在文章底部增加版权信息"></a>在文章底部增加版权信息</h3><p>在目录 <code>next/layout/_macro/</code>下添加 <code>my-copyright.swig</code>：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% if page.copyright %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;my_post_copyright&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- JS库 sweetalert 可修改路径 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/sweetalert/dist/sweetalert.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>本文标题:<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot;</span>&gt;</span>&#123;&#123; page.title &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>文章作者:<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/&quot;</span> <span class="attr">title</span>=<span class="string">&quot;访问 &#123;&#123; theme.author &#125;&#125; 的个人博客&quot;</span>&gt;</span>&#123;&#123; theme.author &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>发布时间:<span class="tag">&lt;/<span class="name">span</span>&gt;</span>&#123;&#123; page.date.format(&quot;YYYY年MM月DD日 - HH:mm&quot;) &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>最后更新:<span class="tag">&lt;/<span class="name">span</span>&gt;</span>&#123;&#123; page.updated.format(&quot;YYYY年MM月DD日 - HH:mm&quot;) &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>原始链接:<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot;</span> <span class="attr">title</span>=<span class="string">&quot;&#123;&#123; page.title &#125;&#125;&quot;</span>&gt;</span>&#123;&#123; page.permalink &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;copy-path&quot;</span>  <span class="attr">title</span>=<span class="string">&quot;点击复制文章链接&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-clipboard&quot;</span> <span class="attr">data-clipboard-text</span>=<span class="string">&quot;&#123;&#123; page.permalink &#125;&#125;&quot;</span>  <span class="attr">aria-label</span>=<span class="string">&quot;复制成功！&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>许可协议:<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-creative-commons&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> <span class="tag">&lt;<span class="name">a</span> <span class="attr">rel</span>=<span class="string">&quot;license&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://creativecommons.org/licenses/by-nc-nd/4.0/&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">title</span>=<span class="string">&quot;Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)&quot;</span>&gt;</span>署名-非商业性使用-禁止演绎 4.0 国际<span class="tag">&lt;/<span class="name">a</span>&gt;</span> 转载请保留原文链接及作者。<span class="tag">&lt;/<span class="name">p</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"> </span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> clipboard = <span class="keyword">new</span> <span class="title class_">Clipboard</span>(<span class="string">&#x27;.fa-clipboard&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    $(<span class="string">&quot;.fa-clipboard&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">      clipboard.<span class="title function_">on</span>(<span class="string">&#x27;success&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">swal</span>(&#123;   </span></span><br><span class="line"><span class="language-javascript">          <span class="attr">title</span>: <span class="string">&quot;&quot;</span>,   </span></span><br><span class="line"><span class="language-javascript">          <span class="attr">text</span>: <span class="string">&#x27;复制成功&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">icon</span>: <span class="string">&quot;success&quot;</span>, </span></span><br><span class="line"><span class="language-javascript">          <span class="attr">showConfirmButton</span>: <span class="literal">true</span></span></span><br><span class="line"><span class="language-javascript">          &#125;);</span></span><br><span class="line"><span class="language-javascript">	&#125;);</span></span><br><span class="line"><span class="language-javascript">    &#125;);  </span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></div>

<p>在目录<code>next/source/css/_common/components/post/</code>下添加<code>my-post-copyright.styl</code>：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">.my_post_copyright &#123;</span><br><span class="line">  width: 85%;</span><br><span class="line">  max-width: 45em;</span><br><span class="line">  margin: 2.8em auto 0;</span><br><span class="line">  padding: 0.5em 1.0em;</span><br><span class="line">  border: 1px solid #d3d3d3;</span><br><span class="line">  font-size: 0.93rem;</span><br><span class="line">  line-height: 1.6em;</span><br><span class="line">  word-break: break-all;</span><br><span class="line">  background: rgba(255,255,255,0.4);</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright p&#123;margin:0;&#125;</span><br><span class="line">.my_post_copyright span &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  width: 5.2em;</span><br><span class="line">  color: #b5b5b5;</span><br><span class="line">  font-weight: bold;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright .raw &#123;</span><br><span class="line">  margin-left: 1em;</span><br><span class="line">  width: 5em;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright a &#123;</span><br><span class="line">  color: #808080;</span><br><span class="line">  border-bottom:0;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright a:hover &#123;</span><br><span class="line">  color: #a3d2a3;</span><br><span class="line">  text-decoration: underline;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright:hover .fa-clipboard &#123;</span><br><span class="line">  color: #000;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright .post-url:hover &#123;</span><br><span class="line">  font-weight: normal;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright .copy-path &#123;</span><br><span class="line">  margin-left: 1em;</span><br><span class="line">  width: 1em;</span><br><span class="line">  +mobile()&#123;display:none;&#125;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright .copy-path:hover &#123;</span><br><span class="line">  color: #808080;</span><br><span class="line">  cursor: pointer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>修改<code>next/layout/_macro/post.swig</code>，在代码</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">      &#123;% if not is_index %&#125;</span><br><span class="line">        &#123;% include &#x27;wechat-subscriber.swig&#x27; %&#125;</span><br><span class="line">      &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></div>

<p>之前添加增加如下代码：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      &#123;% if not is_index %&#125;</span><br><span class="line">        &#123;% include &#x27;my-copyright.swig&#x27; %&#125;</span><br><span class="line">      &#123;% endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>修改<code>next/source/css/_common/components/post/post.styl</code>文件，在最后一行增加代码：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">@import &quot;my-post-copyright&quot;</span><br></pre></td></tr></table></figure></div>

<p>保存重新生成即可。<br>如果要在该博文下面增加版权信息的显示，需要在 Markdown 中增加<code>copyright: true</code>的设置</p>
<p>如果你觉得每次都要输入<code>copyright: true</code>很麻烦的话,那么在<code>/scaffolds/post.md</code>文件中添加：</p>
<div class="highlight-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">categories: </span><br><span class="line"><span class="section">copyright:</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure></div>

<p>这样每次hexo new “你的内容”之后，生成的md文件会自动把<code>copyright:</code>加到里面去</p>
<h3 id="隐藏网页底部powered-By-Hexo-x2F-强力驱动"><a href="#隐藏网页底部powered-By-Hexo-x2F-强力驱动" class="headerlink" title="隐藏网页底部powered By Hexo &#x2F; 强力驱动"></a>隐藏网页底部powered By Hexo &#x2F; 强力驱动</h3><p>打开<code>themes/next/layout/_partials/footer.swig</code>，注释或者直接删除以下代码：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% if theme.footer.powered.enable %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;powered-by&quot;</span>&gt;</span>&#123;#</span><br><span class="line">  #&#125;&#123;&#123; __(&#x27;footer.powered&#x27;, next_url(&#x27;https://hexo.io&#x27;, &#x27;Hexo&#x27;, &#123;class: &#x27;theme-link&#x27;&#125;)) &#125;&#125;&#123;#</span><br><span class="line">  #&#125;&#123;% if theme.footer.powered.version %&#125; v&#123;&#123; hexo_env(&#x27;version&#x27;) &#125;&#125;&#123;% endif %&#125;&#123;#</span><br><span class="line"> #&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% if theme.footer.powered.enable and theme.footer.theme.enable %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-divider&quot;</span>&gt;</span>|<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% if theme.footer.theme.enable %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;theme-info&quot;</span>&gt;</span>&#123;#</span><br><span class="line">  #&#125;&#123;&#123; __(&#x27;footer.theme&#x27;) &#125;&#125; – &#123;&#123; next_url(&#x27;https://theme-next.org&#x27;, &#x27;NexT.&#x27; + theme.scheme, &#123;class: &#x27;theme-link&#x27;&#125;) &#125;&#125;&#123;#</span><br><span class="line">  #&#125;&#123;% if theme.footer.theme.version %&#125; v&#123;&#123; version &#125;&#125;&#123;% endif %&#125;&#123;#</span><br><span class="line">#&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="添加站内搜索"><a href="#添加站内搜索" class="headerlink" title="添加站内搜索"></a>添加站内搜索</h3><p>安装<code>hexo-generator-searchdb</code>插件</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure></div>

<p>编辑<code>_config.yml</code>站点配置文件，新增以下内容到任意位置：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure></div>

<p>编辑<code>themes/next/_config.yml</code> 主题配置文件，启用本地搜索功能,将<code>local_search:</code>下面的<code>enable:</code>的值，改成<code>true</code></p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Local search</span></span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure></div>

<h3 id="首页不显示全文-只显示预览"><a href="#首页不显示全文-只显示预览" class="headerlink" title="首页不显示全文(只显示预览)"></a>首页不显示全文(只显示预览)</h3><p>打开主题配置文件<code>/themes/next/_config.yml</code>，将<code>auto_excerpt</code>下面的<code>enable:</code>的值，改成<code>true</code></p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Automatically Excerpt. Not recommand.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Please use &lt;!-- more --&gt; <span class="keyword">in</span> the post to control excerpt accurately.</span></span><br><span class="line">auto_excerpt:</span><br><span class="line">enable: true</span><br><span class="line">length: 150</span><br></pre></td></tr></table></figure></div>

<p>除了这个方法，还有一个更灵活的方法，直接在编辑的文章中添加<!--more-->标记。这样只会显示<!--more-->标记之前的那部份。</p>
<h3 id="添加打赏功能"><a href="#添加打赏功能" class="headerlink" title="添加打赏功能"></a>添加打赏功能</h3><p>打开<code>themes/next/_config.yml</code>站点配置文件，找到<code># Reward</code>把<code>wechatpay:</code>和<code>alipay:</code>前面的<code>#</code>号删除。然后将自己的二维码文件<code>wechatpay.jpg</code>、<code>alipay.jpg</code>图片放入<code>themes/next/source/images</code>中即可。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Reward</span></span><br><span class="line">reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！</span><br><span class="line">wechatpay: /images/wechatpay.jpg</span><br><span class="line">alipay: /images/alipay.jpg</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">bitcoin: /images/bitcoin.png</span></span><br></pre></td></tr></table></figure></div>

<h3 id="Hexo载入动画效果"><a href="#Hexo载入动画效果" class="headerlink" title="Hexo载入动画效果"></a>Hexo载入动画效果</h3><p>编辑<code>themes/netx/_config.yml</code>找到<code>motion</code>,将<code>enable</code>的值，改成<code>true</code></p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Use velocity to animate everything.</span></span><br><span class="line">motion:</span><br><span class="line">  enable: true</span><br><span class="line">  async: false</span><br><span class="line">  transition:</span><br><span class="line">    # Transition variants:</span><br><span class="line">    # fadeIn | fadeOut | flipXIn | flipXOut | flipYIn | flipYOut | flipBounceXIn | flipBounceXOut | flipBounceYIn | flipBounceYOut</span><br><span class="line">    # swoopIn | swoopOut | whirlIn | whirlOut | shrinkIn | shrinkOut | expandIn | expandOut</span><br><span class="line">    # bounceIn | bounceOut | bounceUpIn | bounceUpOut | bounceDownIn | bounceDownOut | bounceLeftIn | bounceLeftOut | bounceRightIn | bounceRightOut</span><br><span class="line">    # slideUpIn | slideUpOut | slideDownIn | slideDownOut | slideLeftIn | slideLeftOut | slideRightIn | slideRightOut</span><br><span class="line">    # slideUpBigIn | slideUpBigOut | slideDownBigIn | slideDownBigOut | slideLeftBigIn | slideLeftBigOut | slideRightBigIn | slideRightBigOut</span><br><span class="line">    # perspectiveUpIn | perspectiveUpOut | perspectiveDownIn | perspectiveDownOut | perspectiveLeftIn | perspectiveLeftOut | perspectiveRightIn | perspectiveRightOut</span><br><span class="line">    post_block: fadeIn</span><br><span class="line">    post_header: slideDownIn</span><br><span class="line">    post_body: slideDownIn</span><br><span class="line">    coll_header: slideLeftIn</span><br><span class="line">    # Only for Pisces | Gemini.</span><br><span class="line">    sidebar: slideUpIn</span><br></pre></td></tr></table></figure></div>

<p><code>#</code>号里都是载入效果，有时间可以自己多试一试！</p>
<h3 id="美化右侧滚动条"><a href="#美化右侧滚动条" class="headerlink" title="美化右侧滚动条"></a>美化右侧滚动条</h3><p>打开<code>themes\next\source\css\_custom\custom.styl</code>文件，将下面的代码添加进去。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">//设置滚动条的样式</span><br><span class="line">//参考https://segmentfault.com/a/1190000003708894</span><br><span class="line">::-webkit-scrollbar &#123;</span><br><span class="line">      width: 5px;</span><br><span class="line">      height: 5px;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//滚动槽</span><br><span class="line">::-webkit-scrollbar-track &#123;</span><br><span class="line">      background: #eee;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//滚动条滑块</span><br><span class="line">::-webkit-scrollbar-thumb &#123;</span><br><span class="line">      border-radius: 5px;</span><br><span class="line">        background-color: #ccc;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">::-webkit-scrollbar-thumb:hover &#123;</span><br><span class="line">      background-color: rgb(247, 149, 51);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="优化鼠标选择文字的样式"><a href="#优化鼠标选择文字的样式" class="headerlink" title="优化鼠标选择文字的样式"></a>优化鼠标选择文字的样式</h3><p>打开<code>themes\next\source\css\_custom\custom.styl</code>文件，将下面的代码添加进去。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">::selection &#123;</span><br><span class="line">      background-color: rgb(255, 241, 89);</span><br><span class="line">        color: #555;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="网页中文乱码解决办法"><a href="#网页中文乱码解决办法" class="headerlink" title="网页中文乱码解决办法"></a>网页中文乱码解决办法</h3><p>所有配置文件都可以用记事本打开，如果输入中文后网页显示乱码，则需要将该文件另存为<code>utf-8</code>编码文件</p>
<p>即打开后点击左上角 文件—&gt;另存为，然后在弹出的窗口下方有一个 编码 的下拉菜单，点击选择<code>UTF-8</code>选项，然后点击保存，会提示 是否替换，选择 是 即可。以后出现中文乱码问题都这样解决</p>
<h3 id="设置侧边栏头像"><a href="#设置侧边栏头像" class="headerlink" title="设置侧边栏头像"></a>设置侧边栏头像</h3><p>将头像图片放在主题目录的<code>source/images/</code>目录下，尺寸是正方形即可，然后将照片改名为avatar.jpg，或者其他后缀名的图片。<br>编辑 <code>主题配置文件</code>，找到关键字avatar，删掉前面的#号，值设置成头像的链接地址，比如</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">avatar: /images/avatar.jpg</span><br></pre></td></tr></table></figure></div>

<p>保存后可用hexo s打开本地服务器预览一下效果</p>
<h3 id="修改链接样式"><a href="#修改链接样式" class="headerlink" title="修改链接样式"></a>修改链接样式</h3><p>在<code>themes\next\source\css\_common\components\post\post.styl</code>在末尾添加如下css样式：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">// 文章内链接文本样式</span><br><span class="line">.post-body p a&#123;</span><br><span class="line">  color: #0593d3;</span><br><span class="line">  border-bottom: none;</span><br><span class="line">  border-bottom: 1px solid #0593d3;</span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    color: #fc6423;</span><br><span class="line">    border-bottom: none;</span><br><span class="line">    border-bottom: 1px solid #fc6423;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Java排序算法</title>
    <url>/2019/11/12/Java%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="排序算法分类"><a href="#排序算法分类" class="headerlink" title="排序算法分类"></a>排序算法分类</h2><p>十种常见排序算法可以分为两大类：</p>
 <span id="more"></span>
<p><strong>非线性时间比较类排序</strong>：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此称为非线性时间比较类排序。</p>
<p><strong>线性时间非比较类排序</strong>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。</p>
<p>如下图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/21342134.png"
                     
                ></p>
<h2 id="排序算法复杂度及稳定性"><a href="#排序算法复杂度及稳定性" class="headerlink" title="排序算法复杂度及稳定性"></a>排序算法复杂度及稳定性</h2><p>如下图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://imgkr.cn-bj.ufileos.com/2a0c0fd4-66e5-4912-8e22-dd69c2ea1dbb.png"
                     
                ></p>
<p>相关概念：</p>
<p><strong>稳定</strong>：如果a原本在b前面，而a&#x3D;b，排序之后a仍然在b的前面。</p>
<p><strong>不稳定</strong>：如果a原本在b的前面，而a&#x3D;b，排序之后 a 可能会出现在 b 的后面。</p>
<p><strong>时间复杂度</strong>：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</p>
<p><strong>空间复杂度</strong>：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。</p>
<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h3><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
<p><strong>算法描述</strong></p>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>
<li>针对所有的元素重复以上的步骤，除了最后一个；</li>
<li>重复步骤1~3，直到排序完成。</li>
</ol>
<p><strong>动图演示</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://imgkr.cn-bj.ufileos.com/849409db-eab0-4882-abf0-c71221d8b03e.gif"
                     
                ></p>
<p><strong>代码实现</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] bubbleSort(<span class="type">int</span>[] a)&#123;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.length-<span class="number">1</span>;i++)&#123;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;a.length;j++)&#123;  </span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;a[j])&#123;  </span><br><span class="line">                <span class="type">int</span> temp=a[i];  </span><br><span class="line">                a[i]=a[j];  </span><br><span class="line">                a[j]=temp;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> a;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="简单选择排序（Selection-Sort）"><a href="#简单选择排序（Selection-Sort）" class="headerlink" title="简单选择排序（Selection Sort）"></a>简单选择排序（Selection Sort）</h3><p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<p><strong>算法描述</strong></p>
<p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p>
<ol>
<li>初始状态：无序区为R[1..n]，有序区为空；</li>
<li>第i趟排序(i&#x3D;1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n)。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n]分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li>
<li>n-1趟结束，数组有序化了。</li>
</ol>
<p><strong>动图演示</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://imgkr.cn-bj.ufileos.com/f16c258a-08de-43a0-8b02-65e132e12910.gif"
                     
                ></p>
<p><strong>代码实现</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] simpleSelectSort(<span class="type">int</span>[] a)&#123;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.length-<span class="number">1</span>;i++)&#123;  </span><br><span class="line">        <span class="type">int</span> min=i;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;a.length;j++)&#123;  </span><br><span class="line">            <span class="keyword">if</span>(a[min]&gt;a[j])&#123;  </span><br><span class="line">                min=j;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(min!=i)&#123;  </span><br><span class="line">            <span class="type">int</span> temp=a[i];  </span><br><span class="line">            a[i]=a[min];  </span><br><span class="line">            a[min]=temp;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> a;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>算法分析</strong></p>
<p>表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。</p>
<h3 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h3><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<p><strong>算法描述</strong></p>
<p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p>
<ol>
<li>从第一个元素开始，该元素可以认为已经被排序；</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>将新元素插入到该位置后；</li>
<li>重复步骤2~5。</li>
</ol>
<p><strong>动图演示</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://imgkr.cn-bj.ufileos.com/4c5d7b58-1e47-491c-b387-f4d73d2eb3e9.gif"
                     
                ></p>
<p><strong>代码实现</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] straightInsertionSort(<span class="type">int</span>[] a)&#123;  </span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;a.length;i++)&#123;  </span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> j=i;j&gt;<span class="number">0</span>;j--)&#123;  </span><br><span class="line">             <span class="keyword">if</span>(a[j]&lt;a[j-<span class="number">1</span>])&#123;  </span><br><span class="line">                 <span class="type">int</span> temp=a[j-<span class="number">1</span>];  </span><br><span class="line">                 a[j-<span class="number">1</span>]=a[j];  </span><br><span class="line">                 a[j]=temp;  </span><br><span class="line">             &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">                 <span class="keyword">break</span>;  </span><br><span class="line">             &#125;  </span><br><span class="line">         &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">return</span> a;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>算法分析</strong></p>
<p>插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
<h3 id="希尔排序（Shell-Sort）"><a href="#希尔排序（Shell-Sort）" class="headerlink" title="希尔排序（Shell Sort）"></a>希尔排序（Shell Sort）</h3><p>1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。</p>
<p><strong>算法描述</strong></p>
<p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>
<ol>
<li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk&#x3D;1；</li>
<li>按增量序列个数k，对序列进行k 趟排序；</li>
<li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ol>
<p><strong>动图演示</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://imgkr.cn-bj.ufileos.com/6d3eb18f-bcc5-42ce-a0cb-368163d8da1b.gif"
                     
                ></p>
<p><strong>代码实现</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] shellsSort(<span class="type">int</span> a[]) &#123;  </span><br><span class="line">     <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> a.length;  </span><br><span class="line">     <span class="keyword">while</span> (<span class="literal">true</span>) &#123;  </span><br><span class="line">         d = d / <span class="number">2</span>;  </span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; d; x++) &#123;  </span><br><span class="line">             <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> x + d; i &lt; a.length; i = i + d) &#123;  </span><br><span class="line">                 <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[i];  </span><br><span class="line">                 <span class="type">int</span> j;  </span><br><span class="line">                 <span class="keyword">for</span> (j = i - d; j &gt;= <span class="number">0</span> &amp;&amp; a[j] &gt; temp; j = j - d) &#123;  </span><br><span class="line">                     a[j + d] = a[j];  </span><br><span class="line">                 &#125;  </span><br><span class="line">                 a[j + d] = temp;  </span><br><span class="line">             &#125;  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="keyword">if</span> (d == <span class="number">1</span>) &#123;  </span><br><span class="line">             <span class="keyword">break</span>;  </span><br><span class="line">         &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">return</span> a;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>算法分析</strong></p>
<p>希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版）》的合著者Robert Sedgewick提出的。</p>
<h3 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h3><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p>
<p><strong>算法描述</strong></p>
<ol>
<li>把长度为n的输入序列分成两个长度为n&#x2F;2的子序列；</li>
<li>对这两个子序列分别采用归并排序；</li>
<li>将两个排序好的子序列合并成一个最终的排序序列。</li>
</ol>
<p><strong>动图演示</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://imgkr.cn-bj.ufileos.com/72193215-6629-41b7-9f66-023effc70b02.gif"
                     
                ></p>
<p><strong>代码实现</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] mergeSort(<span class="type">int</span> a[])&#123;  </span><br><span class="line">    sort(a,<span class="number">0</span>,<span class="number">1</span>);  </span><br><span class="line">    <span class="keyword">return</span> a;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> s, <span class="type">int</span> len)</span> &#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> a.length;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> size / (len &lt;&lt; <span class="number">1</span>);  </span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> size &amp; ((len &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>);  </span><br><span class="line">    <span class="comment">//　-------归并到只剩一个有序集合的时候结束算法-------//  </span></span><br><span class="line">    <span class="keyword">if</span> (mid == <span class="number">0</span>)  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    <span class="comment">//　------进行一趟归并排序-------//  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mid; ++i) &#123;  </span><br><span class="line">        s = i * <span class="number">2</span> * len;  </span><br><span class="line">        merge(a, s, s + len, (len &lt;&lt; <span class="number">1</span>) + s - <span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//　-------将剩下的数和倒数一个有序集合归并-------//  </span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>)  </span><br><span class="line">        merge(a, size - c - <span class="number">2</span> * len, size - c, size - <span class="number">1</span>);  </span><br><span class="line">    <span class="comment">//　-------递归执行下一趟归并排序------//  </span></span><br><span class="line">    sort(a, <span class="number">0</span>, <span class="number">2</span> * len);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> s, <span class="type">int</span> m, <span class="type">int</span> t)</span> &#123;  </span><br><span class="line">    <span class="type">int</span>[] tmp = <span class="keyword">new</span> <span class="title class_">int</span>[t - s + <span class="number">1</span>];  </span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s, j = m, k = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (i &lt; m &amp;&amp; j &lt;= t) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt;= a[j]) &#123;  </span><br><span class="line">            tmp[k] = a[i];  </span><br><span class="line">            k++;  </span><br><span class="line">            i++;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            tmp[k] = a[j];  </span><br><span class="line">            j++;  </span><br><span class="line">            k++;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">while</span> (i &lt; m) &#123;  </span><br><span class="line">        tmp[k] = a[i];  </span><br><span class="line">        i++;  </span><br><span class="line">        k++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">while</span> (j &lt;= t) &#123;  </span><br><span class="line">        tmp[k] = a[j];  </span><br><span class="line">        j++;  </span><br><span class="line">        k++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    System.arraycopy(tmp, <span class="number">0</span>, a, s, tmp.length);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>算法分析</strong></p>
<p>归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。代价是需要额外的内存空间。</p>
<h3 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h3><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
<p><strong>算法描述</strong></p>
<p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>
<ol>
<li>从数列中挑出一个元素，称为 “基准”（pivot）；</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ol>
<p><strong>动图演示</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://imgkr.cn-bj.ufileos.com/820e7fd6-0415-4e2f-b86e-54be0e812916.gif"
                     
                ></p>
<p><strong>代码实现</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] quickSort(<span class="type">int</span> a[],<span class="type">int</span> low,<span class="type">int</span> high)&#123;  </span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)&#123;  </span><br><span class="line">        <span class="type">int</span> privotLoc=partition(a,low,high);<span class="comment">//将表一分为二  </span></span><br><span class="line">        quickSort(a,low,privotLoc-<span class="number">1</span>);  </span><br><span class="line">        quickSort(a,privotLoc+<span class="number">1</span>,high);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> a;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> privotKey=a[low];<span class="comment">//基准元素  </span></span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)&#123;     <span class="comment">//从表的两端交替向中间扫描  </span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;a[high]&gt;=privotKey)&#123;   <span class="comment">//从high 所指位置向前搜索，至多到low+1 位置。将比基准元素小的交换到低端  </span></span><br><span class="line">            --high;                             <span class="comment">//从右找比基准元素少的  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        a[low]=a[high];                         <span class="comment">//如果比基准元素小，交换位置  </span></span><br><span class="line">        a[high]=privotKey;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;a[low]&lt;=privotKey)&#123;  </span><br><span class="line">            ++low;                              <span class="comment">//从右找比基准元素大的  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        a[high]=a[low];                          <span class="comment">//如果比基准元素大，交换位置  </span></span><br><span class="line">        a[low]=privotKey;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> low;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a>堆排序（Heap Sort）</h3><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<p><strong>算法描述</strong></p>
<ol>
<li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li>
<li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;&#x3D;R[n]；</li>
<li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li>
</ol>
<p><strong>动图演示</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://imgkr.cn-bj.ufileos.com/aad352e0-fc8b-4556-922c-5f675a48722d.gif"
                     
                ></p>
<p><strong>代码实现</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] heapSort(<span class="type">int</span> a[])&#123;  </span><br><span class="line">     buildMaxHeapTree(a);  </span><br><span class="line">     sort(a);  </span><br><span class="line">     <span class="keyword">return</span> a;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">buildMaxHeapTree</span><span class="params">(<span class="type">int</span> a[])</span>&#123;  </span><br><span class="line">     <span class="comment">//没有子节点的才需要创建最大堆，从最后一个的父节点开始  </span></span><br><span class="line">     <span class="type">int</span> startIndex=getParentIndex(a.length-<span class="number">1</span>);  </span><br><span class="line">     <span class="comment">//从尾端开始创建最大堆，每次都是正确的堆  </span></span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=startIndex;i&gt;=<span class="number">0</span>;i--)&#123;  </span><br><span class="line">         maxHeap(a,a.length,i);  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">maxHeap</span><span class="params">(<span class="type">int</span>[] data, <span class="type">int</span> heapSize, <span class="type">int</span> index)</span> &#123;  </span><br><span class="line">     <span class="comment">//当前点与左右子节点比较  </span></span><br><span class="line">     <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> getChildLeftIndex(index);  </span><br><span class="line">     <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> getChildRightIndex(index);  </span><br><span class="line">  </span><br><span class="line">     <span class="type">int</span> <span class="variable">largest</span> <span class="operator">=</span> index;  </span><br><span class="line">     <span class="keyword">if</span> (left &lt; heapSize &amp;&amp; data[index] &lt; data[left]) &#123;  </span><br><span class="line">         largest = left;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">if</span> (right &lt; heapSize &amp;&amp; data[largest] &lt; data[right]) &#123;  </span><br><span class="line">         largest = right;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="comment">//得到最大值后可能需要交换，如果交换了，其子节点可能就不是最大堆了，需要重新调整  </span></span><br><span class="line">     <span class="keyword">if</span> (largest != index) &#123;  </span><br><span class="line">         <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> data[index];  </span><br><span class="line">         data[index] = data[largest];  </span><br><span class="line">         data[largest] = temp;  </span><br><span class="line">         maxHeap(data, heapSize, largest);  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getParentIndex</span><span class="params">(<span class="type">int</span> current)</span>&#123;  </span><br><span class="line">     <span class="keyword">return</span> (current-<span class="number">1</span>)&gt;&gt;<span class="number">2</span>;  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getChildLeftIndex</span><span class="params">(<span class="type">int</span> current)</span>&#123;  </span><br><span class="line">     <span class="keyword">return</span>(current&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getChildRightIndex</span><span class="params">(<span class="type">int</span> current)</span>&#123;  </span><br><span class="line">     <span class="keyword">return</span>(current&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] data)</span>&#123;  </span><br><span class="line">     <span class="comment">//末尾与头交换，交换后调整最大堆  </span></span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=data.length-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--)&#123;  </span><br><span class="line">         <span class="type">int</span> temp=data[<span class="number">0</span>];  </span><br><span class="line">         data[<span class="number">0</span>]=data[i];  </span><br><span class="line">         data[i]=temp;  </span><br><span class="line">         maxHeap(data,i,<span class="number">0</span>);  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="计数排序（Counting-Sort）"><a href="#计数排序（Counting-Sort）" class="headerlink" title="计数排序（Counting Sort）"></a>计数排序（Counting Sort）</h3><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<p><strong>算法描述</strong></p>
<ol>
<li>找出待排序的数组中最大和最小的元素；</li>
<li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li>
<li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li>
<li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li>
</ol>
<p><strong>动图演示</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://imgkr.cn-bj.ufileos.com/52c3b382-7fbb-42fb-bdf3-917b63d001df.gif"
                     
                ></p>
<p><strong>代码实现</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] countSort(<span class="type">int</span>[]a)&#123;  </span><br><span class="line">    <span class="type">int</span> b[] = <span class="keyword">new</span> <span class="title class_">int</span>[a.length];  </span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> a[<span class="number">0</span>],min = a[<span class="number">0</span>];  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i:a)&#123;  </span><br><span class="line">        <span class="keyword">if</span>(i&gt;max)&#123;  </span><br><span class="line">            max=i;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(i&lt;min)&#123;  </span><br><span class="line">            min=i;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;<span class="comment">//这里k的大小是要排序的数组中，元素大小的极值差+1  </span></span><br><span class="line">    <span class="type">int</span> k=max-min+<span class="number">1</span>;  </span><br><span class="line">    <span class="type">int</span> c[]=<span class="keyword">new</span> <span class="title class_">int</span>[k];  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.length;++i)&#123;  </span><br><span class="line">        c[a[i]-min]+=<span class="number">1</span>;<span class="comment">//优化过的地方，减小了数组c的大小  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;c.length;++i)&#123;  </span><br><span class="line">        c[i]=c[i]+c[i-<span class="number">1</span>];  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;--i)&#123;  </span><br><span class="line">        b[--c[a[i]-min]]=a[i];<span class="comment">//按存取的方式取出c的元素  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> b;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>算法分析</strong></p>
<p>计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。</p>
<h3 id="桶排序（Bucket-Sort）"><a href="#桶排序（Bucket-Sort）" class="headerlink" title="桶排序（Bucket Sort）"></a>桶排序（Bucket Sort）</h3><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p>
<p><strong>算法描述</strong></p>
<ol>
<li>设置一个定量的数组当作空桶；</li>
<li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li>
<li>对每个不是空的桶进行排序；</li>
<li>从不是空的桶里把排好序的数据拼接起来。</li>
</ol>
<p><strong>图片演示</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://imgkr.cn-bj.ufileos.com/107896bc-f532-4520-a7fa-1eb49c2154b2.png"
                     
                ></p>
<p><strong>代码实现</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">basket</span><span class="params">(<span class="type">int</span> data[])</span><span class="comment">//data为待排序数组  </span></span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> data.length;  </span><br><span class="line">    <span class="type">int</span> bask[][] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][n];  </span><br><span class="line">    <span class="type">int</span> index[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];  </span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;  </span><br><span class="line">        max = max &gt; (Integer.toString(data[i]).length()) ? max : (Integer.toString(data[i]).length());  </span><br><span class="line">    &#125;  </span><br><span class="line">    String str;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> max - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;  </span><br><span class="line">            str = <span class="string">&quot;&quot;</span>;  </span><br><span class="line">            <span class="keyword">if</span> (Integer.toString(data[j]).length() &lt; max) &#123;  </span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; max - Integer.toString(data[j]).length(); k++)  </span><br><span class="line">                    str += <span class="string">&quot;0&quot;</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            str += Integer.toString(data[j]);  </span><br><span class="line">            bask[str.charAt(i) - <span class="string">&#x27;0&#x27;</span>][index[str.charAt(i) - <span class="string">&#x27;0&#x27;</span>]++] = data[j];  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; index[j]; k++) &#123;  </span><br><span class="line">                data[pos++] = bask[j][k];  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; <span class="number">10</span>; x++) index[x] = <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>算法分析</strong></p>
<p>桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。</p>
<h3 id="基数排序（Radix-Sort）"><a href="#基数排序（Radix-Sort）" class="headerlink" title="基数排序（Radix Sort）"></a>基数排序（Radix Sort）</h3><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p>
<p><strong>算法描述</strong></p>
<ol>
<li>取得数组中的最大数，并取得位数；</li>
<li>arr为原始数组，从最低位开始取每个位组成radix数组；</li>
<li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li>
</ol>
<p><strong>动图演示</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://imgkr.cn-bj.ufileos.com/746d8380-40e5-4fe5-8696-23080a4bec74.gif"
                     
                ></p>
<p><strong>代码实现</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] number, <span class="type">int</span> d)</span> <span class="comment">//d表示最大的数有多少位  </span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1</span>;  </span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">//控制键值排序依据在哪一位  </span></span><br><span class="line">        <span class="type">int</span>[][] temp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][number.length]; <span class="comment">//数组的第一维表示可能的余数0-9  </span></span><br><span class="line">        <span class="type">int</span>[] order = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>]; <span class="comment">//数组orderp[i]用来表示该位是i的数的个数  </span></span><br><span class="line">        <span class="keyword">while</span> (m &lt;= d) &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; number.length; i++) &#123;  </span><br><span class="line">                <span class="type">int</span> <span class="variable">lsd</span> <span class="operator">=</span> ((number[i] / n) % <span class="number">10</span>);  </span><br><span class="line">                temp[lsd][order[lsd]] = number[i];  </span><br><span class="line">                order[lsd]++;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (order[i] != <span class="number">0</span>)  </span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; order[i]; j++) &#123;  </span><br><span class="line">                        number[k] = temp[i][j];  </span><br><span class="line">                        k++;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                order[i] = <span class="number">0</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            n *= <span class="number">10</span>;  </span><br><span class="line">            k = <span class="number">0</span>;  </span><br><span class="line">            m++;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>算法分析</strong></p>
<p>基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2n) ，当然d要远远小于n，因此基本上还是线性级别的。</p>
<p>基数排序的空间复杂度为O(n+k)，其中k为桶的数量。一般来说n&gt;&gt;k，因此额外空间需要大概n个左右。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>新建Test类，测试十种排序算法时间消耗。</p>
<p><strong>代码实现</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line"><span class="comment">//        int arrayLength=10;  </span></span><br><span class="line"><span class="comment">//        int range=100;  </span></span><br><span class="line">        <span class="type">int</span> arrayLength=<span class="number">100000</span>;  </span><br><span class="line">        <span class="type">int</span> range=<span class="number">100000</span>;  </span><br><span class="line">        <span class="comment">//生成一个指定长度数据的int数组  </span></span><br><span class="line">        <span class="type">int</span>[] a=<span class="keyword">new</span> <span class="title class_">int</span>[arrayLength];  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;arrayLength;i++)&#123;  </span><br><span class="line">            a[i]=(<span class="type">int</span>)(Math.random()*range);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//创建十个数组用于测试，否则会冲突  </span></span><br><span class="line">        <span class="type">int</span>[] a1= a.clone();  </span><br><span class="line">        <span class="type">int</span>[] a2= a.clone();  </span><br><span class="line">        <span class="type">int</span>[] a3= a.clone();  </span><br><span class="line">        <span class="type">int</span>[] a4= a.clone();  </span><br><span class="line">        <span class="type">int</span>[] a5= a.clone();  </span><br><span class="line">        <span class="type">int</span>[] a6= a.clone();  </span><br><span class="line">        <span class="type">int</span>[] a7= a.clone();  </span><br><span class="line">        <span class="type">int</span>[] a8= a.clone();  </span><br><span class="line">        <span class="type">int</span>[] a9= a.clone();  </span><br><span class="line">        <span class="type">int</span>[] a10= a.clone();  </span><br><span class="line">        System.out.println(a1.toString());  </span><br><span class="line">        System.out.println(a2.toString());  </span><br><span class="line">        System.out.println(a3.toString());  </span><br><span class="line">        System.out.println(a4.toString());  </span><br><span class="line">        System.out.println(a5.toString());  </span><br><span class="line">        System.out.println(a6.toString());  </span><br><span class="line">        System.out.println(a7.toString());  </span><br><span class="line">        System.out.println(a8.toString());  </span><br><span class="line">        System.out.println(a9.toString());  </span><br><span class="line">        System.out.println(a10.toString());  </span><br><span class="line">  </span><br><span class="line">        System.gc();  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//直接插入排序法  </span></span><br><span class="line">        <span class="type">long</span> starta1=System.currentTimeMillis();  </span><br><span class="line">        a1= StraightInsertionSort.straightInsertionSort(a1);  </span><br><span class="line">        <span class="type">long</span> enda1=System.currentTimeMillis();  </span><br><span class="line">        System.out.println(<span class="string">&quot;插入排序法耗时：&quot;</span>+(enda1-starta1)+<span class="string">&quot;ms&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//冒泡排序法  </span></span><br><span class="line">        <span class="type">long</span> starta2=System.currentTimeMillis();  </span><br><span class="line">        a2= BubbleSort.bubbleSort(a2);  </span><br><span class="line">        <span class="type">long</span> enda2=System.currentTimeMillis();  </span><br><span class="line">        System.out.println(<span class="string">&quot;冒泡排序法耗时：&quot;</span>+(enda2-starta2)+<span class="string">&quot;ms&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//直接(简单)选择排序法  </span></span><br><span class="line">        <span class="type">long</span> starta3=System.currentTimeMillis();  </span><br><span class="line">        a3= SimpleSelectionSort.simpleSelectSort(a3);  </span><br><span class="line">        <span class="type">long</span> enda3=System.currentTimeMillis();  </span><br><span class="line">        System.out.println(<span class="string">&quot;直接选择排序法耗时：&quot;</span>+(enda3-starta3)+<span class="string">&quot;ms&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//堆排序  </span></span><br><span class="line">        <span class="type">long</span> starta4=System.currentTimeMillis();  </span><br><span class="line">        a4= HeapSort.heapSort(a4);  </span><br><span class="line">        <span class="type">long</span> enda4=System.currentTimeMillis();  </span><br><span class="line">        System.out.println(<span class="string">&quot;堆排序法耗时：&quot;</span>+(enda4-starta4)+<span class="string">&quot;ms&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//归并排序  </span></span><br><span class="line">        <span class="type">long</span> starta5=System.currentTimeMillis();  </span><br><span class="line">        a5= MergeSort.mergeSort(a5);  </span><br><span class="line">        <span class="type">long</span> enda5=System.currentTimeMillis();  </span><br><span class="line">        System.out.println(<span class="string">&quot;归并排序法耗时：&quot;</span>+(enda5-starta5)+<span class="string">&quot;ms&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//快速排序算法  </span></span><br><span class="line">        <span class="type">long</span> starta6=System.currentTimeMillis();  </span><br><span class="line">        a6= QuickSort.quickSort(a6,<span class="number">0</span>,a6.length-<span class="number">1</span>);  </span><br><span class="line">        <span class="type">long</span> enda6=System.currentTimeMillis();  </span><br><span class="line">        System.out.println(<span class="string">&quot;快速排序耗时：&quot;</span>+(enda6-starta6)+<span class="string">&quot;ms&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//计数排序算法  </span></span><br><span class="line">        <span class="type">long</span> starta7=System.currentTimeMillis();  </span><br><span class="line">        a7= CountingSort.countSort(a7);  </span><br><span class="line">        <span class="type">long</span> enda7=System.currentTimeMillis();  </span><br><span class="line">        System.out.println(<span class="string">&quot;计数排序耗时：&quot;</span>+(enda7-starta7)+<span class="string">&quot;ms&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//希尔排序算法  </span></span><br><span class="line">        <span class="type">long</span> starta8=System.currentTimeMillis();  </span><br><span class="line">        a8= ShellsSort.shellsSort(a8);  </span><br><span class="line">        <span class="type">long</span> enda8=System.currentTimeMillis();  </span><br><span class="line">        System.out.println(<span class="string">&quot;希尔排序耗时：&quot;</span>+(enda8-starta8)+<span class="string">&quot;ms&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//桶排序算法  </span></span><br><span class="line">        <span class="type">long</span> starta9=System.currentTimeMillis();  </span><br><span class="line">        a9= BucketSort.basket(a9);  </span><br><span class="line">        <span class="type">long</span> enda9=System.currentTimeMillis();  </span><br><span class="line">        System.out.println(<span class="string">&quot;桶排序耗时：&quot;</span>+(enda9-starta9)+<span class="string">&quot;ms&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//基数排序算法  </span></span><br><span class="line">        <span class="type">long</span> starta10=System.currentTimeMillis();  </span><br><span class="line">        a10= RadixSort.sort(a10,<span class="number">6</span>);  </span><br><span class="line">        <span class="type">long</span> enda10=System.currentTimeMillis();  </span><br><span class="line">        System.out.println(<span class="string">&quot;基数排序耗时：&quot;</span>+(enda10-starta10)+<span class="string">&quot;ms&quot;</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//        ArrayHelper.printLine(a1);  </span></span><br><span class="line"><span class="comment">//        System.out.println();  </span></span><br><span class="line"><span class="comment">//        ArrayHelper.printLine(a2);  </span></span><br><span class="line"><span class="comment">//        System.out.println();  </span></span><br><span class="line"><span class="comment">//        ArrayHelper.printLine(a3);  </span></span><br><span class="line"><span class="comment">//        System.out.println();  </span></span><br><span class="line"><span class="comment">//        ArrayHelper.printLine(a4);  </span></span><br><span class="line"><span class="comment">//        System.out.println();  </span></span><br><span class="line"><span class="comment">//        ArrayHelper.printLine(a5);  </span></span><br><span class="line"><span class="comment">//        System.out.println();  </span></span><br><span class="line"><span class="comment">//        ArrayHelper.printLine(a6);  </span></span><br><span class="line"><span class="comment">//        System.out.println();  </span></span><br><span class="line"><span class="comment">//        ArrayHelper.printLine(a7);  </span></span><br><span class="line"><span class="comment">//        System.out.println();  </span></span><br><span class="line"><span class="comment">//        ArrayHelper.printLine(a8);  </span></span><br><span class="line"><span class="comment">//        System.out.println();  </span></span><br><span class="line"><span class="comment">//        ArrayHelper.printLine(a9);  </span></span><br><span class="line"><span class="comment">//        System.out.println();  </span></span><br><span class="line"><span class="comment">//        ArrayHelper.printLine(a10);  </span></span><br><span class="line">  </span><br><span class="line">        System.gc();  </span><br><span class="line">  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>运行结果</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://imgkr.cn-bj.ufileos.com/0f88fcb3-bd3f-4559-bbfe-caa623098bfc.png"
                     
                ></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux上查询和列出当前活跃的SSH会话的六种方法</title>
    <url>/2021/07/14/Linux%E4%B8%8A%E6%9F%A5%E8%AF%A2%E5%92%8C%E5%88%97%E5%87%BA%E5%BD%93%E5%89%8D%E6%B4%BB%E8%B7%83%E7%9A%84SSH%E4%BC%9A%E8%AF%9D%E7%9A%84%E5%85%AD%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>本文阐述了以下内容：</p>
<ol>
<li>检查并列出所有当前活跃的 SSH 会话；</li>
<li>使用日志文件查看 SSH 连接历史记录。</li>
</ol>
 <span id="more"></span>

<h2 id="查询当前活跃的-SSH-连接"><a href="#查询当前活跃的-SSH-连接" class="headerlink" title="查询当前活跃的 SSH 连接"></a>查询当前活跃的 SSH 连接</h2><p>There are various commands and tools available in Linux which can be used to check active SSH connections or sessions on your Linux node. In this article I will share a list of tools which can be used to get the list of active SSH connections. If you are aware of any more commands to show active ssh sessions then please let me know via comment section.</p>
<h3 id="Using-ss-command"><a href="#Using-ss-command" class="headerlink" title="Using ss command"></a>Using <code>ss</code> command</h3><p><code>ss</code> is used to dump socket statistics. It allows showing information similar to <code>netstat</code>. It can display more TCP and state information than other tools. We will use grep function to only get the list of active SSH sessions on our local host</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node3 ~]# ss | grep -i ssh</span><br><span class="line">tcp    ESTAB      0      0      10.0.2.32:ssh                  10.0.2.31:37802</span><br><span class="line">tcp    ESTAB      0      64     10.0.2.32:ssh                  10.0.2.2:49966</span><br><span class="line">tcp    ESTAB      0      0      10.0.2.32:ssh                  10.0.2.30:56088</span><br></pre></td></tr></table></figure></div>

<p>From the above example we know that there are three hosts which are currently connected to our node3. We have active SSH connections from 10.0.2.31, 10.0.2.30 and 10.0.2.2</p>
<h3 id="Using-last-command"><a href="#Using-last-command" class="headerlink" title="Using last command"></a>Using <code>last</code> command</h3><p><code>last</code> searches back through the file <code>/var/log/wtmp</code> (or the file designated by the <code>-f</code> flag) and displays a list of all users logged in (and out) since that file was created. Names of users and tty’s can be given, in which case last will show only those entries matching the arguments.</p>
<p>Using this command you can also get the information about the user using which the SSH connection was created between server and client. So below we know the connection from 10.0.2.31 is done using ‘<strong>deepak</strong>‘ user, while for other two hosts, ‘<strong>root</strong>‘ user was used for connecting to node3.</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node3 ~]# last -a | grep -i still</span><br><span class="line">deepak   pts/1        Fri May 31 16:58   still logged in    10.0.2.31</span><br><span class="line">root     pts/2        Fri May 31 16:50   still logged in    10.0.2.30</span><br><span class="line">root     pts/0        Fri May 31 09:17   still logged in    10.0.2.2</span><br></pre></td></tr></table></figure></div>

<p>Here I am grepping for a string “still” to get all the patterns with “<strong>still logged in</strong>“. So now we know we have three active SSH connections from 10.0.2.31, 10.0.2.30 and 10.0.2.2</p>
<h3 id="Using-who-command"><a href="#Using-who-command" class="headerlink" title="Using who command"></a>Using <code>who</code> command</h3><p><code>who</code> is used to show who is logged on on your Linux host. This tool can also give this information</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node3 ~]# who</span><br><span class="line">root     pts/0        2019-05-31 09:17 (10.0.2.2)</span><br><span class="line">root     pts/1        2019-05-31 16:47 (10.0.2.31)</span><br><span class="line">root     pts/2        2019-05-31 16:50 (10.0.2.30)</span><br></pre></td></tr></table></figure></div>

<p>Using this command we also get similar information as from <code>last</code> command. Now you get the user details used for connecting to node3 from source host, also we have terminal information on which the session is still active.</p>
<h3 id="Using-w-command"><a href="#Using-w-command" class="headerlink" title="Using w command"></a>Using <code>w</code> command</h3><p><code>w</code> displays information about the users currently on the machine, and their processes. This gives more information than who and last command and also serves our purpose to get the list of active SSH connections. Additionally it also gives us the information of the running process on those sessions.</p>
<p>Using <code>w</code> command you will also get the idle time details, i.e. for how long the session is idle. If the SSH session is idle for long period then it is a security breach and it is recommended that such idle SSH session must be killed, you can configure your Linux host to automatically kill such idle SSH session.</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node3 ~]# w</span><br><span class="line"> 17:01:41 up  7:44,  3 users,  load average: 0.00, 0.01, 0.05</span><br><span class="line">USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT</span><br><span class="line">root     pts/0    10.0.2.2         09:17    9:41   0.31s  0.00s less -s</span><br><span class="line">deepak   pts/1    10.0.2.31        16:58    3:06   0.03s  0.03s -bash</span><br><span class="line">root     pts/2    10.0.2.30        16:50    5.00s  0.07s  0.02s w</span><br></pre></td></tr></table></figure></div>

<h3 id="Using-netstat-command"><a href="#Using-netstat-command" class="headerlink" title="Using netstat command"></a>Using <code>netstat</code> command</h3><p>Similar to <code>ss</code> we have <code>netstat</code> command to show active ssh sessions. Actually we can also say that ss is the new version of netstat. Here we can see all the ESTABLISHED SSH sessions from remote hosts to our localhost node3. it is also possible that one or some of these active ssh connections are in hung state so you can configure your host to automatically disconnect or kill these hung or unresponsive ssh sessions in Linux.</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node3 ~]# netstat -tnpa | grep &#x27;ESTABLISHED.*sshd&#x27;</span><br><span class="line">tcp   0   0  10.0.2.32:22   10.0.2.31:37806  ESTABLISHED 10295/sshd: deepak</span><br><span class="line">tcp   0   0  10.0.2.32:22   10.0.2.2:49966   ESTABLISHED 4329/sshd: root@pts</span><br><span class="line">tcp   0   0  10.0.2.32:22   10.0.2.30:56088  ESTABLISHED 10125/sshd: root@pt</span><br></pre></td></tr></table></figure></div>

<h3 id="Using-ps-command"><a href="#Using-ps-command" class="headerlink" title="Using ps command"></a>Using <code>ps</code> command</h3><p>Now to show active ssh sessions, <code>ps</code> command may not give you accurate results like other commands we discussed in this article but it can give you some more additional information i.e. <code>PID</code> of the <code>SSHD</code> process which are currently active and connected.</p>
<h2 id="查看-SSH-连接历史记录"><a href="#查看-SSH-连接历史记录" class="headerlink" title="查看 SSH 连接历史记录"></a>查看 SSH 连接历史记录</h2><p>To get the ssh connection history you can always check your SSHD logs for more information on connected or disconnected SSH session. Now the sshd log file may vary from distribution to distribution. On my RHEL 7.4 my sshd logs are stored inside <code>/var/log/sshd</code>.</p>
<p>Lastly I hope the steps from the article to check active SSH connections and ssh connection history in Linux was helpful. So, let me know your suggestions and feedback using the comment section.</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux之间实现SSH免密登录</title>
    <url>/2021/08/07/Linux%E4%B9%8B%E9%97%B4%E5%AE%9E%E7%8E%B0SSH%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<p>为了让两个 Linux 机器之间使用 ssh 不需要用户名和密码。</p>
<span id="more"></span>

<h2 id="本地生成公钥私钥对"><a href="#本地生成公钥私钥对" class="headerlink" title="本地生成公钥私钥对"></a>本地生成公钥私钥对</h2><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注：ED25519 算法的安全性和性能优于 RSA，DSA已经被淘汰。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过 ED25519 算法生成</span></span><br><span class="line">ssh-keygen -t ed25519 -C &quot;&lt;comment&gt;&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过 RSA 算法生成</span></span><br><span class="line">ssh-keygen -t rsa -b 4096 -C &quot;&lt;comment&gt;&quot;</span><br></pre></td></tr></table></figure></div>

<h2 id="复制本机的公钥到远程服务器中"><a href="#复制本机的公钥到远程服务器中" class="headerlink" title="复制本机的公钥到远程服务器中"></a>复制本机的公钥到远程服务器中</h2><p><code>ssh-copy-id</code> 命令可以把本地的 ssh 公钥文件安装到远程主机对应的账户下，会将本地主机的公钥追加到远程主机的 <code>authorized_keys</code> 文件中，也会给远程主机的用户主目录（home）和 ~&#x2F;.ssh，和 ~&#x2F;.ssh&#x2F;authorized_keys 设置合适的权限。</p>
<p>使用方法：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-copy-id [-f] [-n] [-i identity file] [-p port] [-o ssh_option] [user@]hostname</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><strong>-f</strong> Don’t check if the key is already configured as an authorized key on the server. Just add it. This can result in multiple copies of the key in authorized_keys files.</p>
<p><strong>-i</strong> Specifies the identity file that is to be copied (default is ~&#x2F;.ssh&#x2F;id_rsa). If this option is not provided, this adds all keys listed by ssh-add -L. Note: it can be multiple keys and adding extra authorized keys can easily happen accidentally! If ssh-add -L returns no keys, then the most recently modified key matching ~&#x2F;.ssh&#x2F;id*.pub, excluding those matching ~&#x2F;.ssh&#x2F;*-cert.pub, will be used.</p>
<p><strong>-n</strong> Just print the key(s) that would be installed, without actually installing them.</p>
<p><strong>-o</strong> ssh_option Pass -o ssh_option to the SSH client when making the connection. This can be used for overriding configuration settings for the client. See ssh command line options and the possible configuration options in ssh_config.</p>
<p><strong>-p</strong> port Connect to the specifed SSH port on the server, instead of the default port 22.</p>
<p><strong>-h</strong> or <strong>-?</strong> Print usage summary.</p>
</blockquote>
<h2 id="实现免密登录"><a href="#实现免密登录" class="headerlink" title="实现免密登录"></a>实现免密登录</h2><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-copy-id [user@]hostname</span><br><span class="line">ssh-copy-id -i ~/.ssh/id_ed25519.pub [user@]hostname</span><br></pre></td></tr></table></figure></div>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a class="link"   href="https://www.ssh.com/academy/ssh/copy-id#setting-up-public-key-authentication" >ssh-copy-id for copying SSH keys to servers <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux权限说明</title>
    <url>/2023/03/14/Linux%E6%9D%83%E9%99%90%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/123412341.png"
                     
                ></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MVC、MVP、MVVM架构模式的区别和联系</title>
    <url>/2021/08/17/MVC%E3%80%81MVP%E3%80%81MVVM%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB/</url>
    <content><![CDATA[<blockquote>
<p>我们都知道，复杂的软件必须有清晰合理的架构，否则无法开发和维护。</p>
</blockquote>
<p>MVC、MVP、MVVM这些模式是为了解决开发过程中的实际问题而提出来的，目前作为主流的几种架构模式而被广泛使用。</p>
<span id="more"></span>

<p>MVC（Model-View-Controller）是最常见的软件架构之一，业界有着广泛应用。它本身很容易理解，但是要讲清楚，它与衍生的 MVP 和 MVVM 架构的区别就不容易了。</p>
<p>接下来，我们就来详细解释一下这三种架构的区别。</p>
<h3 id="MVC（Model-View-Controller）"><a href="#MVC（Model-View-Controller）" class="headerlink" title="MVC（Model-View-Controller）"></a>MVC（Model-View-Controller）</h3><p>MVC即Model-VIew-Controller。他是1970年代被引入到软件设计大众的。MVC模式致力于关注点的切分，这意味着model和controller的逻辑是不与用户界面（View）挂钩的。因此，维护和测试程序变得更加简单容易。</p>
<p>MVC是比较直观的架构模式:<br>用户操作-&gt;View（负责接收用户的输入操作）-&gt;Controller（业务逻辑处理）-&gt;Model（数据持久化）-&gt;View（将结果反馈给View）。</p>
<p>MVC使用非常广泛。比如JavaEE中的SSH框架（Struts&#x2F;Spring&#x2F;Hibernate），Struts（View, STL）-Spring（Controller, Ioc、Spring MVC）-Hibernate（Model, ORM）以及ASP.NET中的ASP.NET MVC框架，xxx.cshtml-xxxcontroller-xxxmodel。（实际上后端开发过程中是v-c-m-c-v，v和m并没有关系，下图仅代表经典的mvc模型）。</p>
<p>MVC模式的意思是，软件可以分成三个部分。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/123123.png"
                     
                ></p>
<p><strong>视图（View）</strong>：用户界面。<br><strong>控制器（Controller）</strong>：业务逻辑<br><strong>模型（Model）</strong>：数据保存</p>
<p>各部分之间的通信方式如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/123124.png"
                     
                ></p>
<ol>
<li>View 传送指令到 Controller。</li>
<li>Controller 完成业务逻辑后，要求 Model 改变状态。</li>
<li>Model 将新的数据发送到 View，用户得到反馈。</li>
</ol>
<p><strong>注意</strong>: 所有通信都是单向的。</p>
<h3 id="MVP（Model-View-Presenter）"><a href="#MVP（Model-View-Presenter）" class="headerlink" title="MVP（Model-View-Presenter）"></a>MVP（Model-View-Presenter）</h3><p>MVP是把MVC中的Controller换成了Presenter（呈现），目的就是为了完全切断View跟Model之间的联系，由Presenter充当桥梁，做到View-Model之间通信的完全隔离。</p>
<p>NET程序员熟知的ASP.NET webform、winform基于事件驱动的开发技术就是使用的MVP模式。控件组成的页面充当View，实体数据库操作充当Model，而View和Model之间的控件数据绑定操作则属于Presenter。控件事件的处理可以通过自定义的IView接口实现，而View和IView都将对Presenter负责。</p>
<p>MVP 模式将 Controller 改名为 Presenter，同时改变了通信方向。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/123125.png"
                     
                ></p>
<ol>
<li>各部分之间的通信，都是双向的。</li>
<li>View 与 Model 不发生联系，都通过 Presenter 传递。</li>
<li>View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。</li>
</ol>
<h3 id="MVVM（Model-View-ViewModel）"><a href="#MVVM（Model-View-ViewModel）" class="headerlink" title="MVVM（Model-View-ViewModel）"></a>MVVM（Model-View-ViewModel）</h3><p>如果说MVP是对MVC的进一步改进，那么MVVM则是思想的完全变革。</p>
<p>它是将“数据模型数据双向绑定”的思想作为核心，因此在View和Model之间没有联系，通过ViewModel进行交互，而且Model和ViewModel之间的交互是双向的，因此视图的数据的变化会同时修改数据源，而数据源数据的变化也会立即反应到View上。</p>
<p>这方面典型的应用有.NET的WPF，js框架Knockout、AngularJS等。</p>
<p>MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/123126.png"
                     
                ></p>
<p>唯一的区别是，它采用双向绑定（data-binding）：<br>View的变动，自动反映在 ViewModel，反之亦然。Angular 和 Ember 都采用这种模式。</p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>RDIMM或LRDIMM适合你的设计吗？</title>
    <url>/2019/07/17/RDIMM%E6%88%96LRDIMM%E9%80%82%E5%90%88%E4%BD%A0%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[<p>DDR5 DIMM缓冲芯片正为下一代服务器&#x2F;系统设计整装待发。你可以选择RDIMM或LRDIMM，但练达的设计师知道要同时保有这两者。</p>
 <span id="more"></span>

<blockquote>
<p>下一代DDR5缓冲芯片呼之欲出，服务器和系统设计人员将很快将DDR5服务器双列直插存储器模块（DIMM）缓冲芯片组纳入其新设计中。但服务器&#x2F;系统设计师可能在思考的问题是：在带寄存器的DIMM（RDIMM）或减负（load-reduced）DIMM（LRDIMM）间如何取舍？了解RDIMM和LRDIMM之间基本差异非常重要，因为这些差异如何有助于指导你正确使用DIMM进行设计。某些规范对于帮助你确定要使用的DIMM也至关重要。最后，了解一些关键设计注意事项是有帮助的，它们可作为选择正确DIMM类型的基础。</p>
</blockquote>
<p>下一代DDR5缓冲芯片呼之欲出，服务器和系统设计人员将很快将DDR5服务器双列直插存储器模块（DIMM）缓冲芯片组纳入他们的新设计中。但服务器&#x2F;系统设计师可能在思考的问题是：在带寄存器的DIMM（RDIMM）或减少负载的（load-reduced）DIMM（LRDIMM）间如何取舍？</p>
<p>简要的回答是：如果你致力高速和低延迟，那么RDIMM通常适合你。另一方面，当你的设计需要更高的内存密度时，LRDIMM是不二之选。但要使设计高效、没有短板，还有很多事情需要考虑。</p>
<p>服务器&#x2F;系统设计达人明白：通盘考虑两者是明智之举。为什么？因为你的系统内存容量可能会随时间而变化。最初，你的系统可能没有满载，因此你可以从RDIMM开始，在相对轻载的条件下达到最高速度。但以后，你可能希望增加服务器的内存容量，因此可以使用LRDIMM以提供更大容量。</p>
<p>这就是为何了解RDIMM和LRDIMM之间基本差异非常重要，并了解这些差异如何有助于指导你正确使用DIMM进行设计。某些规范对于帮助你确定要使用的DIMM也至关重要。最后，了解一些关键设计注意事项是有帮助的，它们可作为选择正确DIMM类型的基础。</p>
<h2 id="RDIMM或LRDIMM——选哪种？"><a href="#RDIMM或LRDIMM——选哪种？" class="headerlink" title="RDIMM或LRDIMM——选哪种？"></a>RDIMM或LRDIMM——选哪种？</h2><p>如下图所示，RDIMM上有一个带寄存器的时钟驱动器（RCD）。 RCD从主机存储器控制器获取命令地址总线、控制信号和时钟信号，然后将这些信号流扇出到DIMM上的DRAM。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/3245134.png"
                     
                ></p>
<p>DQ信号数据总线和DQ选通（DQS）直接从存储器控制器传送到DRAM封装。在RCD上缓冲的唯一操作是命令&#x2F;地址总线、控制信号和DIMM的输入时钟。所有这些都在通过RCD后都会进入RDIMM上的所有DRAM，并重新计时和清理。</p>
<p>与早期的无缓冲DIMM（UDIMM）设计相比，采用RDIMM的设计可跑得更快。与UDIMM相比，将RCD放在RDIMM中可以帮助你加大负载，因为它可以缓冲时钟信号和命令&#x2F;地址线。在RDIMM中，时钟信号和命令&#x2F;地址线需要额外的驱动强度，因为它们会进入DIMM上的所有DRAM封装。相比之下，DQ和DQS信号不需要额外的驱动强度，因为它们直接从存储器控制器进入单个DRAM封装或多列DRAM封装。</p>
<p>此外，就RDIMM来说，了解从存储器控制器到DIMM的RCD的命令&#x2F;地址总线和输入时钟是单向的很重要。相比之下，DQ总线和DQS在存储器控制器和RDIMM上的DRAM之间则是双向的。</p>
<p>接着看LRDIMM，如下图所示，它上面也有一个RCD，并使用多个数据缓冲区（DB）来缓冲主机内存控制器和DRAM之间的进入DQ和DQS信号。DDR5 LRDIMM有10个DBs，每个DB只处理8位数据总线。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/324234.jpeg"
                     
                ></p>
<p>对于DDR5，数据总线预计是两个32位通道加上一个8位纠错码（ECC）字节。因此，每个通道上有40位，LRDIMM的每一侧需要5个DBs。</p>
<p>DB和DRAM之间的信号称为MDQ和MDQS，以区别主机端的DQ和DQS信号。这里，主机和DRAM间数据缓冲区的好处是：如果LRDIMM上有多列DRAM，你还降低了数据总线上的负载。</p>
<p>此外，数据缓冲区获得8个数据位，但每半个字节有4个DQ位。对于四个位中的每一个，都有一个DQS选通位，它是差分的，而DQ位是单端的。主机存储器控制器可通过带内（in-band）命令&#x2F;地址总线或通过串行管理总线对RCD进行配置。主机内存控制器不直接配置数据缓冲区，而是由RCD通过缓冲通信总线（BCOM）配置。</p>
<h2 id="驾驭规范"><a href="#驾驭规范" class="headerlink" title="驾驭规范"></a>驾驭规范</h2><p>在规划DDR5设计时，DIMM规格将发挥重要作用。它们很重要，因为它们是量测缓冲芯片、时钟和&#x2F;或缓冲数据信号质量的标准。你希望能够确保DRAM的输入在经过RCD或DB缓冲后没太多变化。</p>
<p>你还希望确认系统存储器通道时序的预算得以保证。另外，你想知道DB或RCD不会占用从内存控制器到DIMM并返回内存控制器这一往返延迟的太大部分。</p>
<p>就规格本身而言，RDIMM和LRDIMM的一些高阶规格是相似的。例如，速率以存储器通道上的每秒兆次传输（MT&#x2F;s）来度量。对于DDR5，速率从3,200 MT&#x2F;s开始、最高可达6,400 MT &#x2F;s，可能更高。</p>
<p>此外，与DDR4一样，DIMM的内存容量以千兆字节为单位，例如8 GB，16 GB或32 GB。了解功耗也很重要。采用非常结构化的方式测量功耗，具有标准定义的工作和休眠功耗模式。对于数据缓冲区，它区分工作状态下的读、写功耗。</p>
<p>RDIMM上RCD的关键规范与时钟计时有关，因为RCD的主要功能是重新缓冲时钟并将其发送到DRAM。在这里，你需要了解从DIMM输入时钟到RCD输出命令&#x2F;地址（CA）信号的传播延迟。该规范称为tPDM，包括发出信号的时间，而不仅仅是时钟延迟。</p>
<p>静态偏移（或tSTAOFF）是另一种传播延迟测量，它指的是通过RCD、从输入到输出时钟的时钟延迟。因为这是个缓冲时钟，所以你还需知道输出到DRAM的时钟的抖动量。</p>
<p>动态偏移（或tDYNOFF）是传播延迟的最大变化，是衡量时钟一致性的指标。这对DRAM时序很重要。 tQSK是另一种RCD测量，它是从QCA输出到时钟的偏差（skew）。</p>
<p>对于LRDIMM，以下是数据缓冲区的关键规范。一些重要的测量和规范还与偏差有关；但它们是从DQS或选通到DQ数据（称为tDQSQ）、或每半个字节的引脚之间DQS到DQ的偏差。</p>
<p>你还需要测量数据有效窗口（或tDVWp）。这决定了数据有效窗口可能的宽度，以便数据缓冲区有效处理。对于写入输入，有tDVA和tDVB规范，分别表示：数据有效前；数据有效后。它们告诉你可用于设置和保持数据缓冲区输出到DRAM的时间。</p>
<p>tPDM Read和tPDM Write是通过数据缓冲区的传播延迟的度量。这是针对DQ路径的，因为它是双向的，所以它们在每个方向上都是单独测量的。从主机存储器控制器的角度看：tPDM Read是从DRAM到主机的度量；tPDM Write是从主机到DRAM的度量。</p>
<p>接收器灵敏度是需要了解的LRDIMM数据缓冲区的另一个规范。对于DDR5，信号运行的速度比以前DDR信号要快得多。因此，你需要获得良好的测量结果，包括Vih&#x2F;Vil（电压输入高电平和低电平）。</p>
<h2 id="设计注意事项"><a href="#设计注意事项" class="headerlink" title="设计注意事项"></a>设计注意事项</h2><p>在RDIMM或LRDIMM之间进行选择时，DDR5 MT&#x2F;s的目标速率是主要考量之一。与LRDIMM相比，RDIMM更便宜、功耗更低。如果系统内存容量不是关键要素，它们还可以实现最高速度。</p>
<p>LRDIMM提供更高的DRAM内存容量。因为数据位在数据缓冲区内缓冲，它们或许能支持更多的封装列。如果你需要最大化服务器中每个CPU的可用内存，LRDIMM实际上是容量大咖。当然要有代价，因为你要向LRDIMM添加10个数据缓冲区。 DIMM设计稍微复杂些。因此，与RDIMM相比，LRDIMM的成本更高，且由于额外的数据缓冲器其功耗也稍高。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如前所述，RDIMM和LRDIMM都是下一代DDR5设计的可行选择。到底选哪种，取决于你的初始设计目标。如果需要性能更强的服务器设计，随着新的速度和容量需求增加，选用DDR 5 LRDIMM，则系统仍可胜任。</p>
]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>String、StringBuffer、StringBuilder区别</title>
    <url>/2018/10/28/String,StringBuffer,StringBuilder%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h3 id="可变性"><a href="#可变性" class="headerlink" title="可变性"></a>可变性</h3><p>String类中使用字符数组保存字符串，private　final　char　value[]，所以string对象是不可变的。StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，char[]value，这两种对象都是可变的。</p>
<span id="more"></span>

<h3 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h3><p>String中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>每次对String类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String 对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。 对于三者使用的总结： 如果要操作少量的数据用 &#x3D; String 单线程操作字符串缓冲区 下操作大量数据 &#x3D; StringBuilder 多线程操作字符串缓冲区 下操作大量数据 &#x3D; StringBuffer</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu UFW 防火墙设置</title>
    <url>/2019/04/17/Ubuntu%20UFW%20%E9%98%B2%E7%81%AB%E5%A2%99%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Ubuntu 默认是有 <code>ufw</code> 的。如果因为种种原因没有的话：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ufw</span><br></pre></td></tr></table></figure></div>
 <span id="more"></span>

<h3 id="初步配置"><a href="#初步配置" class="headerlink" title="初步配置"></a>初步配置</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/default/ufw</span><br></pre></td></tr></table></figure></div>

<h4 id="开启-ipv6-optional"><a href="#开启-ipv6-optional" class="headerlink" title="开启 ipv6 (optional)"></a>开启 ipv6 (optional)</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">IPV6=yes</span><br></pre></td></tr></table></figure></div>

<h4 id="设置默认规则"><a href="#设置默认规则" class="headerlink" title="设置默认规则"></a>设置默认规则</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ufw default deny incoming</span><br><span class="line">sudo ufw default allow outgoing</span><br></pre></td></tr></table></figure></div>

<h3 id="设置-incoming-规则"><a href="#设置-incoming-规则" class="headerlink" title="设置 incoming 规则"></a>设置 incoming 规则</h3><h3 id="允许-ssh"><a href="#允许-ssh" class="headerlink" title="允许 ssh"></a>允许 ssh</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ufw allow 22/tcp</span><br></pre></td></tr></table></figure></div>

<h4 id="允许-http、https"><a href="#允许-http、https" class="headerlink" title="允许 http、https"></a>允许 http、https</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ufw allow 80</span><br><span class="line">sudo ufw allow 443</span><br></pre></td></tr></table></figure></div>

<h4 id="允许端口段"><a href="#允许端口段" class="headerlink" title="允许端口段"></a>允许端口段</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ufw allow 1000:2000/tcp</span><br></pre></td></tr></table></figure></div>

<h4 id="允许-ip"><a href="#允许-ip" class="headerlink" title="允许 ip"></a>允许 ip</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ufw allow from 192.168.1.125</span><br></pre></td></tr></table></figure></div>

<h4 id="设置允许-ip-x2F-subnet-访问特定端口"><a href="#设置允许-ip-x2F-subnet-访问特定端口" class="headerlink" title="设置允许 ip &#x2F; subnet 访问特定端口"></a>设置允许 ip &#x2F; subnet 访问特定端口</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ufw allow from 192.168.100.0/24 to any port 3306</span><br></pre></td></tr></table></figure></div>

<h4 id="设置禁止规则"><a href="#设置禁止规则" class="headerlink" title="设置禁止规则"></a>设置禁止规则</h4><p>修改 <code>allow</code> 为 <code>deny</code> 即可。</p>
<h3 id="开启-UFW"><a href="#开启-UFW" class="headerlink" title="开启 UFW"></a>开启 UFW</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ufw enable</span><br></pre></td></tr></table></figure></div>

<h3 id="查看-UFW-状态"><a href="#查看-UFW-状态" class="headerlink" title="查看 UFW 状态"></a>查看 UFW 状态</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ufw status [verbose|numbered]</span><br></pre></td></tr></table></figure></div>

<h3 id="删除规则"><a href="#删除规则" class="headerlink" title="删除规则"></a>删除规则</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ufw delete allow 1000:2000/tcp</span><br></pre></td></tr></table></figure></div>

<p>或</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ufw status numbered</span><br><span class="line">sudo ufw delete [number]</span><br></pre></td></tr></table></figure></div>

<p><code>[number]</code> 为上一条返回的规则号码</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="关闭-UFW"><a href="#关闭-UFW" class="headerlink" title="关闭 UFW"></a>关闭 UFW</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ufw disable</span><br></pre></td></tr></table></figure></div>

<h4 id="重设-UFW"><a href="#重设-UFW" class="headerlink" title="重设 UFW"></a>重设 UFW</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ufw reset</span><br></pre></td></tr></table></figure></div>

<h4 id="开启关闭-Logging"><a href="#开启关闭-Logging" class="headerlink" title="开启关闭 Logging"></a>开启关闭 Logging</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ufw logging [on|off]</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu常用设置</title>
    <url>/2018/06/16/Ubuntu%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<p>Ubuntu 18.10 安装之后需要做的 事，下面会列出系统安装之后需要做的一些事，这将使得 Ubuntu 的体验更加出色。</p>
<span id="more"></span>

<h3 id="安装更新"><a href="#安装更新" class="headerlink" title="安装更新"></a>安装更新</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure></div>

<h3 id="启用「点击Ubuntu-Dock最小化」"><a href="#启用「点击Ubuntu-Dock最小化」" class="headerlink" title="启用「点击Ubuntu Dock最小化」"></a>启用「点击Ubuntu Dock最小化」</h3><p>在 Ubuntu 18.10 中点击应用程序「最小化」按钮可以隐藏到 Ubuntu Dock 栏图标，再点击 Ubuntu Dock 栏中的图标时可以还原界面。但在默认情况下，点击 Ubuntu Dock 图标却无法将应用程序界面最小化。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">gsettings set org.gnome.shell.extensions.dash-to-dock click-action &#x27;minimize&#x27;</span><br></pre></td></tr></table></figure></div>

<h3 id="显示电池百分比"><a href="#显示电池百分比" class="headerlink" title="显示电池百分比"></a>显示电池百分比</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">gsettings set org.gnome.desktop.interface show-battery-percentage true</span><br></pre></td></tr></table></figure></div>

<h3 id="用TLP降低发热"><a href="#用TLP降低发热" class="headerlink" title="用TLP降低发热"></a>用TLP降低发热</h3><p>TLP 是一个有助于「系统冷却」的应用程序，可以让 Ubuntu 运行得更快、更顺畅。安装完成后，运行命令启动它即可，而无需任何配置。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:linrunner/tlp</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install tlp tlp-rdw</span><br><span class="line">sudo tlp start</span><br></pre></td></tr></table></figure></div>

<h3 id="设置软件更新镜像"><a href="#设置软件更新镜像" class="headerlink" title="设置软件更新镜像"></a>设置软件更新镜像</h3><p>Ubuntu 的软件源配置文件是 &#x2F;etc&#x2F;apt&#x2F;sources.list，确保 Ubuntu 从最佳服务器获取更新，建议使用<a class="link"   href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/" >清华大学开源镜像站的软件源镜像 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>Ubuntu 18.10</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ cosmic main restricted universe multiverse</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ cosmic main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ cosmic-updates main restricted universe multiverse</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ cosmic-updates main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ cosmic-backports main restricted universe multiverse</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ cosmic-backports main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ cosmic-security main restricted universe multiverse</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ cosmic-security main restricted universe multiverse</span></span><br></pre></td></tr></table></figure></div>

<h3 id="使用apt-fast取代apt-get"><a href="#使用apt-fast取代apt-get" class="headerlink" title="使用apt-fast取代apt-get"></a>使用apt-fast取代apt-get</h3><p>如果您希望下载速度更快，可以安装apt-fast并在使用apt-get命令的地方用apt-fast来替换。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:apt-fast/stable</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install apt-fast</span><br></pre></td></tr></table></figure></div>

<h3 id="清理Ubuntu"><a href="#清理Ubuntu" class="headerlink" title="清理Ubuntu"></a>清理Ubuntu</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt clean #只删除过时的软件包</span><br><span class="line">sudo apt autoremove #清理整个缓存</span><br></pre></td></tr></table></figure></div>

<h3 id="安装Nvidia显卡驱动"><a href="#安装Nvidia显卡驱动" class="headerlink" title="安装Nvidia显卡驱动"></a>安装Nvidia显卡驱动</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:graphics-drivers/ppa</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-fast install nvidia-390 nvidia-settings nvidia-prime</span><br></pre></td></tr></table></figure></div>

<p>安装完成后需要重启。</p>
<h3 id="安装Preload"><a href="#安装Preload" class="headerlink" title="安装Preload"></a>安装Preload</h3><p>Preload（预加载）会在后台工作，以「研究」您如何使用计算机并增强计算机的应用程序处理能力。安装好 Preload 后，您使用频率最高的应用程序的加载速度就会明显快于不经常使用的应用程序。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install preload</span><br></pre></td></tr></table></figure></div>

<h3 id="清理缩略图缓存"><a href="#清理缩略图缓存" class="headerlink" title="清理缩略图缓存"></a>清理缩略图缓存</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">du -sh ~/.cache/thumbnails</span><br></pre></td></tr></table></figure></div>

<h3 id="卸载不必要的应用程序"><a href="#卸载不必要的应用程序" class="headerlink" title="卸载不必要的应用程序"></a>卸载不必要的应用程序</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt remove 软件包名</span><br></pre></td></tr></table></figure></div>

<h3 id="获取WiFi无线密码"><a href="#获取WiFi无线密码" class="headerlink" title="获取WiFi无线密码"></a>获取WiFi无线密码</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">cd /etc/NetworkManager/system-connections  #此目录中存储了网络连接详细信息的配置文件，可以使用ls命令列出所有 WiFi 连接配置文件。</span><br></pre></td></tr></table></figure></div>

<p>使用 cat 命令查看 Linux 中已保存的 WiFi 配置文件，在 WiFi-Security 段的 psk 位置可以查看到无线密码。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu系统出现无法连接adb问题的解决方案</title>
    <url>/2019/04/12/Ubuntu%E7%B3%BB%E7%BB%9F%E5%87%BA%E7%8E%B0%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5adb%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>如果以下情况：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">adb devices</span></span><br><span class="line">List of devices attached</span><br><span class="line">xxxxxxxx    no permissions (user in plugdev group; are your udev rules wrong?);</span><br><span class="line">see [http://developer.android.com/tools/device.html]</span><br></pre></td></tr></table></figure></div>

<span id="more"></span>

<p>检查设备的ID和产品ID：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">lsusb</span></span><br><span class="line">Bus 001 Device 002: ID 8087:8000 Intel Corp. </span><br><span class="line">Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub</span><br><span class="line">Bus 003 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub</span><br><span class="line">Bus 002 Device 078: ID 138a:0011 Validity Sensors, Inc. VFS5011 Fingerprint Reader</span><br><span class="line">Bus 002 Device 003: ID 8087:07dc Intel Corp. </span><br><span class="line">Bus 002 Device 002: ID 5986:0652 Acer, Inc </span><br><span class="line">Bus 002 Device 081: ID 22b8:2e81 Motorola PCS  #示例设备</span><br><span class="line">Bus 002 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub</span><br></pre></td></tr></table></figure></div>

<p>在这里，示例设备为 Motorola PCS ，所以我的 <code>vid=22b8</code>  和 <code>pid=2e81</code></p>
<p>在路径  <code>/etc/udev/rules.d</code> 下，新建 <code>51-android.rules</code></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo vi /etc/udev/rules.d/51-android.rules</span><br><span class="line">SUBSYSTEM==&quot;usb&quot;, ATTR&#123;idVendor&#125;==&quot;22b8&quot;, ATTR&#123;idProduct&#125;==&quot;2e81&quot;, MODE=&quot;0666&quot;, GROUP=&quot;plugdev&quot;</span><br></pre></td></tr></table></figure></div>

<p>现在重启 <code>udev</code> 规则</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo udevadm control --reload-rules</span><br></pre></td></tr></table></figure></div>

<p>现在，设备可以被识别了：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">adb devices</span></span><br><span class="line">List of devices attached</span><br><span class="line">ZF6222Q9D9  device</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>如果依然无法识别：<br>1、重新拔插手机设备；<br>2、重启系统。</p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu网络配置</title>
    <url>/2019/03/15/Ubuntu%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="以太网接口"><a href="#以太网接口" class="headerlink" title="以太网接口"></a>以太网接口</h2><h3 id="识别以太网接口的两种方法："><a href="#识别以太网接口的两种方法：" class="headerlink" title="识别以太网接口的两种方法："></a>识别以太网接口的两种方法：</h3> <span id="more"></span>

<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">justme@justserver:$ ifconfig -a</span><br><span class="line">eno1np0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.1.125  netmask 255.255.255.0  broadcast 192.168.1.255</span><br><span class="line">        inet6 fe80::4ed9:8fff:fe2c:cb98  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 4c:d9:8f:2c:cb:98  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 24440107  bytes 35187073438 (35.1 GB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 11198489  bytes 800420673 (800.4 MB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">eno2np1: flags=4098&lt;BROADCAST,MULTICAST&gt;  mtu 1500</span><br><span class="line">        ether 4c:d9:8f:2c:cb:99  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 7094  bytes 793776 (793.7 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 7094  bytes 793776 (793.7 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">justme@justserver:~/AndroidSource/lineage_17.0$ sudo lshw -class network</span><br><span class="line">[sudo] password for justme:</span><br><span class="line">  *-network:0</span><br><span class="line">       description: Ethernet interface</span><br><span class="line">       product: BCM57416 NetXtreme-E Dual-Media 10G RDMA Ethernet Controller</span><br><span class="line">       vendor: Broadcom Inc. and subsidiaries</span><br><span class="line">       physical id: 0</span><br><span class="line">       bus info: pci@0000:18:00.0</span><br><span class="line">       logical name: eno1np0</span><br><span class="line">       version: 01</span><br><span class="line">       serial: 4c:d9:8f:2c:cb:98</span><br><span class="line">       size: 1Gbit/s</span><br><span class="line">       capacity: 10Gbit/s</span><br><span class="line">       width: 64 bits</span><br><span class="line">       clock: 33MHz</span><br><span class="line">       capabilities: pm vpd msi msix pciexpress bus_master cap_list rom ethernet physical tp 1000bt-fd 10000bt-fd autonegotiation</span><br><span class="line">       configuration: autonegotiation=on broadcast=yes driver=bnxt_en driverversion=1.10.0 duplex=full firmware=214.0.222.1/pkg 21.40.22.21 ip=192.168.1.125 latency=0 link=yes multicast=yes port=twisted pair speed=1Gbit/s</span><br><span class="line">       resources: irq:72 memory:9da10000-9da1ffff memory:9d900000-9d9fffff memory:9da22000-9da23fff memory:9de00000-9de7ffff</span><br><span class="line">  *-network:1 DISABLED</span><br><span class="line">       description: Ethernet interface</span><br><span class="line">       product: BCM57416 NetXtreme-E Dual-Media 10G RDMA Ethernet Controller</span><br><span class="line">       vendor: Broadcom Inc. and subsidiaries</span><br><span class="line">       physical id: 0.1</span><br><span class="line">       bus info: pci@0000:18:00.1</span><br><span class="line">       logical name: eno2np1</span><br><span class="line">       version: 01</span><br><span class="line">       serial: 4c:d9:8f:2c:cb:99</span><br><span class="line">       capacity: 10Gbit/s</span><br><span class="line">       width: 64 bits</span><br><span class="line">       clock: 33MHz</span><br><span class="line">       capabilities: pm vpd msi msix pciexpress bus_master cap_list rom ethernet physical tp 1000bt-fd 10000bt-fd autonegotiation</span><br><span class="line">       configuration: autonegotiation=on broadcast=yes driver=bnxt_en driverversion=1.10.0 duplex=half firmware=214.0.222.1/pkg 21.40.22.21 latency=0 link=no multicast=yes port=twisted pair</span><br><span class="line">       resources: irq:81 memory:9da00000-9da0ffff memory:9d800000-9d8fffff memory:9da20000-9da21fff memory:9de80000-9defffff</span><br></pre></td></tr></table></figure></div>

<h3 id="以太网接口逻辑名称"><a href="#以太网接口逻辑名称" class="headerlink" title="以太网接口逻辑名称"></a>以太网接口逻辑名称</h3><p>接口逻辑名称也可以通过 <code>netplan</code> 配置进行配置。如果要控制哪个接口收到特定的逻辑名称，请使用 <code>match</code> 和 <code>set-name</code> 键。<code>match</code> 键用于根据某些条件（例如MAC地址，驱动程序等）查找适配器。然后，<code>set-name</code> 键可用于将设备更改为所需的逻辑名称。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">network:</span><br><span class="line">  version: 2</span><br><span class="line">  renderer: networkd</span><br><span class="line">  ethernets:</span><br><span class="line">    eth_lan0:</span><br><span class="line">      dhcp4: true</span><br><span class="line">	  match:</span><br><span class="line">	    macaddress: 00:11:22:33:44:55</span><br><span class="line">	  set-name: eth_lan0</span><br></pre></td></tr></table></figure></div>

<h3 id="以太网接口设置"><a href="#以太网接口设置" class="headerlink" title="以太网接口设置"></a>以太网接口设置</h3><p>ethtool 是一个程序，用于显示和更改以太网卡设置，例如自动协商，端口速度，双工模式和局域网唤醒。以下是如何查看以太网接口的受支持功能和配置设置：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ethtool eth4</span><br><span class="line">Settings for eth4:</span><br><span class="line">	Supported ports: [ FIBRE ]</span><br><span class="line">	Supported link modes:   10000baseT/Full</span><br><span class="line">	Supported pause frame use: No</span><br><span class="line">	Supports auto-negotiation: No</span><br><span class="line">	Supported FEC modes: Not reported</span><br><span class="line">	Advertised link modes:  10000baseT/Full</span><br><span class="line">	Advertised pause frame use: No</span><br><span class="line">	Advertised auto-negotiation: No</span><br><span class="line">	Advertised FEC modes: Not reported</span><br><span class="line">	Speed: 10000Mb/s</span><br><span class="line">	Duplex: Full</span><br><span class="line">	Port: FIBRE</span><br><span class="line">	PHYAD: 0</span><br><span class="line">	Transceiver: internal</span><br><span class="line">	Auto-negotiation: off</span><br><span class="line">	Supports Wake-on: d</span><br><span class="line">	Wake-on: d</span><br><span class="line">	Current message level: 0x00000014 (20)</span><br><span class="line">			               link ifdown</span><br><span class="line">	Link detected: yes</span><br></pre></td></tr></table></figure></div>

<h2 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h2><h3 id="临时IP地址分配"><a href="#临时IP地址分配" class="headerlink" title="临时IP地址分配"></a>临时IP地址分配</h3><p>对于临时网络配置，可以使用 <code>ip</code> 命令，该命令在大多数其他 GNU &#x2F; Linux 操作系统上也可以找到。 ip 命令使您可以配置立即生效的设置，但是这些设置不是永久性的，并且在重启后将丢失。</p>
<p>要临时配置 IP 地址，可以按以下方式使用 <code>ip</code> 命令。修改 IP 地址和子网掩码以符合您的网络要求。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ip addr add 10.102.66.200/24 dev enp0s25</span><br></pre></td></tr></table></figure></div>

<p>然后可以使用 <code>ip</code> 来设置链接 up 或 down</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ip link set dev enp0s25 up</span><br><span class="line">ip link set dev enp0s25 down</span><br></pre></td></tr></table></figure></div>

<p>要验证 enp0s25 的 IP 地址配置，可以按以下方式使用 <code>ip</code> 命令。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ip address show dev enp0s25</span><br><span class="line">10: enp0s25: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000</span><br><span class="line">    link/ether 00:16:3e:e2:52:42 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 10.102.66.200/24 brd 10.102.66.255 scope global dynamic eth0</span><br><span class="line">       valid_lft 2857sec preferred_lft 2857sec</span><br><span class="line">    inet6 fe80::216:3eff:fee2:5242/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever6</span><br></pre></td></tr></table></figure></div>

<p>要<strong>配置默认网关</strong>，可以按以下方式使用ip命令。修改默认网关地址以符合您的网络要求。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ip route add default via 10.102.66.1</span><br></pre></td></tr></table></figure></div>

<p>要验证默认网关配置，可以按以下方式使用 <code>ip</code> 命令。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ip route show</span><br><span class="line">default via 10.102.66.1 dev eth0 proto dhcp src 10.102.66.200 metric 100</span><br><span class="line">10.102.66.0/24 dev eth0 proto kernel scope link src 10.102.66.200</span><br><span class="line">10.102.66.1 dev eth0 proto dhcp scope link src 10.102.66.200 metric 100 </span><br></pre></td></tr></table></figure></div>

<p>如果您需要 DNS 进行临时网络配置，则可以在文件 <code>/etc/resolv.con</code>f 中添加 DNS 服务器 IP 地址。通常，不建议直接编辑 <code>/etc/resolv.conf</code> ，但这是一个<strong>临时且非永久的配置</strong>。下例显示了如何在 <code>/etc/resolv.conf</code> 中输入两个 DNS 服务器，应将其更改为适合您网络的服务器。下一节将更详细地描述进行 DNS 客户端配置的正确的持久方法。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">nameserver 8.8.8.8</span><br><span class="line">nameserver 8.8.4.4</span><br></pre></td></tr></table></figure></div>

<p>如果您不再需要此配置，并且希望从接口清除所有 IP 配置，则可以将 <code>ip</code> 命令与 <code>flush</code> 选项一起使用，如下所示。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ip addr flush eth0</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>使用 <code>ip</code> 命令刷新IP配置不会清除 <code>/etc/resolv.conf</code> 的内容。您必须手动删除或修改这些条目，或者重新引导，这也将导致 <code>/etc/resolv.conf</code>（它是 <code>/run/systemd/resolve/stub-resolv.conf</code>的符号链接）被重写。</p>
</blockquote>
<h2 id="动态IP地址分配（DHCP客户端）"><a href="#动态IP地址分配（DHCP客户端）" class="headerlink" title="动态IP地址分配（DHCP客户端）"></a>动态IP地址分配（DHCP客户端）</h2><p>要将服务器配置为使用 DHCP 进行动态地址分配，请在文件 <code>/etc/netplan/99_config.yaml</code> 中创建一个 <code>netplan</code> 配置。下面的示例假定您正在配置标识为 <code>enp3s0</code> 的第一个以太网接口。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">network:</span><br><span class="line">  version: 2</span><br><span class="line">  renderer: networkd</span><br><span class="line">  ethernets:</span><br><span class="line">    enp3s0:</span><br><span class="line">      dhcp4: true</span><br></pre></td></tr></table></figure></div>

<p>然后可以使用 <code>netplan</code> 命令应用该配置。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo netplan apply</span><br></pre></td></tr></table></figure></div>

<h3 id="静态IP地址分配"><a href="#静态IP地址分配" class="headerlink" title="静态IP地址分配"></a>静态IP地址分配</h3><p>要将系统配置为使用静态地址分配，请在文件 <code>/etc/netplan/99_config.yaml</code> 中创建一个 <code>netplan</code> 配置。下面的示例假定您正在配置标识为 <code>eth0</code> 的第一个以太网接口。更改地址，<code>gateway4</code> 和名称服务器值，以满足您的网络要求。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">network:</span><br><span class="line">  version: 2</span><br><span class="line">  renderer: networkd</span><br><span class="line">  ethernets:</span><br><span class="line">     eno1np0:</span><br><span class="line">        dhcp4: no</span><br><span class="line">        dhcp6: no</span><br><span class="line">        addresses:</span><br><span class="line">           - 192.168.1.125/24</span><br><span class="line">        gateway4: 192.168.1.1</span><br><span class="line">        nameservers:</span><br><span class="line">           search: []</span><br><span class="line">           addresses: [192.168.1.1]</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>eno1np0：指定需配置网络接口的名称。</p>
<p>dhcp4：是否打开 IPv4 的 dhcp。</p>
<p>dhcp6：是否打开 IPv6 的 dhcp。</p>
<p>addresses：定义网络接口的静态 IP 地址。</p>
<p>gateway4：指定默认网关的 IPv4 地址。</p>
<p>nameservers：指定域名服务器的 IP 地址。</p>
</blockquote>
<p>然后可以使用 <code>netplan</code> 命令应用该配置。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo netplan apply</span><br></pre></td></tr></table></figure></div>

<h2 id="环回接口"><a href="#环回接口" class="headerlink" title="环回接口"></a>环回接口</h2><p>系统将环回接口标识为 <code>lo</code> ，其默认 IP 地址为 127.0.0.1。可以使用 <code>ip</code> 命令查看它。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ip address show lo</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure></div>

<h2 id="名称解析"><a href="#名称解析" class="headerlink" title="名称解析"></a>名称解析</h2><p>与 IP 网络相关的名称解析是将 IP 地址映射到主机名的过程，从而更容易识别网络上的资源。下一节将说明如何使用 DNS 和静态主机名记录正确配置系统以进行名称解析。</p>
<h3 id="DNS客户端配置"><a href="#DNS客户端配置" class="headerlink" title="DNS客户端配置"></a>DNS客户端配置</h3><p>传统上，文件 <code>/etc/resolv.conf</code> 是静态配置文件，很少需要通过 DCHP 客户端挂接进行更改或自动更改。 <code>Systemd-resolved</code> 处理名称服务器配置，并且应该通过 <code>systemd-resolve</code> 命令与之交互。 <code>Netplan</code> 配置<code>systemd-resolved</code> 生成一个名称服务器和域的列表，以放入 <code>/etc/resolv.conf</code> 中，这是一个符号链接：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">/etc/resolv.conf -&gt; ../run/systemd/resolve/stub-resolv.conf</span><br></pre></td></tr></table></figure></div>

<p>要配置解析器，请将适合您的网络的名称服务器的 IP 地址添加到 <code>netplan</code> 配置文件中。您还可以添加可选的 DNS 后缀搜索列表以匹配您的网络域名。生成的文件可能如下所示：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">network:</span><br><span class="line">  version: 2</span><br><span class="line">  renderer: networkd</span><br><span class="line">  ethernets:</span><br><span class="line">    enp0s25:</span><br><span class="line">      addresses:</span><br><span class="line">        - 192.168.0.100/24</span><br><span class="line">      gateway4: 192.168.0.1</span><br><span class="line">      nameservers:</span><br><span class="line">          search: [mydomain, otherdomain]</span><br><span class="line">          addresses: [1.1.1.1, 8.8.8.8, 4.4.4.4]</span><br></pre></td></tr></table></figure></div>

<p>搜索选项也可以与多个域名一起使用，以便将 DNS 查询按输入顺序附加。例如，您的网络可能有多个子域可供搜索； example.com 的父域，以及两个子域 sales.example.com 和 dev.example.com 。</p>
<p>如果您要搜索多个域，则配置可能如下所示：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">network:</span><br><span class="line">  version: 2</span><br><span class="line">  renderer: networkd</span><br><span class="line">  ethernets:</span><br><span class="line">    enp0s25:</span><br><span class="line">      addresses:</span><br><span class="line">        - 192.168.0.100/24</span><br><span class="line">      gateway4: 192.168.0.1</span><br><span class="line">      nameservers:</span><br><span class="line">          search: [example.com, sales.example.com, dev.example.com]</span><br><span class="line">          addresses: [1.1.1.1, 8.8.8.8, 4.4.4.4]</span><br></pre></td></tr></table></figure></div>

<p>如果尝试对名称为 <code>server1</code> 的主机执行 <code>ping</code> 操作，系统将按照以下顺序自动查询DNS的完全合格域名（FQDN）：</p>
<ol>
<li><p>server1.example.com</p>
</li>
<li><p>server1.sales.example.com</p>
</li>
<li><p>server1.dev.example.com</p>
</li>
</ol>
<p>如果找不到匹配项，则 DNS 服务器将提供 <code>notfound</code> 的结果，并且 DNS 查询将失败。</p>
<h4 id="静态主机名"><a href="#静态主机名" class="headerlink" title="静态主机名"></a>静态主机名</h4><p>静态主机名是本地定义的主机名到 IP 的映射，位于文件 <code>/etc/hosts</code> 中。默认情况下，<code>hosts</code> 文件中的条目将优先于 DNS 。这意味着，如果您的系统尝试解析主机名并且与 <code>/etc/hosts</code> 中的条目匹配，它将不会尝试在 DNS 中查找记录。在某些配置中，尤其是当不需要 Internet 访问时，可以方便地将与有限数量的资源进行通信的服务器设置为使用静态主机名而不是 DNS 。</p>
<p>以下是主机文件的示例，其中已通过简单的主机名，别名及其等效的完全限定域名（FQDN）标识了许多本地服务器。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1	localhost</span><br><span class="line">127.0.1.1	ubuntu-server</span><br><span class="line">10.0.0.11	server1 server1.example.com vpn</span><br><span class="line">10.0.0.12	server2 server2.example.com mail</span><br><span class="line">10.0.0.13	server3 server3.example.com www</span><br><span class="line">10.0.0.14	server4 server4.example.com file</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>在上面的示例中，请注意，除了它们的专有名称和 FQDN 之外，还为每个服务器指定了别名。 Server1 已映射为名称 vpn ，server2 被称为 mail ，server3 被称为 www ， server4 被称为 file 。</p>
</blockquote>
<h4 id="名称服务交换机配置"><a href="#名称服务交换机配置" class="headerlink" title="名称服务交换机配置"></a>名称服务交换机配置</h4><p>系统选择将主机名解析为 IP 地址的方法的顺序由名称服务交换机（NSS）配置文件 <code>/etc/nsswitch.conf</code> 控制。如上一节所述，通常，在系统 <code>/etc/hosts</code> 文件中定义的静态主机名优先于从 DNS 解析的名称。以下是文件 <code>/etc/nsswitch.conf</code> 中负责主机名查找此顺序的行的示例。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">hosts:          files mdns4_minimal [NOTFOUND=return] dns mdns4</span><br></pre></td></tr></table></figure></div>

<ol>
<li><strong>files</strong> ：首先尝试解析 <code>/etc/hosts</code> 中的静态主机名。</li>
<li><strong>mdns4_minimal</strong> ：尝试使用多播 DNS 解析名称。</li>
<li><strong>[NOTFOUND&#x3D;return]</strong> ：意味着前面的 <code>mdns4_minimal</code> 进程未找到的任何响应都应视为权威，并且系统不应尝试继续寻找答案。</li>
<li><strong>dns</strong> ：表示旧式单播 DNS 查询。</li>
<li><strong>mdns4</strong>  ：表示多播 DNS 查询。</li>
</ol>
<p>要修改上述名称解析方法的顺序，只需将 hosts：字符串更改为您选择的值即可。例如，如果您更喜欢使用传统的单播 DNS 而不是多播 DNS ，则可以在 <code>/etc/nsswitch.conf</code> 中更改字符串，如下所示。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">hosts:          files dns [NOTFOUND=return] mdns4_minimal mdns4</span><br></pre></td></tr></table></figure></div>

<h2 id="桥接"><a href="#桥接" class="headerlink" title="桥接"></a>桥接</h2><p>桥接多个接口是一种更高级的配置，但在多种情况下非常有用。一种情况是建立具有多个网络接口的网桥，然后使用防火墙过滤两个网段之间的流量。另一种情况是在具有一个接口的系统上使用网桥，以允许虚拟机直接访问外部网络。以下示例涵盖了后一种情况。</p>
<p>通过编辑 <code>/etc/netplan/</code> 中的 <code>netplan</code> 配置来配置网桥：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">network:</span><br><span class="line">  version: 2</span><br><span class="line">  renderer: networkd</span><br><span class="line">  ethernets:</span><br><span class="line">    enp3s0:</span><br><span class="line">      dhcp4: no</span><br><span class="line">  bridges:</span><br><span class="line">    br0:</span><br><span class="line">      dhcp4: yes</span><br><span class="line">      interfaces:</span><br><span class="line">        - enp3s0</span><br></pre></td></tr></table></figure></div>

<p>为您的物理接口和网络输入适当的值。</p>
<p>现在应用配置以启用网桥：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo netplan apply</span><br></pre></td></tr></table></figure></div>

<p>现在，新的网桥接口应已启动并正在运行。 <code>brctl</code> 提供有关网桥状态的有用信息，控制哪些接口是网桥的一部分，等等。有关更多信息，请参见 <code>man brctl</code> 。</p>
<h2 id="YAML-语言基本语法规则"><a href="#YAML-语言基本语法规则" class="headerlink" title="YAML 语言基本语法规则"></a>YAML 语言基本语法规则</h2><p>YAML 语言的设计目标，就是方便人类读写。它实质上是一种通用的数据串行化格式。 YAML 基本语法规则如下:</p>
<blockquote>
<p>大小写敏感<br>使用缩进表示层级关系<br>缩进时不允许使用Tab键，只允许使用空格。<br>缩进的空格数目不重要，只要相同层级的元素左侧对齐即可<br>#表示注释，从这个字符一直到行尾，都会被解析器忽略。</p>
</blockquote>
<h3 id="根据-Netplan-的描述文件手动创建网络守护程序的配置信息"><a href="#根据-Netplan-的描述文件手动创建网络守护程序的配置信息" class="headerlink" title="根据 Netplan 的描述文件手动创建网络守护程序的配置信息"></a>根据 Netplan 的描述文件手动创建网络守护程序的配置信息</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo netplan generate</span><br></pre></td></tr></table></figure></div>

<p>执行后会使用  <code>/etc/netplan/*.yaml</code> 生成对应网络守护程序的配置信息。例如：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /run/systemd/network/10-netplan-enp0s5.network</span></span><br><span class="line">[Match]</span><br><span class="line">Name=enp0s5</span><br><span class="line"></span><br><span class="line">[Link]</span><br><span class="line">RequiredForOnline=no</span><br><span class="line"></span><br><span class="line">[Network]</span><br><span class="line">Address=192.168.100.211/23</span><br><span class="line">Gateway=192.168.100.1</span><br><span class="line">DNS=8.8.8.8</span><br><span class="line">DNS=8.8.4.4</span><br></pre></td></tr></table></figure></div>

<h3 id="查看当前系统的-DNS-Servers"><a href="#查看当前系统的-DNS-Servers" class="headerlink" title="查看当前系统的 DNS Servers"></a>查看当前系统的 DNS Servers</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemd-resolve --status</span></span><br><span class="line">Global</span><br><span class="line">          DNSSEC NTA: 10.in-addr.arpa</span><br><span class="line">                      16.172.in-addr.arpa</span><br><span class="line">                      168.192.in-addr.arpa</span><br><span class="line">                      17.172.in-addr.arpa</span><br><span class="line">                      18.172.in-addr.arpa</span><br><span class="line">                      19.172.in-addr.arpa</span><br><span class="line">                      20.172.in-addr.arpa</span><br><span class="line">                      21.172.in-addr.arpa</span><br><span class="line">                      22.172.in-addr.arpa</span><br><span class="line">                      23.172.in-addr.arpa</span><br><span class="line">                      24.172.in-addr.arpa</span><br><span class="line">                      25.172.in-addr.arpa</span><br><span class="line">                      26.172.in-addr.arpa</span><br><span class="line">                      27.172.in-addr.arpa</span><br><span class="line">                      28.172.in-addr.arpa</span><br><span class="line">                      29.172.in-addr.arpa</span><br><span class="line">                      30.172.in-addr.arpa</span><br><span class="line">                      31.172.in-addr.arpa</span><br><span class="line">                      corp</span><br><span class="line">                      d.f.ip6.arpa</span><br><span class="line">                      home</span><br><span class="line">                      internal</span><br><span class="line">                      intranet</span><br><span class="line">                      lan</span><br><span class="line">                      local</span><br><span class="line">                      private</span><br><span class="line">                      test</span><br><span class="line"></span><br><span class="line">Link 2 (enp0s5)</span><br><span class="line">      Current Scopes: DNS</span><br><span class="line">       LLMNR setting: yes</span><br><span class="line">MulticastDNS setting: no</span><br><span class="line">      DNSSEC setting: no</span><br><span class="line">    DNSSEC supported: no</span><br><span class="line">         DNS Servers: 8.8.8.8</span><br><span class="line">                      8.8.4.4</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu远程ssh使用root账户登录时的权限问题</title>
    <url>/2019/05/05/Ubuntu%E8%BF%9C%E7%A8%8Bssh%E4%BD%BF%E7%94%A8root%E8%B4%A6%E6%88%B7%E7%99%BB%E5%BD%95%E6%97%B6%E7%9A%84%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>Ubuntu使用ssh进行远程登陆，账户为 <code>root</code> 时，提示出现 Permission denied 错误。</p>
 <span id="more"></span>

<p>解决办法，编辑服务器中的 <code>/etc/ssh/sshd_config</code> 配置文件：</p>
<p>搜索找到 <code>PermitRootLogin without-password</code> 这行，注释掉，然后添加代码 <code>PermitRootLogin yes</code></p>
<p>然后重启 ssh</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">sudo service ssh restart</span><br></pre></td></tr></table></figure></div>

<p>另外，用 <code>ssh密钥 </code>也可以，使用 <code>ssh-keygen</code> 生成后，追加在 <code>/root/.ssh/authorized_keys</code> 文件中即可.</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim键位参考与速查表</title>
    <url>/2023/03/14/Vim%E9%94%AE%E4%BD%8D%E5%8F%82%E8%80%83%E4%B8%8E%E9%80%9F%E6%9F%A5%E8%A1%A8/</url>
    <content><![CDATA[<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/12341234.jpg"
                     
                ></p>
<hr>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/12342314.png"
                     
                ></p>
]]></content>
      <categories>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows10使用Robocopy多线程功能加速中的文件复制</title>
    <url>/2019/04/18/Windows10%E4%BD%BF%E7%94%A8Robocopy%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8A%9F%E8%83%BD%E5%8A%A0%E9%80%9F%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<p>当用户需要将文件或文件夹复制到另一个驱动器时，通常都使用（GUI 中）标准的选择、复制和粘贴操作。虽然默认的批量文件复制和移动功能在 Windows 10 操作系统中已经历经过微软多次优化，已经能够工作得很好，但当尝试传输大批量文件（特别是大量小文件）时，还是需要很长时间，速度就成了一个瓶颈。<br> <span id="more"></span><br>此时，许多精通技术的 Windows 用户都会使用 <strong>Robocopy</strong>（Robust File Copy，强大的文件复制），这是一个内置于 Windows 10 中的命令行工具，它提供了更多功能来帮助用户更快地将数据移动到不同的位置。</p>
<p><strong>Robocopy</strong> 最为特殊也经常被忽略的是其支持多线程的能力，允许我们同时复制多个文件，而不像在<strong>文件管理器</strong>中复制文件时只能一次一个（移动多个文件时也只是列队之后一个一个移动）。</p>
<p>下面介绍在 Windows 10 中如何使用 <strong>Robocopy</strong> 的多线程副本功能来加快文件和文件夹的复制、移动传输过程。</p>
<h3 id="如何使用Robocopy多线程特性"><a href="#如何使用Robocopy多线程特性" class="headerlink" title="如何使用Robocopy多线程特性"></a>如何使用Robocopy多线程特性</h3><p>如果你要将 Windows 10 中的大量文件和文件夹复制到另一个驱动器，可以仿照如下步骤来实现 <strong>Robocopy</strong> 多线程功能以达到超快的数据复制速度：</p>
<h4 id="以管理员权限打开「命令提示符」"><a href="#以管理员权限打开「命令提示符」" class="headerlink" title="以管理员权限打开「命令提示符」"></a>以管理员权限打开「命令提示符」</h4><h4 id="执行类似如下命令进行多线程复制"><a href="#执行类似如下命令进行多线程复制" class="headerlink" title="执行类似如下命令进行多线程复制"></a>执行类似如下命令进行多线程复制</h4><div class="highlight-container" data-rel="Powershell"><figure class="iseeu highlight powershell"><table><tr><td class="code"><pre><span class="line">ROBOCOPY source destination [<span class="type">file</span> [<span class="type">file</span>]<span class="type">...</span>] [<span class="type">options</span>]</span><br></pre></td></tr></table></figure></div>
<p><strong>source</strong> :  源目录(驱动器:\路径或\服务器\共享\路径)。<br><strong>destination</strong> :  目标目录(驱动器:\路径或\服务器\共享\路径)。<br><strong>file</strong> :  要复制的文件(名称&#x2F;通配符: 默认为 “<em>.</em>“)。</p>
<p>例如：</p>
<div class="highlight-container" data-rel="Powershell"><figure class="iseeu highlight powershell"><table><tr><td class="code"><pre><span class="line">robocopy D:\Pictures\ E:\收藏\Pictures /S /ZB /<span class="built_in">R</span>:<span class="number">5</span> /W:<span class="number">5</span> /V /MT:<span class="number">8</span></span><br></pre></td></tr></table></figure></div>

<p><strong>注意</strong>：请自行将源路径和目标路径替换成你自己的。</p>
<h3 id="Robocopy命令行用法解释"><a href="#Robocopy命令行用法解释" class="headerlink" title="Robocopy命令行用法解释"></a>Robocopy命令行用法解释</h3><p>robocopy 的功能非常强大，因此其命令行开关也非常之多，下面我们只列出能够可靠、快速复制文件的常用开关。</p>
<blockquote>
<p><strong>&#x2F;S</strong>:  复制子目录，但不复制空的子目录。<br><strong>&#x2F;E</strong>:  复制子目录，包括空的子目录。<br><strong>&#x2F;LEV:n</strong>:  仅复制源目录树的前 n 层。<br><strong>&#x2F;Z</strong>:  在可重新启动模式下复制文件。<br><strong>&#x2F;B</strong>:  在备份模式下复制文件。<br><strong>&#x2F;ZB</strong>:  使用可重新启动模式；如果拒绝访问，请使用备份模式。<br><strong>&#x2F;J</strong>:   复制时使用未缓冲的 I&#x2F;O (推荐在复制大文件时使用)。<br><strong>&#x2F;R:n</strong>:  失败副本的重试次数: 默认为 1 百万。<br><strong>&#x2F;W:n</strong>:  两次重试间的等待时间: 默认为 30 秒。<br><strong>&#x2F;TBD</strong>:   等待定义共享名称(重试错误 67)。<br><strong>&#x2F;NP</strong>:   无进度 – 不显示已复制的百分比。<br><strong>&#x2F;V</strong>:  生成详细输出，同时显示跳过的文件。<br><strong>&#x2F;MOV</strong>:   移动文件(复制后从源中删除)。<br><strong>&#x2F;MOVE</strong>:  移动文件和目录(复制后从源中删除)。<br><strong>&#x2F;MT:32</strong>:  使用 n 个线程进行多线程复制(默认值为 8)。必须至少为 1，但不得大于 128。</p>
</blockquote>
<p>上述命令中最为重要的开关就是 &#x2F;MT，它让 robocopy 能够以多线程模式进行复制传输。如果你没为 &#x2F;MT设置数字，那么默认数字是 8，这意味着 Robocopy 将会同时复制 8 个文件。我个人推荐使用 8个线程，虽然可开的线程可以更多，但数字越大，所使用的系统资源和带宽就越多。</p>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>int、char、long各占多少字节数</title>
    <url>/2018/12/17/int%E3%80%81char%E3%80%81long%E5%90%84%E5%8D%A0%E5%A4%9A%E5%B0%91%E5%AD%97%E8%8A%82%E6%95%B0/</url>
    <content><![CDATA[<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(Byte.SIZE);</span><br><span class="line">    System.out.println(Character.SIZE);</span><br><span class="line">    System.out.println(Short.SIZE);</span><br><span class="line">    System.out.println(Integer.SIZE);</span><br><span class="line">    System.out.println(Float.SIZE);</span><br><span class="line">    System.out.println(Double.SIZE);</span><br><span class="line">    System.out.println(Long.SIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<span id="more"></span>

<p>输出：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">16</span><br><span class="line">16</span><br><span class="line">32</span><br><span class="line">32</span><br><span class="line">64</span><br><span class="line">64</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>type</th>
<th>size</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>1字节</td>
<td>最小值是 -128（-2^7）；最大值是 127（2^7-1）</td>
</tr>
<tr>
<td>boolean</td>
<td>至少1字节</td>
<td>这种类型只作为一种标志来记录 true&#x2F;false 情况</td>
</tr>
<tr>
<td>short</td>
<td>2字节</td>
<td>最小值是 -32768（-2^15）；最大值是 32767（2^15 - 1）</td>
</tr>
<tr>
<td>char</td>
<td>2字节</td>
<td>最小值是 \u0000（即为0）；最大值是 \uffff（即为65,535）</td>
</tr>
<tr>
<td>int</td>
<td>4字节</td>
<td>最小值是 -2,147,483,648（-2^31）；最大值是 2,147,483,647（2^31^ - 1）</td>
</tr>
<tr>
<td>float</td>
<td>4字节</td>
<td>单精度浮点数字长32位，尾数长度23，指数长度8,指数偏移量127</td>
</tr>
<tr>
<td>long</td>
<td>8字节</td>
<td>最小值是 -9,223,372,036,854,775,808（-2^63）；最大值是 9,223,372,036,854,775,807（2^63 -1）</td>
</tr>
<tr>
<td>double</td>
<td>8字节</td>
<td>双精度浮点数字长64位，尾数长度52，指数长度11，指数偏移量1023</td>
</tr>
</tbody></table>
<p><strong>英文字母：</strong></p>
<ul>
<li>字节数 : 1，编码：GB2312</li>
<li>字节数 : 1，编码：GBK</li>
<li>字节数 : 1，编码：ISO-8859-1</li>
<li>字节数 : 1，编码：UTF-8</li>
</ul>
<p><strong>中文汉字：</strong></p>
<ul>
<li>字节数 : 2，编码：GB2312</li>
<li>字节数 : 2，编码：GBK</li>
<li>字节数 : 1，编码：ISO-8859-1</li>
<li>字节数 : 3，编码：UTF-8</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>int与integer的区别</title>
    <url>/2018/11/15/int%E4%B8%8Einteger%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<ul>
<li>Integer是int的包装类，int则是java的一种基本数据类型</li>
<li>Integer变量必须实例化后才能使用，而int变量不需要</li>
<li>Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值</li>
<li>Integer的默认值是null，int的默认值是0</li>
</ul>
<span id="more"></span>

<p><strong>关于Integer和int的比较</strong></p>
<ol>
<li>由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">100</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">100</span>);</span><br><span class="line">System.out.print(i == j); <span class="comment">//false</span></span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较）</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">100</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">100</span>；</span><br><span class="line">System.out.print(i == j); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li>非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。（因为非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同）</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">100</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">System.out.print(i == j); <span class="comment">//false</span></span><br></pre></td></tr></table></figure></div>

<ol start="4">
<li>对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">System.out.print(i == j); <span class="comment">//true</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">System.out.print(i == j); <span class="comment">//false</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>对于第4条的原因： java在编译Integer i &#x3D; 100 ;时，会翻译成为Integer i &#x3D; Integer.valueOf(100)；，而java API中对Integer类型的valueOf的定义如下：</p>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">     <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">     <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)&#123;</span><br><span class="line">         <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>java对于-128到127之间的数，会进行缓存，Integer i &#x3D; 127时，会将127进行缓存，下次再写Integer j &#x3D; 127时，就会直接从缓存中取，就不会new了</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>npm设置代理</title>
    <url>/2019/03/14/npm%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p> 通常情况下当 npm 无法下载依赖时，我们使用 cnpm 就够了。但是总是存在特殊情况的：</p>
<ol>
<li><p>公司内网，无法访问 npm，但是有一个代理可以访问外网</p>
</li>
<li><p>网络质量很差，连 cnpm 都无法正常使用（比如长城坑带，跨市就出现大量的丢包）</p>
</li>
</ol>
<p>那就需要给 npm 设置代理了</p>
<span id="more"></span>

<h2 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h2><h3 id="http-代理"><a href="#http-代理" class="headerlink" title="http 代理"></a>http 代理</h3><p>npm 原生支持 http 代理，直接设置即可</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">假设本地代理端口为1080</span></span><br><span class="line">npm config set proxy &quot;http://localhost:1080&quot;</span><br><span class="line">npm config set https-proxy &quot;http://localhost:1080&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">有用户密码的代理</span></span><br><span class="line">npm config set proxy &quot;http://username:password@localhost:1080&quot;</span><br><span class="line">npm confit set https-proxy &quot;http://username:password@localhost:1080&quot;</span><br></pre></td></tr></table></figure></div>

<h3 id="socks5-代理"><a href="#socks5-代理" class="headerlink" title="socks5 代理"></a>socks5 代理</h3><p>npm 不支持 socks 代理，但是我们可以用一个工具将 http 代理转成 socks 代理，然后将 npm 代理地址设置到这个工具的地址。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">假设本地socks5代理端口为1081</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">首先安装转换工具</span></span><br><span class="line">npm install -g http-proxy-to-socks</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后使用这个工具监听1080端口,支持http代理，然后所有1080的http代理数据都将转换成socks的代理数据发送到1081上</span></span><br><span class="line">hpts -s localhost:1081 -p 1080</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">最后设置npm代理为1080</span></span><br><span class="line">npm config set proxy &quot;http://localhost:1080&quot;</span><br><span class="line">npm config set https-proxy &quot;http://localhost:1080&quot;</span><br></pre></td></tr></table></figure></div>

<p>相当于又加了一个中间层，将 http 转成 socks。</p>
<h2 id="删除代理"><a href="#删除代理" class="headerlink" title="删除代理"></a>删除代理</h2><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">npm config delete proxy</span><br><span class="line">npm config delete https-proxy</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>npm</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是内部类？内部类的作用</title>
    <url>/2018/07/22/%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%9F%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<h3 id="内部类基础"><a href="#内部类基础" class="headerlink" title="内部类基础"></a>内部类基础</h3><p>在Java中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。广泛意义上的内部类一般来说包括这四种：成员内部类、局部内部类、匿名内部类和静态内部类。下面就先来了解一下这四种内部类的用法。</p>
<span id="more"></span>

<h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><p>成员内部类是最普通的内部类，它的定义为位于另一个类的内部，形如下面的形式：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">radius</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(<span class="type">double</span> radius)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Draw</span> &#123;     <span class="comment">//内部类</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawSahpe</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;drawshape&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这样看起来，类Draw像是类Circle的一个成员，Circle称为外部类。成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="variable">radius</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(<span class="type">double</span> radius)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Draw</span> &#123;     <span class="comment">//内部类</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawSahpe</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(radius);  <span class="comment">//外部类的private成员</span></span><br><span class="line">            System.out.println(count);   <span class="comment">//外部类的静态成员</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>不过要注意的是，当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">外部类.<span class="built_in">this</span>.成员变量</span><br><span class="line">外部类.<span class="built_in">this</span>.成员方法</span><br></pre></td></tr></table></figure></div>

<p>虽然成员内部类可以无条件地访问外部类的成员，而外部类想访问成员内部类的成员却不是这么随心所欲了。在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="variable">radius</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(<span class="type">double</span> radius)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.radius = radius;</span><br><span class="line">        getDrawInstance().drawSahpe();   <span class="comment">//必须先创建成员内部类的对象，再进行访问</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Draw <span class="title function_">getDrawInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Draw</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Draw</span> &#123;     <span class="comment">//内部类</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawSahpe</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(radius);  <span class="comment">//外部类的private成员</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。创建成员内部类对象的一般方式如下：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="comment">//第一种方式：</span></span><br><span class="line">        <span class="type">Outter</span> <span class="variable">outter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outter</span>();</span><br><span class="line">        Outter.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> outter.<span class="keyword">new</span> <span class="title class_">Inner</span>();  <span class="comment">//必须通过Outter对象来创建</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二种方式：</span></span><br><span class="line">        Outter.<span class="type">Inner</span> <span class="variable">inner1</span> <span class="operator">=</span> outter.getInnerInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Outter</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">getInnerInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(inner == <span class="literal">null</span>)</span><br><span class="line">            inner = <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        <span class="keyword">return</span> inner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Inner</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>内部类可以拥有private访问权限、protected访问权限、public访问权限及包访问权限。比如上面的例子，如果成员内部类Inner用private修饰，则只能在外部类的内部访问，如果用public修饰，则任何地方都能访问；如果用protected修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。这一点和外部类有一点不一样，外部类只能被public和包访问两种权限修饰。我个人是这么理解的，由于成员内部类看起来像是外部类的一个成员，所以可以像类的成员一样拥有多种权限修饰。</p>
<h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p>局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">People</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Man</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Man</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> People <span class="title function_">getWoman</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Woman</span> <span class="keyword">extends</span> <span class="title class_">People</span>&#123;   <span class="comment">//局部内部类</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Woman</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>注意，局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。</p>
<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>匿名内部类应该是平时我们编写代码时用得最多的，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护。下面这段代码是一段Android事件监听代码：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">scan_bt.setOnClickListener(<span class="keyword">new</span> <span class="title class_">OnClickListener</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">history_bt.setOnClickListener(<span class="keyword">new</span> <span class="title class_">OnClickListener</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<p>这段代码为两个按钮设置监听器，这里面就使用了匿名内部类。这段代码中的：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">OnClickListener</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>就是匿名内部类的使用。代码中需要给按钮设置监听器对象，使用匿名内部类能够在实现父类或者接口中的方法情况下同时产生一个相应的对象，但是前提是这个父类或者接口必须先存在才能这样使用。当然像下面这种写法也是可以的，跟上面使用匿名内部类达到效果相同。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setListener</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    scan_bt.setOnClickListener(<span class="keyword">new</span> <span class="title class_">Listener1</span>());</span><br><span class="line">    history_bt.setOnClickListener(<span class="keyword">new</span> <span class="title class_">Listener2</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Listener1</span> <span class="keyword">implements</span> <span class="title class_">View</span>.OnClickListener&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Listener2</span> <span class="keyword">implements</span> <span class="title class_">View</span>.OnClickListener&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这种写法虽然能达到一样的效果，但是既冗长又难以维护，所以一般使用匿名内部类的方法来编写事件监听代码。同样的，匿名内部类也是不能有访问修饰符和static修饰符的。</p>
<p>匿名内部类是唯一一种没有构造器的类。正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调。匿名内部类在编译的时候由系统自动起名为Outter$1.class。一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。</p>
<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        Outter.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outter</span>.Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Outter</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Inner</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="深入理解内部类"><a href="#深入理解内部类" class="headerlink" title="深入理解内部类"></a>深入理解内部类</h3><h4 id="为什么成员内部类可以无条件访问外部类的成员"><a href="#为什么成员内部类可以无条件访问外部类的成员" class="headerlink" title="为什么成员内部类可以无条件访问外部类的成员"></a>为什么成员内部类可以无条件访问外部类的成员</h4><p>在此之前，我们已经讨论过了成员内部类可以无条件访问外部类的成员，那具体究竟是如何实现的呢？下面通过反编译字节码文件看看究竟。事实上，编译器在进行编译的时候，会将成员内部类单独编译成一个字节码文件，下面是Outter.java的代码：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Outter</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">getInnerInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(inner == <span class="literal">null</span>)</span><br><span class="line">            inner = <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        <span class="keyword">return</span> inner;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Inner</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>编译之后，出现了两个字节码文件：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">Outter$</span><span class="language-bash">Inner.class</span></span><br><span class="line">Outter.class</span><br></pre></td></tr></table></figure></div>

<p>反编译Outter$Inner.class文件得到下面信息：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"> bill@ThinkPad:~/test$ javap -v Outter\$Inner.class</span><br><span class="line">Classfile /home/bill/test/Outter$Inner.class</span><br><span class="line">  Last modified Feb 27, 2019; size 304 bytes</span><br><span class="line">  MD5 checksum 732ba89287828251572200e940699e56</span><br><span class="line">  Compiled from &quot;Outter.java&quot;</span><br><span class="line">public class Outter$Inner</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">1 = Fieldref           <span class="comment">#3.#13         // Outter$Inner.this$0:LOutter;</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">2 = Methodref          <span class="comment">#4.#14         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">3 = Class              <span class="comment">#16            // Outter$Inner</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">4 = Class              <span class="comment">#19            // java/lang/Object</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">5 = Utf8               this<span class="variable">$0</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">6 = Utf8               LOutter;</span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">7 = Utf8               &lt;init&gt;</span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">8 = Utf8               (LOutter;)V</span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">9 = Utf8               Code</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">10 = Utf8               LineNumberTable</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">11 = Utf8               SourceFile</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">12 = Utf8               Outter.java</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">13 = NameAndType        <span class="comment">#5:#6          // this$0:LOutter;</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">14 = NameAndType        <span class="comment">#7:#20         // &quot;&lt;init&gt;&quot;:()V</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">15 = Class              <span class="comment">#21            // Outter</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">16 = Utf8               Outter<span class="variable">$Inner</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">17 = Utf8               Inner</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">18 = Utf8               InnerClasses</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">19 = Utf8               java/lang/Object</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">20 = Utf8               ()V</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">21 = Utf8               Outter</span></span><br><span class="line">&#123;</span><br><span class="line">  final Outter this$0;</span><br><span class="line">    descriptor: LOutter;</span><br><span class="line">    flags: ACC_FINAL, ACC_SYNTHETIC</span><br><span class="line"></span><br><span class="line">  public Outter$Inner(Outter);</span><br><span class="line">    descriptor: (LOutter;)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=2, args_size=2</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: aload_1</span><br><span class="line">         2: putfield      #1                  // Field this$0:LOutter;</span><br><span class="line">         5: aload_0</span><br><span class="line">         6: invokespecial #2                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         9: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 14: 0</span><br><span class="line">        line 16: 9</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;Outter.java&quot;</span><br><span class="line">InnerClasses:</span><br><span class="line">     protected #17= #3 of #15; //Inner=class Outter$Inner of class Outter</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>第33行的内容：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">final Outter this$0;</span><br></pre></td></tr></table></figure></div>

<p>这行是一个指向外部类对象的指针，看到这里想必大家豁然开朗了。也就是说编译器会默认为成员内部类添加了一个指向外部类对象的引用，那么这个引用是如何赋初值的呢？下面接着看内部类的构造器：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">public Outter$Inner(Outter);</span><br></pre></td></tr></table></figure></div>

<p>从这里可以看出，虽然我们在定义的内部类的构造器是无参构造器，编译器还是会默认添加一个参数，该参数的类型为指向外部类对象的一个引用，所以成员内部类中的Outter this&amp;0 指针便指向了外部类对象，因此可以在成员内部类中随意访问外部类的成员。从这里也间接说明了成员内部类是依赖于外部类的，如果没有创建外部类的对象，则无法对Outter this&amp;0引用进行初始化赋值，也就无法创建成员内部类的对象了。</p>
<h4 id="为什么局部内部类和匿名内部类只能访问局部final变量"><a href="#为什么局部内部类和匿名内部类只能访问局部final变量" class="headerlink" title="为什么局部内部类和匿名内部类只能访问局部final变量"></a>为什么局部内部类和匿名内部类只能访问局部final变量</h4><p>想必这个问题也曾经困扰过很多人，在讨论这个问题之前，先看下面这段代码：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">                System.out.println(b);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这段代码会被编译成两个class文件：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">Test.class</span><br><span class="line"><span class="meta prompt_">Test$</span><span class="language-bash">1.class</span></span><br></pre></td></tr></table></figure></div>

<p>默认情况下，编译器会为匿名内部类和局部内部类起名为Outterx.class（x为正整数）。</p>
<p>上段代码中，如果把变量a和b前面的任一个final去掉，这段代码都编译不过。我们先考虑这样一个问题：</p>
<p>当test方法执行完毕之后，变量a的生命周期就结束了，而此时Thread对象的生命周期很可能还没有结束，那么在Thread的run方法中继续访问变量a就变成不可能了，但是又要实现这样的效果，怎么办呢？Java采用了 复制 的手段来解决这个问题。将这段代码的字节码反编译可以得到下面的内容：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">public void run();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: bipush        10</span><br><span class="line">         5: invokevirtual #5                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">         8: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        11: aload_0</span><br><span class="line">        12: getfield      #2                  // Field val$b:I</span><br><span class="line">        15: invokevirtual #5                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">        18: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 8: 0</span><br><span class="line">        line 9: 8</span><br><span class="line">        line 10: 18</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div>

<p>我们看到在run方法中有一条指令：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">3: bipush        10</span><br></pre></td></tr></table></figure></div>

<p>这条指令表示将操作数10压栈，表示使用的是一个本地局部变量。这个过程是在编译期间由编译器默认进行，如果这个变量的值在编译期间可以确定，则编译器默认会在匿名内部类（局部内部类）的常量池中添加一个内容相等的字面量或直接将相应的字节码嵌入到执行字节码中。这样一来，匿名内部类使用的变量是另一个局部变量，只不过值和方法中局部变量的值相等，因此和方法中的局部变量完全独立开。</p>
<p>下面再看一个例子：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  final int val$a;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_FINAL, ACC_SYNTHETIC</span><br><span class="line"></span><br><span class="line">  final Test this$0;</span><br><span class="line">    descriptor: LTest;</span><br><span class="line">    flags: ACC_FINAL, ACC_SYNTHETIC</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  Test$</span><span class="language-bash">1(Test, int);</span></span><br><span class="line">    descriptor: (LTest;I)V</span><br><span class="line">    flags:</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=3, args_size=3</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: aload_1</span><br><span class="line">         2: putfield      #1                  // Field this$0:LTest;</span><br><span class="line">         5: aload_0</span><br><span class="line">         6: iload_2</span><br><span class="line">         7: putfield      #2                  // Field val$a:I</span><br><span class="line">        10: aload_0</span><br><span class="line">        11: invokespecial #3                  // Method java/lang/Thread.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        14: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 7: 0</span><br><span class="line"></span><br><span class="line">  public void run();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: aload_0</span><br><span class="line">         4: getfield      #2                  // Field val$a:I</span><br><span class="line">         7: invokevirtual #5                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">        10: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 9: 0</span><br><span class="line">        line 10: 10</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;Test.java&quot;</span><br><span class="line">EnclosingMethod: #21.#22                // Test.test</span><br><span class="line">InnerClasses:</span><br><span class="line">     #6; //class Test$1</span><br></pre></td></tr></table></figure></div>

<p>我们看到匿名内部类Test$1的构造器含有两个参数，一个是指向外部类对象的引用，一个是int型变量，很显然，这里是将变量test方法中的形参a以参数的形式传进来对匿名内部类中的拷贝（变量a的拷贝）进行赋值初始化。</p>
<p><strong>也就说如果局部变量的值在编译期间就可以确定，则直接在匿名内部里面创建一个拷贝。如果局部变量的值无法在编译期间确定，则通过构造器传参的方式来对拷贝进行初始化赋值。</strong></p>
<p>从上面可以看出，在run方法中访问的变量a根本就不是test方法中的局部变量a。这样一来就解决了前面所说的 生命周期不一致的问题。但是新的问题又来了，既然在run方法中访问的变量a和test方法中的变量a不是同一个变量，当在run方法中改变变量a的值的话，会出现什么情况？</p>
<p>对，会造成数据不一致性，这样就达不到原本的意图和要求。为了解决这个问题，java编译器就限定必须将变量a限制为final变量，不允许对变量a进行更改（对于引用类型的变量，是不允许指向新的对象），这样数据不一致性的问题就得以解决了。</p>
<p>到这里，想必大家应该清楚为何方法中的局部变量和形参都必须用final进行限定了。</p>
<h4 id="静态内部类有特殊的地方吗"><a href="#静态内部类有特殊的地方吗" class="headerlink" title="静态内部类有特殊的地方吗"></a>静态内部类有特殊的地方吗</h4><p>从前面可以知道，静态内部类是不依赖于外部类的，也就说可以在不创建外部类对象的情况下创建内部类的对象。另外，静态内部类是不持有指向外部类对象的引用的，这个读者可以自己尝试反编译class文件看一下就知道了，是没有Outter this&amp;0引用的。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Outter</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">getInnerInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(inner == <span class="literal">null</span>)</span><br><span class="line">            inner = <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        <span class="keyword">return</span> inner;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Inner</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">bill@ThinkPad:~/test$ javap -v Outter\$Inner.class</span><br><span class="line">Classfile /home/bill/test/Outter$Inner.class</span><br><span class="line">  Last modified Feb 27, 2019; size 247 bytes</span><br><span class="line">  MD5 checksum 49f1ac59bf30823652c62cfb3807f21e</span><br><span class="line">  Compiled from &quot;Outter.java&quot;</span><br><span class="line">class Outter$Inner</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">1 = Methodref          <span class="comment">#3.#10         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">2 = Class              <span class="comment">#12            // Outter$Inner</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">3 = Class              <span class="comment">#15            // java/lang/Object</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">4 = Utf8               &lt;init&gt;</span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">5 = Utf8               ()V</span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">6 = Utf8               Code</span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">7 = Utf8               LineNumberTable</span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">8 = Utf8               SourceFile</span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">9 = Utf8               Outter.java</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">10 = NameAndType        <span class="comment">#4:#5          // &quot;&lt;init&gt;&quot;:()V</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">11 = Class              <span class="comment">#16            // Outter</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">12 = Utf8               Outter<span class="variable">$Inner</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">13 = Utf8               Inner</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">14 = Utf8               InnerClasses</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">15 = Utf8               java/lang/Object</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">16 = Utf8               Outter</span></span><br><span class="line">&#123;</span><br><span class="line">  public Outter$Inner();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 12: 0</span><br><span class="line">        line 13: 4</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;Outter.java&quot;</span><br><span class="line">InnerClasses:</span><br><span class="line">     static #13= #2 of #11; //Inner=class Outter$Inner of class Outter</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h4 id="内部类的使用场景和好处"><a href="#内部类的使用场景和好处" class="headerlink" title="内部类的使用场景和好处"></a>内部类的使用场景和好处</h4><p>为什么在Java中需要内部类？总结一下主要有以下四点：</p>
<ul>
<li>每个内部类都能独立的继承一个接口的实现，所以无论外部类是否已经继承了某个(接口的)实现，对于内部类都没有影响。内部类使得多继承的解决方案变得完整</li>
<li>方便将存在一定逻辑关系的类组织在一起，又可以对外界隐藏</li>
<li>方便编写事件驱动程序</li>
<li>方便编写线程代码 个人觉得第一点是最重要的原因之一，内部类的存在使得Java的多继承机制变得更加完善</li>
</ul>
<h4 id="常见的与内部类相关的笔试面试题"><a href="#常见的与内部类相关的笔试面试题" class="headerlink" title="常见的与内部类相关的笔试面试题"></a>常见的与内部类相关的笔试面试题</h4><h5 id="根据注释填写-1-，-2-，-3-处的代码"><a href="#根据注释填写-1-，-2-，-3-处的代码" class="headerlink" title="根据注释填写(1)，(2)，(3)处的代码"></a>根据注释填写(1)，(2)，(3)处的代码</h5><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 初始化Bean1</span></span><br><span class="line">        <span class="comment">//(1)</span></span><br><span class="line">        bean1.I++;</span><br><span class="line">        <span class="comment">// 初始化Bean2</span></span><br><span class="line">        <span class="comment">//(2)</span></span><br><span class="line">        bean2.J++;</span><br><span class="line">        <span class="comment">//初始化Bean3</span></span><br><span class="line">        <span class="comment">//(3)</span></span><br><span class="line">        bean3.k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Bean1</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="variable">I</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean2</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="variable">J</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bean</span>&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Bean3</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>答案：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 初始化Bean1</span></span><br><span class="line">        <span class="comment">//(1)</span></span><br><span class="line">        <span class="type">Solution</span> <span class="variable">mySolution</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution</span>();</span><br><span class="line">        <span class="type">Bean1</span> <span class="variable">bean1</span> <span class="operator">=</span> mySolution.<span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line">        bean1.I++;</span><br><span class="line">        <span class="comment">// 初始化Bean2</span></span><br><span class="line">        <span class="comment">//(2)</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Bean2</span> <span class="variable">bean2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution</span>.Bean2();</span><br><span class="line"></span><br><span class="line">        bean2.J++;</span><br><span class="line">        <span class="comment">//初始化Bean3</span></span><br><span class="line">        <span class="comment">//(3)</span></span><br><span class="line">        <span class="type">Bean</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bean</span>();</span><br><span class="line">        Bean.<span class="type">Bean3</span> <span class="variable">bean3</span> <span class="operator">=</span> bean.<span class="keyword">new</span> <span class="title class_">Bean3</span>();</span><br><span class="line">        bean3.k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Bean1</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="variable">I</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean2</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="variable">J</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bean</span>&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Bean3</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>从前面可知，对于成员内部类，必须先产生外部类的实例化对象，才能产生内部类的实例化对象。而静态内部类不用产生外部类的实例化对象即可产生内部类的实例化对象。</p>
<p>创建静态内部类对象的一般形式为： <strong>外部类类名.内部类类名 xxx &#x3D; new 外部类类名.内部类类名()</strong></p>
<p>创建成员内部类对象的一般形式为： <strong>外部类类名.内部类类名 xxx &#x3D; 外部类对象名.new 内部类类名()</strong></p>
<h4 id="下面这段代码的输出结果是什么"><a href="#下面这段代码的输出结果是什么" class="headerlink" title="下面这段代码的输出结果是什么"></a>下面这段代码的输出结果是什么</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="type">Outter</span> <span class="variable">outter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outter</span>();</span><br><span class="line">        outter.<span class="keyword">new</span> <span class="title class_">Inner</span>().print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;局部变量：&quot;</span> + a);</span><br><span class="line">            System.out.println(<span class="string">&quot;内部类变量：&quot;</span> + <span class="built_in">this</span>.a);</span><br><span class="line">            System.out.println(<span class="string">&quot;外部类变量：&quot;</span> + Outter.<span class="built_in">this</span>.a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure></div>

<p>最后补充一点知识：关于成员内部类的继承问题。一般来说，内部类是很少用来作为继承用的。但是当用来继承的话，要注意两点：</p>
<ol>
<li>成员内部类的引用方式必须为 Outter.Inner.</li>
<li>构造器中必须有指向外部类对象的引用，并通过这个引用调用super()。这段代码摘自《Java编程思想》</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WithInner</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InheritInner</span> <span class="keyword">extends</span> <span class="title class_">WithInner</span>.Inner &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// InheritInner() 是不能通过编译的，一定要加上形参</span></span><br><span class="line">    InheritInner(WithInner wi) &#123;</span><br><span class="line">        wi.<span class="built_in">super</span>(); <span class="comment">//必须有这句调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">WithInner</span> <span class="variable">wi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WithInner</span>();</span><br><span class="line">        <span class="type">InheritInner</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InheritInner</span>(wi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>使用泛型简化findViewById</title>
    <url>/2018/09/26/%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E7%AE%80%E5%8C%96findViewById/</url>
    <content><![CDATA[<h3 id="简化findViewById"><a href="#简化findViewById" class="headerlink" title="简化findViewById"></a>简化findViewById</h3><p>在Android开发中，通过findViewById来引用资源文件的view，但是资源文件的view过多会导致做很多重复性的工作，代码很冗余，开发效率随之下降。为了减少重复书写findViewById的次数，我们可以这么来写。　　　</p>
 <span id="more"></span>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ViewUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  &lt;T <span class="keyword">extends</span> <span class="title class_">View</span>&gt; T <span class="title function_">findViewById</span><span class="params">(Activity activity,<span class="type">int</span> resId)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) activity.findViewById(resId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">View</span>&gt; T <span class="title function_">findViewById</span><span class="params">(View view,<span class="type">int</span> resId)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) view.findViewById(resId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>通过使用泛型，可以避免了每次都进行类型转换，很大程度的简化了代码，开发效率也随之提升了。</p>
</blockquote>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>在Ubuntu中安装和美化ZSH Shell</title>
    <url>/2018/07/16/%E5%9C%A8Ubuntu%E4%B8%AD%E5%AE%89%E8%A3%85%E5%92%8C%E7%BE%8E%E5%8C%96ZSH%20Shell/</url>
    <content><![CDATA[<blockquote>
<p>ZSH 或称 Z Shell 是一个类似于 Bash 和 SH 的 Linux Shell，它具有一些 Bash 和其它 Shell 不具备的高级功能。流行的 Git 版本控制系统也可以使用插件与 ZSH 很好的集成，这一点对软件开发人员来说非常有用。而且 ZSH 有非常多的主题和插件支持，比 Bash 更具可定制性。简单来说，ZSH 就是一款替代 Bash 且非常好用的 Linux Shell。</p>
</blockquote>
<span id="more"></span>

<h3 id="安装ZSH-Shell"><a href="#安装ZSH-Shell" class="headerlink" title="安装ZSH Shell"></a>安装ZSH Shell</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install zsh</span><br></pre></td></tr></table></figure></div>

<h3 id="设置为默认Shell"><a href="#设置为默认Shell" class="headerlink" title="设置为默认Shell"></a>设置为默认Shell</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">whereis zsh</span><br><span class="line">sudo usermod -s /usr/bin/zsh $(whoami)</span><br></pre></td></tr></table></figure></div>

<p>现在使用 reboot 或 init 6 命令重新启动 Ubuntu 计算机。</p>
<p>重启后，打开终端，输入<code>数字 2</code>，ZSH 会使用推荐的设置创建一个新的 ~&#x2F;.zshrc 配置文件，此后就可以正常使用 ZSH Shell 了。</p>
<h3 id="安装Powerline和Powerline字体"><a href="#安装Powerline和Powerline字体" class="headerlink" title="安装Powerline和Powerline字体"></a>安装Powerline和Powerline字体</h3><p>「Powerline」是 ZSH Shell 的状态行插件，「Powerline 字体」也允许 ZSH 在 Shell 中使用不同的图标和符号。而「Powerline」和「Powerline 字体」也可以在 Ubuntu 的官方软件包存储库中找到。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install powerline fonts-powerline</span><br></pre></td></tr></table></figure></div>

<h3 id="ZSH、Git与「Oh-My-ZSH」集成"><a href="#ZSH、Git与「Oh-My-ZSH」集成" class="headerlink" title="ZSH、Git与「Oh My ZSH」集成"></a>ZSH、Git与「Oh My ZSH」集成</h3><p>安装 Git</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install git</span><br></pre></td></tr></table></figure></div>

<p>Git 安装好之后，请执行以下命令在 Ubuntu 系统中安装「Oh My ZSH」</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sh -c &quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>注意：安装「Oh My ZSH」会自动更改 ~&#x2F;.zshrc 配置文件，这意味着安装的 ZSH Syntax Highlighting 插件将会被禁用。可以在「Oh My ZSH」安装好之后执行zsh的相关命令，重新启用 ZSH Syntax Highlighting 插件。</p>
</blockquote>
<h3 id="启用语法高亮显示"><a href="#启用语法高亮显示" class="headerlink" title="启用语法高亮显示"></a>启用语法高亮显示</h3><p>使用它可以突出显示 ZSH Shell 中的命令</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install zsh-syntax-highlighting</span><br></pre></td></tr></table></figure></div>

<p>将<code>/usr/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh</code>目录下在读文件复制到<code>~/.oh-my-zsh/plugins/zsh-syntax-highlighting</code>目录下，然后编辑<code>~/.zshrc</code>文件，在最末尾加入<code>source ~/.oh-my-zsh/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh</code>。</p>
<p>打开一个新的「终端」窗口开始输入命令，应该就可以看到命令以不同的颜色突出、高亮显示。</p>
<h3 id="自动补齐插件"><a href="#自动补齐插件" class="headerlink" title="自动补齐插件"></a>自动补齐插件</h3><p>下载此插件，<a class="link"   href="http://mimosa-pudica.net/zsh-incremental.html" >插件官网 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">cd /temp</span><br><span class="line">wget http://mimosa-pudica.net/src/incr-0.2.zsh</span><br></pre></td></tr></table></figure></div>

<p>将此插件放到oh-my-zsh目录的插件库下 <code>~/.oh-my-zsh/plugins/incr</code>。</p>
<p>在<code>~/.zshrc</code>文件末尾加上</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">source ~/.oh-my-zsh/plugins/incr/incr-0.2.zsh</span><br></pre></td></tr></table></figure></div>

<h3 id="更新配置"><a href="#更新配置" class="headerlink" title="更新配置"></a>更新配置</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">source ~/.zshrc   </span><br></pre></td></tr></table></figure></div>

<h3 id="优化zsh的配置"><a href="#优化zsh的配置" class="headerlink" title="优化zsh的配置"></a>优化zsh的配置</h3><p>修改<code>~/.zshrc</code>文件</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">zhs的主题</span></span><br><span class="line">ZSH_THEME=&quot;ys&quot;	</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">z命令快速跳转目录     x命令解压一切文件         命令行可以直接google</span>  </span><br><span class="line">plugins=(</span><br><span class="line">  git z zsh-autosuggestions extract web-search zsh-syntax-highlighting </span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>

<h3 id="与vim的提示相冲突的解决方案"><a href="#与vim的提示相冲突的解决方案" class="headerlink" title="与vim的提示相冲突的解决方案"></a>与vim的提示相冲突的解决方案</h3><p>使用自动补全插件可能会与vim的提示功能相冲突，如会报以下错误：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">vim t</span><br><span class="line">_arguments:451: _vim_files: function definition file not found</span><br></pre></td></tr></table></figure></div>

<p>解决方法：将~&#x2F;.zcompdump*删除即可</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">rm -rf ~/.zcompdump*</span><br><span class="line">exec zsh</span><br></pre></td></tr></table></figure></div>



]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>失业保险金和失业补助金的区别</title>
    <url>/2023/03/14/%E5%A4%B1%E4%B8%9A%E4%BF%9D%E9%99%A9%E9%87%91%E5%92%8C%E5%A4%B1%E4%B8%9A%E8%A1%A5%E5%8A%A9%E9%87%91%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/2134234.jpg"
                     
                ></p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>失业</tag>
      </tags>
  </entry>
  <entry>
    <title>如何防止QQ轻聊版强制升级TIM</title>
    <url>/2019/04/28/%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2QQ%E8%BD%BB%E8%81%8A%E7%89%88%E5%BC%BA%E5%88%B6%E5%8D%87%E7%BA%A7TIM/</url>
    <content><![CDATA[<p>QQ主要使用以下2个升级程序来自动升级：</p>
<span id="more"></span>

<blockquote>
<p>txupd.exe<br>QQProtectUpd.exe<br>bugreport.exe</p>
</blockquote>
<p>点击 Win 键，键盘输入 <code>gpedit.msc</code>, 回车，定位到 <code>用户配置</code> - <code>管理模版</code> - <code>系统</code> - <code>不要运行特定的Windows 应用</code> :</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/21342342.png"
                      alt="插图1"
                ></p>
<p>双击 <code>不要运行特定的Windows 应用</code> ， 将其 <code>启用</code>，并且在下面的 <code>列表</code> 中添加上面提到的2个程序名称，然后保存即可。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/3284653.png"
                      alt="插图2"
                ></p>
<p>后续 QQ 将无法启动这两个程序，也就不会弹窗提醒，更不会给你悄悄的升级了。</p>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>正确为Android Studio配置ssr代理</title>
    <url>/2019/09/12/%E6%AD%A3%E7%A1%AE%E4%B8%BAAndroid%20Studio%E9%85%8D%E7%BD%AEssr%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<p>打开Android Studio，进入Preferences，搜索proxy关键字，进入proxy设置页面。</p>
 <span id="more"></span>
<p>打开本地代理软件SS，等其他socks代理软件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/4352353.png"
                     
                ></p>
<p>但是这样只能下载sdk，这样配置之后有没有发现我们使用Gradle下载某些依赖的时候还是下载不下来，因为gradle不支持socks代理，这里我们可以将socks转为http代理，或者给jvm设置代理</p>
<p>在AS中我们可以直接给JVM设置代理</p>
<div class="highlight-container" data-rel="Groovy"><figure class="iseeu highlight groovy"><table><tr><td class="code"><pre><span class="line">org.gradle.jvmargs=-DsocksProxyHost=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> -DsocksProxyPort=<span class="number">1080</span></span><br></pre></td></tr></table></figure></div>

<p>这里的端口要根据你自己代理的端口变化，一般都是1080</p>
<p>在我们的跟目录的 gradle.properties 加上上面配置就可以下载了。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建Samba文件共享服务端</title>
    <url>/2019/04/11/%E6%90%AD%E5%BB%BASamba%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB%E6%9C%8D%E5%8A%A1%E7%AB%AF/</url>
    <content><![CDATA[<p><code>Samba</code> 是著名的开源软件项目之一，它在 <code>Linux/UNIX</code> 系统中实现了微软的 <code>SMB/CIFS</code> 网络协议，从而使得跨平台的文件共享变得更加容易。在部署 Windows、Linux&#x2F;UNIX 混合平台的企业环境时，选用 <code>Samba</code> 可以很好地解决不同系统之间的文件互访问题。</p>
 <span id="more"></span>

<h1 id="开始准备"><a href="#开始准备" class="headerlink" title="开始准备"></a>开始准备</h1><p>Windows电脑和服务器主机必须在相同的工作站域下，打开命令提示符检查Windows系统所在的工作站域</p>
<div class="highlight-container" data-rel="Powershell"><figure class="iseeu highlight powershell"><table><tr><td class="code"><pre><span class="line">net config workstation</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/3456543.png"
                     
                ></p>
<p>在Windows系统中，修改 hosts 文件，以<code>管理员权限</code>打开命令提示符，并运行以下命令</p>
<div class="highlight-container" data-rel="Powershell"><figure class="iseeu highlight powershell"><table><tr><td class="code"><pre><span class="line">notepad C:\Windows\System32\drivers\etc\hosts</span><br></pre></td></tr></table></figure></div>

<p>例如：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">[...]</span><br><span class="line">192.168.0.100 	server1.example.com	ubuntu</span><br></pre></td></tr></table></figure></div>

<h1 id="安装-samba-软件包"><a href="#安装-samba-软件包" class="headerlink" title="安装 samba 软件包"></a>安装 <code>samba</code> 软件包</h1><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install samba -y</span><br></pre></td></tr></table></figure></div>

<p>备份samba的配置文件，方便出错的时候恢复初始设置</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo cp /etc/samba/smb.conf /etc/samba/smb.conf.bak</span><br></pre></td></tr></table></figure></div>

<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="编辑-etc-samba-smb-conf-文件："><a href="#编辑-etc-samba-smb-conf-文件：" class="headerlink" title="编辑 /etc/samba/smb.conf 文件："></a>编辑 <code>/etc/samba/smb.conf</code> 文件：</h2><p>在 <code>[global]</code> 节点下添加以下键值对：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">workgroup = WORKGROUP</span><br><span class="line">security = user</span><br></pre></td></tr></table></figure></div>

<h2 id="在文件的最末尾添加新的节点："><a href="#在文件的最末尾添加新的节点：" class="headerlink" title="在文件的最末尾添加新的节点："></a>在文件的最末尾添加新的节点：</h2><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">[SambaShare]</span><br><span class="line">    comment = Ubuntu File Server Share   #描述和介绍</span><br><span class="line">    path = /srv/samba/share   #请添加需要的路径</span><br><span class="line">    browsable = yes   #能够被 Windows Explorer 浏览文件或文件夹</span><br><span class="line">    guest ok = yes    #任何用户都可以访问</span><br><span class="line">    read only = no    #Windows Explorer 拥有读写权限</span><br><span class="line">    create mask = 0777  #当文件被创建的时候，被赋予的默认权限</span><br><span class="line">　　 valid users = tom       # 指定登录的用户，该项不写，则默认对所有人可见</span><br><span class="line">　　 force user = nobody     # 指定的用户可以进行登录，其他用户没有权限登录，nobody不限制</span><br><span class="line">　 　force group = nogroup   # 同上，指定用户组</span><br><span class="line">　　 public = yes            # 是否对所有登录成功的用户可见</span><br><span class="line">　　 writable = yes          # 写权限，目录的权限也要许可</span><br><span class="line">　　 available = yes         # 同样是设置共享目录是否可见</span><br></pre></td></tr></table></figure></div>

<h2 id="创建待共享的文件夹路径，并赋予权限："><a href="#创建待共享的文件夹路径，并赋予权限：" class="headerlink" title="创建待共享的文件夹路径，并赋予权限："></a>创建待共享的文件夹路径，并赋予权限：</h2><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /srv/samba/share  #如果父文件夹不存在，则创建父文件夹</span><br><span class="line">sudo chown nobody:nogroup /srv/samba/share/</span><br></pre></td></tr></table></figure></div>

<h2 id="创建Samba用户"><a href="#创建Samba用户" class="headerlink" title="创建Samba用户"></a>创建Samba用户</h2><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo smbpasswd -a tom</span><br></pre></td></tr></table></figure></div>

<p>然后输入密码即可</p>
<h2 id="重启-samba-系统服务让配置生效"><a href="#重启-samba-系统服务让配置生效" class="headerlink" title="重启 samba 系统服务让配置生效"></a>重启 <code>samba</code> 系统服务让配置生效</h2><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart smbd.service nmbd.service</span><br></pre></td></tr></table></figure></div>

<h2 id="设置访问权限"><a href="#设置访问权限" class="headerlink" title="设置访问权限"></a>设置访问权限</h2><p>再次强调，以上配置，在局域网内所有的访问客户端都被赋予了所有权限，如果需要配置访问权限，请按照以下说明修改：</p>
<ul>
<li><h3 id="编辑-etc-samba-smb-conf"><a href="#编辑-etc-samba-smb-conf" class="headerlink" title="编辑 /etc/samba/smb.conf"></a>编辑 <code>/etc/samba/smb.conf</code></h3></li>
<li><h3 id="添加以下网络配置："><a href="#添加以下网络配置：" class="headerlink" title="添加以下网络配置："></a>添加以下网络配置：</h3></li>
</ul>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hosts allow = 127.0.0.1 192.168.1.0/24</span></span><br><span class="line">hosts allow = 127.0.0.1 192.168.1.1 192.168.1.2</span><br><span class="line">hosts deny = 0.0.0.0/0    #拒绝其他所有人</span><br></pre></td></tr></table></figure></div>

<ul>
<li><h3 id="分享权限："><a href="#分享权限：" class="headerlink" title="分享权限："></a>分享权限：</h3></li>
</ul>
<p>browseable &#x3D; no ，代表当客户端访问的时候，无法浏览文件或文件夹</p>
<p>users &#x3D; user1 user2 ，代表仅列出的用户可以访问此分享 </p>
<p>可以参考如下配置：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">[private]</span><br><span class="line">        comment = Private Share</span><br><span class="line">        path = /path/to/share/point</span><br><span class="line">        browseable = no</span><br><span class="line">        read only = no</span><br><span class="line">        valid users = user1 user2 user3  # user1 user2和user3 访问私有分享</span><br></pre></td></tr></table></figure></div>

<h2 id="设置防火墙"><a href="#设置防火墙" class="headerlink" title="设置防火墙"></a>设置防火墙</h2><p>可以配置防火墙（如 <code>iptables</code> ）来限制访问你的服务器，<code>Samba</code> 使用以下端口</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">UDP : 137 和 138</span><br><span class="line">TCP : 139 和 445</span><br></pre></td></tr></table></figure></div>

<h1 id="查看效果"><a href="#查看效果" class="headerlink" title="查看效果"></a>查看效果</h1><p>在Windows下通过samba访问服务器内容</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/1231232.png"
                     
                ></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>网页版HTML5视频倍速播放方法</title>
    <url>/2018/11/17/%E7%BD%91%E9%A1%B5%E7%89%88HTML5%E8%A7%86%E9%A2%91%E5%80%8D%E9%80%9F%E6%92%AD%E6%94%BE%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>仅支持的浏览器有Chrome 43+、 Firefox 20+、 IE 9+、 Edge 12+等版本。</p>
 <span id="more"></span>

<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">document.querySelector(&#x27;video&#x27;).defaultPlaybackRate = 2.0;</span><br><span class="line">document.querySelector(&#x27;video&#x27;).play();</span><br><span class="line">document.querySelector(&#x27;video&#x27;).playbackRate = 16.0;</span><br></pre></td></tr></table></figure></div>


]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>禁止电脑版钉钉软件提示升级</title>
    <url>/2019/06/15/%E7%A6%81%E6%AD%A2%E7%94%B5%E8%84%91%E7%89%88%E9%92%89%E9%92%89%E8%BD%AF%E4%BB%B6%E6%8F%90%E7%A4%BA%E5%8D%87%E7%BA%A7/</url>
    <content><![CDATA[<p>在路径 <code>C:\Windows\System32\drivers\etc</code> 以<strong>管理员身份</strong>打开 <code>hosts</code> ，添加以下内容：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1     im.dingtalk.com</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈对java多态的理解</title>
    <url>/2018/09/28/%E8%B0%88%E8%B0%88%E5%AF%B9java%E5%A4%9A%E6%80%81%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>运行时多态性是面向对象程序设计代码重用的一个最强大机制，Java多态性的概念也可以被说成“一个接口，多个方法”。Java实现运行时多态性的基础是动态方法调度，它是一种在运行时而不是在编译期调用重载方法的机制。</p>
<span id="more"></span>

<p>方法的重写<code>Overriding</code>和重载<code>Overloading</code>是Java多态性的不同表现。重写<code>Overriding</code>是父类与子类之间多态性的一种表现，重载<code>Overloading</code>是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写(<code>Overriding</code>)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“屏蔽”了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(<code>Overloading</code>)。<code>Overloaded</code>的方法是可以改变返回值的类型。方法的重写<code>Overriding</code>和重载<code>Overloading</code>是Java多态性的不同表现。重写<code>Overriding</code>是父类与子类之间多态性的一种表现，重载<code>Overloading</code>是一个类中Java多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (<code>Overriding</code>)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“屏蔽”了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(<code>Overloading</code>)。<code>Overloaded</code>的方法是可以改变返回值的类型。</p>
<p>当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。 （但是如果强制把超类转换成子类的话，就可以调用子类中新添加而超类没有的方法了。）</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>超五类和六类网线的区别</title>
    <url>/2019/05/17/%E8%B6%85%E4%BA%94%E7%B1%BB%E5%92%8C%E5%85%AD%E7%B1%BB%E7%BD%91%E7%BA%BF%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>网线，电脑网络组成的最不起眼的部分，最容易被忽视的部件。在组建网络时，人们大多会重视如交换机、路由器、网卡等设备，但对于网线，一般不会太多的去挑剔。但随着网络规模的扩大，对网线需求的增加，网线的重要性越来越明显。下面一起来了解下网线基本知识，告诉你什么样的网线好，超五类和六类网线区别。</p>
 <span id="more"></span>

<h2 id="了解网线小常识-网线的种类"><a href="#了解网线小常识-网线的种类" class="headerlink" title="了解网线小常识-网线的种类"></a>了解网线小常识-网线的种类</h2><h3 id="双绞线（Twisted-Pair）"><a href="#双绞线（Twisted-Pair）" class="headerlink" title="双绞线（Twisted Pair）"></a>双绞线（Twisted Pair）</h3><h4 id="网线的种类"><a href="#网线的种类" class="headerlink" title="网线的种类"></a>网线的种类</h4><p><strong>双绞线（twisted pair，TP）</strong>是一种综合布线工程中最常用的传输介质，一般由两根22～26号绝缘铜导线相互缠绕而成，<code>双绞线</code>的名字也是由此而来。它的特点就是价格便宜，所以被广泛应用，如我们常见的电话线等。它是用来和<code>RJ45</code>水晶头相连的。 </p>
<p>双绞线可分为<code>非屏蔽双绞线（UTP）</code>和<code>屏蔽双绞线（STP）</code>：</p>
<ol>
<li><p><strong>屏蔽双绞线</strong>电缆的外层由铝铂包裹，以减小辐射，但并不能完全消除辐射，屏蔽双绞线价格相对较高，安装时要比非屏蔽双绞线电缆困难。 </p>
</li>
<li><p><strong>非屏蔽双绞线</strong>电缆具有以下优点：无屏蔽外套，直径小，节省所占用的空间；重量轻，易弯曲，易安装；将近端串扰减至最小或加以消除；具有阻燃性；具有独立性和灵活性，适用于结构化综合布线。</p>
</li>
</ol>
<h4 id="双绞线常见的型号"><a href="#双绞线常见的型号" class="headerlink" title="双绞线常见的型号"></a>双绞线常见的型号</h4><p><strong>一类线（CAT1）</strong>：主要用于传输语音（一类标准主要用于八十年代初之前的电话线缆），不同于数据传输。 </p>
<p><strong>二类线（CAT2）</strong>：传输频率为1MHZ，用于语音传输和最高传输速率4Mbps的数据传输，常见于使用4MBPS规范令牌传递协议的旧的令牌网。 </p>
<p><strong>三类线（CAT3）</strong>：传输频率16MHz，用于语音传输及最高传输速率为10Mbps的数据传输主要用于10BASE–T，在ANSI和EIA&#x2F;TIA568标准中指定的电缆。</p>
<p><strong>四类线（CAT4）</strong>：传输频率为20MHz，用于语音传输和最高传输速率16Mbps的数据传输主要用于基于令牌的局域网和10BASE-T&#x2F;100BASE-T。 </p>
<p><strong>五类线（CAT5）</strong>：传输频率为100MHz，用于语音传输和最高传输速率为100Mbps的数据传输，主要用于100BASE-T和10BASE-T网络。这是最常用的以太网电缆，该类电缆增加了绕线密度，外套一种高质量的绝缘材料。 </p>
<p><strong>超五类线（CAT5e）</strong>：传输频率为100MHz，主要用于千兆位以太网（1000Mbps）。具有衰减小，串扰少，并且具有更高的衰减与串扰的比值（ACR)和信噪比（StructuralReturn Loss)、更小的时延误差，性能得到很大提高。 </p>
<p><strong>六类线（CAT6）</strong>：传输频率为250MHz，最适用于传输速率高于1Gbps的应用，主要用于千兆位以太网（1000Mbps）。六类双绞线在外形上和结构上与五类或超五类双绞线都有一定的差别，不仅增加了绝缘的十字骨架，将双绞线的四对线分别置于十字骨架的四个凹槽内，而且电缆的直径也更粗。</p>
<p><strong>超六类或6A（CAT6A）</strong>：传输频率是200～250 MHz，最大传输速度也可达到1000 Mbps，主要应用于千兆位网络中。超六类线是六类线的改进版，同样是ANSI&#x2F;EIA&#x2F;TIA-568B.2和ISO 6类&#x2F;E级标准中规定的一种非屏蔽双绞线电缆，在串扰、衰减和信噪比等方面有较大改善。 </p>
<p><strong>七类线（CAT7）</strong>：传输频率至少可达500 MHz，传输速率可达10 Gbps，它主要为了适应万兆位以太网技术的应用和发展。该线是ISO 7类&#x2F;F级标准中最新的一种屏蔽双绞线。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/324231.jpeg"
                     
                ></p>
<h4 id="超五类和六类网线区别"><a href="#超五类和六类网线区别" class="headerlink" title="超五类和六类网线区别"></a>超五类和六类网线区别</h4><p>超五类和六类网线连接使用并无不同，只是使用的场合和成本不一样。 </p>
<p><strong>超五类线</strong>的标识是“CAT5E”，带宽155M，是目前的主流产品； </p>
<p><strong>六类线</strong>的标识是“ CAT6”，带宽250M，六类非屏蔽双绞线可以非常好地支持千兆以太网，并实现100m的传输距离。六类布线系统被广泛应用子服务器机房的布线，以及保留升级至千兆以太网能力的水平布线。六类非屏蔽双绞线虽然价格较高，但由于与超五类布线系统具有非常好的兼容性，且能够非常好地支持1000Base-T，所以正慢慢成为综合布线的新宠。 </p>
<p>若考虑网络将来的应用需求，理论上应安装最先进的布线产品，因为安装电缆后往往难以重新更新替代，基本上，一个布线系统至少要应用10年作为标准，能够支持4至5代的网络设备的性能更新，如果将来的网络设备需要更好的电缆才能提高数据速度。那么，用六类电缆代替超五类电缆是无可避免的，但这些电缆重新组建工程非常昂贵，所以纵使六类产品的价格相对于超五类产品稍贵，但为了减少日后网络升级问题，六类产品仍然值得考虑。</p>
<h3 id="同轴电缆（Coaxial-Cable）"><a href="#同轴电缆（Coaxial-Cable）" class="headerlink" title="同轴电缆（Coaxial Cable）"></a>同轴电缆（Coaxial Cable）</h3><h4 id="网线的种类-1"><a href="#网线的种类-1" class="headerlink" title="网线的种类"></a>网线的种类</h4><p>**同轴电缆(Coaxial Cable)**是指有两个同心导体，而导体和屏蔽层又共用同一轴心的电缆。最常见的同轴电缆由绝缘材料隔离的铜线导体组成，在里层绝缘材料的外部是另一层环形导体及其绝缘体，然后整个电缆由聚氯乙烯或特氟纶材料的护套包住。</p>
<h3 id="光缆（Optical-Fiber-Cable）"><a href="#光缆（Optical-Fiber-Cable）" class="headerlink" title="光缆（Optical Fiber Cable）"></a>光缆（Optical Fiber Cable）</h3><h4 id="网线的种类-2"><a href="#网线的种类-2" class="headerlink" title="网线的种类"></a>网线的种类</h4><p>**光缆(optical fiber cable)**是为了满足光学、机械或环境的性能规范而制造的，它是利用置于包覆护套中的一根或多根光纤作为传输媒质并可以单独或成组使用的通信线缆组件。光缆是一定数量的光纤按照一定方式组成缆心，外包有护套，有的还包覆外护层，用以实现光信号传输的一种通信线路。</p>
<h2 id="掌握网络选购方法-确保上网质量"><a href="#掌握网络选购方法-确保上网质量" class="headerlink" title="掌握网络选购方法 确保上网质量"></a>掌握网络选购方法 确保上网质量</h2><h3 id="网线材质哪种好"><a href="#网线材质哪种好" class="headerlink" title="网线材质哪种好"></a>网线材质哪种好</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/2134232.jpeg"
                     
                ></p>
<h4 id="铜包铁线"><a href="#铜包铁线" class="headerlink" title="铜包铁线"></a>铜包铁线</h4><p>此类网线在铁线外面电镀了一层铜，因为趋肤效应，对铁线的导电能力有一定提升，电阻较大，不适合POE供电。</p>
<h4 id="铁芯线"><a href="#铁芯线" class="headerlink" title="铁芯线"></a>铁芯线</h4><p>铁芯线此类网线电阻较大，不适合POE供电，仅适合短距离内传输且对网速要求不高的情况下使用。</p>
<h4 id="混合性线材"><a href="#混合性线材" class="headerlink" title="混合性线材"></a>混合性线材</h4><p>混合性线材里面部分线使用铜，部分线使用铝，仅适合短距离使用，可用于POE供电，水晶头接法严格。</p>
<h3 id="网线哪种好-网线选购方法"><a href="#网线哪种好-网线选购方法" class="headerlink" title="网线哪种好 网线选购方法"></a>网线哪种好 网线选购方法</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/234234.jpeg"
                     
                ></p>
<h2 id="交换机和猫的区别-交换机和路由器的区别"><a href="#交换机和猫的区别-交换机和路由器的区别" class="headerlink" title="交换机和猫的区别 交换机和路由器的区别"></a>交换机和猫的区别 交换机和路由器的区别</h2><h3 id="家庭网络与办公网络区别"><a href="#家庭网络与办公网络区别" class="headerlink" title="家庭网络与办公网络区别"></a>家庭网络与办公网络区别</h3><p>家庭中大多使用双绞线(即一般的网线)，一般分为<strong>T568A</strong>和<strong>T568B</strong>两种线序，信息模块端接入方式分<strong>T568A模块</strong>和<strong>T568B模块</strong>两种方式，两种端接方式所对应的接线顺序如下： </p>
<p><strong>T586A模式</strong> ：白绿 、绿 、白橙 、蓝 、白蓝 、橙 、白棕 、棕</p>
<p><strong>T586B模式</strong> ：白橙 、橙 、白绿 、蓝 、白蓝 、绿 、白棕 、棕</p>
<h3 id="家庭网线布线建议"><a href="#家庭网线布线建议" class="headerlink" title="家庭网线布线建议"></a>家庭网线布线建议</h3><p>在进行网络布线前，首先应该了解自己的居室环境及各房间的用途，什么地方可以开槽埋线，什么地方不可以？同时要了解家庭的网络需求，什么地方要上网？什么地方要看电视？自己心里要有数。</p>
<p>根据自己的设想来画出设计草图，然后根据房间的电源配电箱、有线电视进线口和电话线、网线入户口的位置，确定配电箱及分线器的位置。一般配电箱不要轻易移动；电话线及网络线的配线箱应选一个既不影响美观又方便操作的地方，考虑到要放路由器和交换机，所以应设计一个较大的配线箱；有线电视则在进线口设计一个能摆放两只电视分配器的盒子。</p>
<p>建议大家采用的是<strong>并联</strong>布线方式，并且<strong>电话线</strong>和<strong>网线</strong>分别采用<strong>4芯</strong>和<strong>8芯（五类线）</strong>线，为了方便，电话线和网络线穿在同一根PVC管内（理论上电话线和网络线应分开布线，间距10cm以避免相互干扰），考虑到家庭电话和网络同时使用的时间很短，不会造成大的干扰。假如有多台电脑要同时上网时，只要在总配线处加一个宽带路由器或交换机即可。</p>
<h3 id="办公室网络布线建议"><a href="#办公室网络布线建议" class="headerlink" title="办公室网络布线建议"></a>办公室网络布线建议</h3><p><strong>综合性</strong>：办公室布线需要满足各种不同模拟或数字信号的传输需求，将所有的语言、数据、图象、监控设备的布线组合在一套标准的布线系统上，设备与信息出口之间只需一根标准的连接线通过标准的接口把它们接通即可。 </p>
<p><strong>可靠性</strong>：办公室布线系统使用的产品必须要通过国际组织认证，布线系统的设计、安装、测试以ANSI EIA&#x2F;TIA 568A及GB&#x2F;T50311-200为布线标准、遵循国内的布线规范和测试规范。 </p>
<p><strong>灵活性</strong>：每个办公地点到底使用多少个信息点，办公室布线不仅满足用户当前需求，也要符合用户对未来信息系统统的期望；而且数据、语音双绞线布线应具有可换性，构成一套完整的布线系统。</p>
<p><strong>合理性</strong>：办公室强弱电的布线走向要合理搭配，互不干扰，而且要外形美观；用户同时使用计算机的电源、电话、网线要方便操作、便于以后的运行维护。 </p>
<p><strong>有线和无线的互补性</strong>：根据大楼的具体建筑环境和办公要求，长期还是临时使用网络等情况下，决定采用有线的布线还是无线；一般来说，是将有线和无线结合起来，发挥各自的特长，来达到我们上网办公的目的。</p>
<h3 id="网线插座接法"><a href="#网线插座接法" class="headerlink" title="网线插座接法"></a>网线插座接法</h3><p>用剥线工具或压线钳的刀具在离线头10厘米长左右将双绞线的外包皮剥去，露出四对双绞线。开始打线，先不要拆开各线对，在将相应线对预先压入打线柱时才拆开。</p>
<p>按照信息模块上所指示的色标选择我们偏好的线序模式(在一个布线系统中最好只统一采用一种线序模式，否则接乱了，网络不通则很难查)。将全部的线都压进各槽位后，用工具压住模块和线，用力压下去，将线卡在模块里面，并把多余的先头剪掉。就是将打好线的信息模块装到86盒面板上，这样墙壁网线插座就安装好了。</p>
<h2 id="网线和电话线的区别-网线和电话线共用"><a href="#网线和电话线的区别-网线和电话线共用" class="headerlink" title="网线和电话线的区别 网线和电话线共用"></a>网线和电话线的区别 网线和电话线共用</h2><h3 id="网线和电话线的区别"><a href="#网线和电话线的区别" class="headerlink" title="网线和电话线的区别"></a>网线和电话线的区别</h3><h4 id="作用不同"><a href="#作用不同" class="headerlink" title="作用不同"></a>作用不同</h4><ol>
<li><p>电话线通过ADSL，将电脑的数字信号调制成模拟线号通过电话线传播，到对端就是电信那边以后，再把模拟信号解调成数字信号。网线上网则少了调制解调这一步。</p>
</li>
<li><p>带宽问题。电话线受物理带宽影响，一般带宽不会太高（最大宽带值为8M），网线物理带宽比较高（好的网线可以达到1000M甚至更多）</p>
</li>
</ol>
<h4 id="接口不同"><a href="#接口不同" class="headerlink" title="接口不同"></a>接口不同</h4><p>为什么用猫连接的都是电话接口，而网线接口连上去都没什么反应的，这是因为从电话线过来的信号，要经过猫的转换和处理才能转发给网络设备，比如转发给电脑、路由器、集线器和交换机等。如果直接接上去的话那么就是无法识别的模拟信号，相当于无信号。</p>
<p>换言之，猫在中间起到的作用，就是信号的转换和简单的处理，具体说就是将电话线过来的模拟信号转换成数字信号交给网络设备，将网络设备发送的数字信号转换为模拟信号通过电话线发出去。</p>
<h4 id="网线和电话线共用好吗"><a href="#网线和电话线共用好吗" class="headerlink" title="网线和电话线共用好吗"></a>网线和电话线共用好吗</h4><p>选择网线和电话线共用一根网线的方法在中小企业尤其是小型企业的网络系统中常见。一些网络管理者出于为企业节约综合布线的资金的考虑，在电话和网络方面做了中和，选择网线和电话线共用一根网线的方法作为现行状况的解决方案。</p>
<p>为避免后期管理以及维护及排除故障考虑，不建议电话和网络公用一根网线。</p>
<h2 id="网络常见故障分析及处理"><a href="#网络常见故障分析及处理" class="headerlink" title="网络常见故障分析及处理"></a>网络常见故障分析及处理</h2><h3 id="线路故障"><a href="#线路故障" class="headerlink" title="线路故障"></a>线路故障</h3><p>线路故障最常见的情况就是线路不通，诊断这种故障可用ping检查线路远端的路由器端口是否还能响应，或检测该线路上的流量是否还存在。一旦发现远端路由器端口不通，或该线路没有流量，则该线路可能出现了故障。</p>
<p>这时有几种处理方法。</p>
<p>首先是ping线路两端路由器端口，检查两端的端口是否关闭了。如果其中一端端口没有响应则可能是路由器端口故障。如果是近端端口关闭，则可检查端口插头是否松动，路由器端口是否处于down的状态；如果是远端端口关闭，则要通知线路对方进行检查。进行这些故障处理之后，线路往往就通畅了。</p>
<p>如果线路仍然不通，一种可能就得线路本身的问题，看是否线路中间被切断；另一种可能就是路由器配置出错，比如路由循环了。就是远端端口路由又指向了线路的近端，这样线路远端连接的网络用户就不通了，这种故障可以用traceroute来诊断。解决路由循环的方法就是重新配置路由器端口的静态路由或动态路由。</p>
<h3 id="路由器故障"><a href="#路由器故障" class="headerlink" title="路由器故障"></a>路由器故障</h3><p>事实上，线路故障中很多情况都涉及到路由器，因此也可以把一些线路故障归结为路由器故障。</p>
<p>但线路涉及到两端的路由器，因此在考虑线路故障是要涉及到多个路由器。有些路由器故障仅仅涉及到它本身，这些故障比较典型的就是路由器CPU温度过高、CPU利用率过高和路由器内存余量太小。其中最危险的是路由器CPU温度过高，因为这可能导致路由器烧毁。而路由器CPU利用率过高和路由器内存余量太小都将直接影响到网络服务的质量，比如路由器上丢包率就会随内存余量的下降而上升。</p>
<p>检测这种类型的故障，需要利用MIB变量浏览器这种工具，从路由器MIB变量中读出有关的数据，通常情况下网络管理系统有专门的管理进程不断地检测路由器的关键数据，并及时给出报警。而解决这种故障，只有对路由器进行升级、扩内存等，或者重新规划网络的拓扑结构。</p>
<p>另一种路由器故障就是自身的配置错误。比如配置的协议类型不对，配置的端口不对等。这种故障比较少见，在使用初期配置好路由器基本上就不会出现了。</p>
<h3 id="主机故障"><a href="#主机故障" class="headerlink" title="主机故障"></a>主机故障</h3><p>主机故障常见的现象就是主机的配置不当。比如，主机配置的IP地址与其他主机冲突，或IP地址根本就不在子网范围内，这将导致该主机不能连通。</p>
<p>如某网段范围是172.17.14.1—172.17.14.253，所以主机地址只有设置在此段区间内才有效。还有一些服务设置的故障。比如E-Mail服务器设置不当导致不能收发E-Mail，或者域名服务器设置不当将导致不能解析域名。</p>
<p>主机故障的另一种可能是主机安全故障。比如，主机没有控制其上的finger，rpc，rlogin等多余服务。而恶意攻击者可以通过这些多余进程的正常服务或bug攻击该主机，甚至得到该主机的超级用户权限等。</p>
<h3 id="主机的其他故障"><a href="#主机的其他故障" class="headerlink" title="主机的其他故障"></a>主机的其他故障</h3><p>比如不当共享本机硬盘等，将导致恶意攻击者非法利用该主机的资源。发现主机故障是一件困难的事情，特别是别人恶意的攻击。一般可以通过监视主机的流量、或扫描主机端口和服务来防止可能的漏洞。</p>
<p>当发现主机受到攻击之后，应立即分析可能的漏洞，并加以预防，同时通知网络管理人员注意。现在，各市都安装了防火墙，如果防火墙地址权限设置不当，也会造成网络的连接故障，只要在设置使用防火墙时加以注意，这种故障就能解决。</p>
<h2 id="网线哪个牌子好"><a href="#网线哪个牌子好" class="headerlink" title="网线哪个牌子好"></a>网线哪个牌子好</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/12321123.jpeg"
                     
                ></p>
]]></content>
      <categories>
        <category>硬件</category>
      </categories>
      <tags>
        <tag>硬件</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云服务器完全卸载监控教程</title>
    <url>/2018/09/17/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%8C%E5%85%A8%E5%8D%B8%E8%BD%BD%E7%9B%91%E6%8E%A7%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>阿里云的服务器都自带监控（AliYunDun&#x2F;阿里云盾&#x2F;安骑士教程），大家都不想自己的所作所为都被监控着。<br> <span id="more"></span></p>
<h3 id="SSH连接阿里云服务器"><a href="#SSH连接阿里云服务器" class="headerlink" title="SSH连接阿里云服务器"></a>SSH连接阿里云服务器</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ssh root@[address]</span><br></pre></td></tr></table></figure></div>

<p>然后输入密码，即可。</p>
<h3 id="在终端中输入下方命令，进行卸载AliYunDun操作"><a href="#在终端中输入下方命令，进行卸载AliYunDun操作" class="headerlink" title="在终端中输入下方命令，进行卸载AliYunDun操作"></a>在终端中输入下方命令，进行卸载AliYunDun操作</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://update.aegis.aliyun.com/download/uninstall.sh &amp;&amp; chmod +x uninstall.sh &amp;&amp; ./uninstall.sh</span><br><span class="line">wget http://update.aegis.aliyun.com/download/quartz_uninstall.sh &amp;&amp; chmod +x quartz_uninstall.sh &amp;&amp; ./quartz_uninstall.sh</span><br></pre></td></tr></table></figure></div>

<h3 id="停止agentwatch-service服务（阿里云盾的监控进程）"><a href="#停止agentwatch-service服务（阿里云盾的监控进程）" class="headerlink" title="停止agentwatch.service服务（阿里云盾的监控进程）"></a>停止agentwatch.service服务（阿里云盾的监控进程）</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop agentwatch.service</span><br></pre></td></tr></table></figure></div>

<h3 id="禁止agentwatch-service服务启动"><a href="#禁止agentwatch-service服务启动" class="headerlink" title="禁止agentwatch.service服务启动"></a>禁止agentwatch.service服务启动</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl disable agentwatch.service</span><br></pre></td></tr></table></figure></div>

<h3 id="回到根目录"><a href="#回到根目录" class="headerlink" title="回到根目录"></a>回到根目录</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">cd /</span><br></pre></td></tr></table></figure></div>

<h3 id="删除agentwatch-service相关服务"><a href="#删除agentwatch-service相关服务" class="headerlink" title="删除agentwatch.service相关服务"></a>删除agentwatch.service相关服务</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">find . -name &#x27;agentwatch*&#x27; -type d -exec rm -rf &#123;&#125; \; &amp;&amp; find . -name &#x27;agentwatch*&#x27; -type f -exec rm -rf &#123;&#125; \;</span><br></pre></td></tr></table></figure></div>

<h3 id="强行停止aliyun-service服务"><a href="#强行停止aliyun-service服务" class="headerlink" title="强行停止aliyun-service服务"></a>强行停止aliyun-service服务</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">pkill aliyun-service</span><br></pre></td></tr></table></figure></div>

<h3 id="清理所有带aliyun、aegis关键字的文件"><a href="#清理所有带aliyun、aegis关键字的文件" class="headerlink" title="清理所有带aliyun、aegis关键字的文件"></a>清理所有带aliyun、aegis关键字的文件</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">find . -name &#x27;aliyun*&#x27; -type d -exec rm -rf &#123;&#125; \;</span><br><span class="line">find . -name &#x27;aliyun*&#x27; -type f -exec rm -rf &#123;&#125; \;</span><br><span class="line">find . -name &#x27;aegis*&#x27; -type f -exec rm -rf &#123;&#125; \;</span><br><span class="line">find . -name &#x27;aegis*&#x27; -type d -exec rm -rf &#123;&#125; \;</span><br><span class="line">rm -fr /usr/sbin/aliyun-service /usr/sbin/aliyun_installer</span><br></pre></td></tr></table></figure></div>

<h3 id="一些未触发关键字，但属于阿里云夹带私货的服务"><a href="#一些未触发关键字，但属于阿里云夹带私货的服务" class="headerlink" title="一些未触发关键字，但属于阿里云夹带私货的服务"></a>一些未触发关键字，但属于阿里云夹带私货的服务</h3><p>阿里云还偷偷内置了一堆服务，虽然没有注册到系统里且启动，但为了保险起见，还是将它们一并删除的比较好，有关内置服务的详情，参见：<a class="link"   href="https://gist.github.com/shui/748e436b92055634d2160367d0161c8d" >阿里云服务删除 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>可疑服务有以下几个，有5个位于&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;multi-user.target.wants&#x2F;目录下，均以“cloud-”打头的五个服务：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">find /etc/systemd/system/ -name &#x27;cloud-*&#x27; | xargs rm -rf</span><br></pre></td></tr></table></figure></div>

<p>还有一个是位于&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;目录下的“accounts-daemon.service”文件。<br><strong>注意</strong>，删除掉这个，你就无法通过阿里云控制台的VNC面板为机器修改ssh密码、查看机器的详细运行状态了，请谨慎决定是否需要删除（不推荐）：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">rm -fr /lib/systemd/system/accounts-daemon.service</span><br></pre></td></tr></table></figure></div>

<p>将以上组件删除后，阿里云后面板监控中的操作系统监控和进程监控都变为<strong>不可用</strong>。</p>
<h3 id="禁止所有与阿里云监控相关的IP访问"><a href="#禁止所有与阿里云监控相关的IP访问" class="headerlink" title="禁止所有与阿里云监控相关的IP访问"></a>禁止所有与阿里云监控相关的IP访问</h3><h4 id="利用阿里云安全组规则屏蔽相关IP"><a href="#利用阿里云安全组规则屏蔽相关IP" class="headerlink" title="利用阿里云安全组规则屏蔽相关IP"></a>利用阿里云安全组规则屏蔽相关IP</h4><p>进入云服务器，选择网络与安全，点击配置规则，点击添加安全组规则，各个项目照着填，授权对象填以下这些IP（摘自上面那个阿里云的官网），最后一个“描述”填“屏蔽阿里云盾监控”，点“确定”就行了。</p>
<blockquote>
<p>140.205.201.0&#x2F;28,140.205.201.16&#x2F;29,140.205.201.32&#x2F;28,140.205.225.192&#x2F;29,140.205.225.200&#x2F;30,140.205.225.184&#x2F;29,140.205.225.183&#x2F;32,140.205.225.206&#x2F;32,140.205.225.205&#x2F;32,140.205.225.195&#x2F;32,140.205.225.204&#x2F;32,106.11.224.0&#x2F;26,106.11.224.64&#x2F;26,106.11.224.128&#x2F;26,106.11.224.192&#x2F;26,106.11.222.64&#x2F;26,106.11.222.128&#x2F;26,106.11.222.192&#x2F;26,106.11.223.0&#x2F;26,140.205.201.0&#x2F;24,140.205.225.0&#x2F;24</p>
</blockquote>
<p>同理，阿里云监测IP也要并到这个安全组规则里面来，以下是待屏蔽的IP：</p>
<blockquote>
<p>112.124.127.224,112.124.127.44,112.124.127.64,112.124.127.53,120.26.216.168,120.26.64.126,121.43.107.174,121.43.105.176,121.41.117.242,121.40.130.38,121.41.112.148,115.29.112.222,115.28.203.70,42.96.189.63,115.29.113.101,120.27.40.113,115.28.171.22,115.28.189.208,121.42.196.232,115.28.26.13,120.27.47.144,120.27.47.33,112.126.74.55,182.92.148.207,182.92.1.233,112.126.73.56,123.56.138.37,123.57.10.133,112.126.75.174,182.92.157.118,112.126.75.221,182.92.69.212,10.153.174.11,10.153.175.147,10.153.175.146,110.75.0.0&#x2F;16,42.120.0.0&#x2F;16</p>
</blockquote>
<p>出方向允许全部就ok，反正我们主要防止的是阿里云的IP主动来找我们机器的麻烦。</p>
<p>安全组规则入方向的屏蔽阿里云监测IP添加完成了，我们再逐条添加常用的443、、80、3306等端口放行规则。</p>
<h4 id="机器内部配置防火墙"><a href="#机器内部配置防火墙" class="headerlink" title="机器内部配置防火墙"></a>机器内部配置防火墙</h4><p>对于<code>Ubuntu</code>系统，可以考虑开启<code>UFW</code>防火墙，只开放ssh登陆端口和攀云屐端口，在系统防火墙里添加如下规则，彻底锁死阿里云的IP主动探测我们的机器。</p>
<h5 id="安装ufw："><a href="#安装ufw：" class="headerlink" title="安装ufw："></a>安装ufw：</h5><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install ufw</span><br></pre></td></tr></table></figure></div>

<h5 id="开启ufw："><a href="#开启ufw：" class="headerlink" title="开启ufw："></a>开启ufw：</h5><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ufw enable</span><br></pre></td></tr></table></figure></div>

<h5 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h5><p>如果你的机器自带IPv6地址，确保 IPV6&#x3D;yes 这个值生效：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/default/ufw</span><br></pre></td></tr></table></figure></div>

<h5 id="设置基本的出入站规则"><a href="#设置基本的出入站规则" class="headerlink" title="设置基本的出入站规则"></a>设置基本的出入站规则</h5><p>入站（备注，默认禁止所有端口访问，后面我们会预留必要的端口）：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ufw default deny incoming</span><br></pre></td></tr></table></figure></div>

<p>出站（备注，默认允许服务器访问所有端口）：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ufw default allow outgoing</span><br></pre></td></tr></table></figure></div>

<p>出站规则我们就不用再做其他的额外设置了，主要做入站的端口规则，打开各种必要的端口，对于我的阿里云来说，平时打开ssh登陆端口和其他访问端口就够了：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ufw allow 22/tcp</span><br></pre></td></tr></table></figure></div>

<p>ssh登陆端口是一定要放行的，否则等会儿机器都连不上了。</p>
<h5 id="在ufw里添加规则"><a href="#在ufw里添加规则" class="headerlink" title="在ufw里添加规则"></a>在ufw里添加规则</h5><p>彻底禁止阿里云的检测节点IP来骚扰我们的机器：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/ufw/before.rules</span><br></pre></td></tr></table></figure></div>

<p>找到 ## End required lines ，添加如下：</p>
<blockquote>
<p>-A ufw-before-input -s 140.205.201.0&#x2F;24 -j DROP<br>-A ufw-before-input -s 140.205.201.0&#x2F;28 -j DROP<br>-A ufw-before-input -s 140.205.201.16&#x2F;29 -j DROP<br>-A ufw-before-input -s 140.205.201.32&#x2F;28 -j DROP<br>-A ufw-before-input -s 140.205.225.0&#x2F;24 -j DROP<br>-A ufw-before-input -s 140.205.225.192&#x2F;29 -j DROP<br>-A ufw-before-input -s 140.205.225.200&#x2F;30 -j DROP<br>-A ufw-before-input -s 140.205.225.184&#x2F;29 -j DROP<br>-A ufw-before-input -s 140.205.225.183&#x2F;32 -j DROP<br>-A ufw-before-input -s 140.205.225.206&#x2F;32 -j DROP<br>-A ufw-before-input -s 140.205.225.205&#x2F;32 -j DROP<br>-A ufw-before-input -s 140.205.225.195&#x2F;32 -j DROP<br>-A ufw-before-input -s 140.205.225.204&#x2F;32 -j DROP<br>-A ufw-before-input -s 106.11.224.0&#x2F;26 -j DROP<br>-A ufw-before-input -s 106.11.224.64&#x2F;26 -j DROP<br>-A ufw-before-input -s 106.11.224.128&#x2F;26 -j DROP<br>-A ufw-before-input -s 106.11.224.192&#x2F;26 -j DROP<br>-A ufw-before-input -s 106.11.222.64&#x2F;26 -j DROP<br>-A ufw-before-input -s 106.11.222.128&#x2F;26 -j DROP<br>-A ufw-before-input -s 106.11.222.192&#x2F;26 -j DROP<br>-A ufw-before-input -s 106.11.223.0&#x2F;26 -j DROP<br>-A ufw-before-input -s 112.124.127.224 -j DROP<br>-A ufw-before-input -s 112.124.127.44 -j DROP<br>-A ufw-before-input -s 112.124.127.64 -j DROP<br>-A ufw-before-input -s 112.124.127.53 -j DROP<br>-A ufw-before-input -s 120.26.216.168 -j DROP<br>-A ufw-before-input -s 120.26.64.126 -j DROP<br>-A ufw-before-input -s 121.43.107.174 -j DROP<br>-A ufw-before-input -s 121.43.107.176 -j DROP<br>-A ufw-before-input -s 121.41.117.242 -j DROP<br>-A ufw-before-input -s 121.40.130.38 -j DROP<br>-A ufw-before-input -s 121.41.112.148 -j DROP<br>-A ufw-before-input -s 115.29.112.222 -j DROP<br>-A ufw-before-input -s 115.28.203.70 -j DROP<br>-A ufw-before-input -s 42.96.189.63 -j DROP<br>-A ufw-before-input -s 115.29.113.101 -j DROP<br>-A ufw-before-input -s 120.27.40.113 -j DROP<br>-A ufw-before-input -s 115.28.171.22 -j DROP<br>-A ufw-before-input -s 115.28.189.208 -j DROP<br>-A ufw-before-input -s 121.42.196.232 -j DROP<br>-A ufw-before-input -s 115.28.26.13 -j DROP<br>-A ufw-before-input -s 120.27.47.144 -j DROP<br>-A ufw-before-input -s 120.27.47.33 -j DROP<br>-A ufw-before-input -s 112.126.74.55 -j DROP<br>-A ufw-before-input -s 182.92.148.207 -j DROP<br>-A ufw-before-input -s 182.92.1.233 -j DROP<br>-A ufw-before-input -s 112.126.73.56 -j DROP<br>-A ufw-before-input -s 123.56.138.37 -j DROP<br>-A ufw-before-input -s 123.57.10.133 -j DROP<br>-A ufw-before-input -s 112.126.75.174 -j DROP<br>-A ufw-before-input -s 182.92.157.118 -j DROP<br>-A ufw-before-input -s 112.126.75.221 -j DROP<br>-A ufw-before-input -s 182.92.69.212 -j DROP<br>-A ufw-before-input -s 10.153.174.11 -j DROP<br>-A ufw-before-input -s 10.153.175.147 -j DROP<br>-A ufw-before-input -s 10.153.175.146 -j DROP<br>-A ufw-before-input -s 110.75.0.0&#x2F;16 -j DROP<br>-A ufw-before-input -s 42.120.0.0&#x2F;16 -j DROP</p>
</blockquote>
<p>确认、保存退出。</p>
<h5 id="重载ufw配置，使其生效"><a href="#重载ufw配置，使其生效" class="headerlink" title="重载ufw配置，使其生效"></a>重载ufw配置，使其生效</h5><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ufw reload</span><br></pre></td></tr></table></figure></div>

<h3 id="卸载云监控Java版本插件"><a href="#卸载云监控Java版本插件" class="headerlink" title="卸载云监控Java版本插件"></a>卸载云监控Java版本插件</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo /usr/local/cloudmonitor/wrapper/bin/cloudmonitor.sh stop</span><br><span class="line">sudo /usr/local/cloudmonitor/wrapper/bin/cloudmonitor.sh remove</span><br><span class="line">sudo rm -rf /usr/local/cloudmonitor</span><br></pre></td></tr></table></figure></div>
<h3 id="卸载云监控-Go-语言版"><a href="#卸载云监控-Go-语言版" class="headerlink" title="卸载云监控 Go 语言版"></a>卸载云监控 Go 语言版</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo /usr/local/cloudmonitor/CmsGoAgent.linux-amd64 stop</span><br><span class="line">sudo /usr/local/cloudmonitor/CmsGoAgent.linux-amd64 uninstall</span><br><span class="line">sudo rm -rf /usr/local/cloudmonitor</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
