<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
        <meta name="description" content="做一个通透的人，理解复杂，选择简单。">
    
    <meta name="author" content="JustOneBean">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    
    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://just-girl.github.io/2019/03/14/java nio工作原理及代码示例/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/favicon.png" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png">
    <meta name="theme-color" content="#005080">
    <link rel="shortcut icon" href="/images/favicon.png">
    <!--- Page Info-->
    
    <title>
        
            Java NIO工作原理及代码示例 -
        
        个人博客
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/assets/fonts.css">

    <!--- Font Part-->
    
    
    
    

    <!--- Inject Part-->
    
    <script id="hexo-configurations">
    let Global = window.Global || {};
    Global.hexo_config = {"hostname":"just-girl.github.io","root":"/","language":"zh-CN","path":"search.xml"};
    Global.theme_config = {"articles":{"style":{"font_size":"13px","line_height":1.5,"image_border_radius":"8px","image_alignment":"center","image_caption":false,"link_icon":true},"word_count":{"enable":false,"count":true,"min2read":true},"author_label":{"enable":false,"auto":false,"list":[]},"code_block":{"copy":true,"style":"simple","font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":5,"number":false,"expand":true,"init_open":true},"copyright":true,"lazyload":true,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#005080","secondary":null},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":true,"percentage":false},"busuanzi_counter":{"enable":false,"site_pv":true,"site_uv":true,"post_pv":true},"pjax":true,"open_graph":false,"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":false,"style":"static","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"Theme Redefine","subtitle":{"text":[],"hitokoto":{"enable":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"links":{"github":null,"instagram":null,"zhihu":null,"twitter":null,"email":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null}]},"mermaid":{"enable":false,"version":"9.3.0"}},"version":"2.1.3","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"links":{"Home":{"path":"none","icon":"fa-regular fa-house"},"Archives":{"path":"/archives","icon":"fa-regular fa-archive"},"Tags":{"path":"/tags","icon":"fa-regular fa-tag"}},"search":{"enable":true,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"links":null},"article_date_format":"YYYY-MM-DD","categories":{"enable":false,"limit":3},"tags":{"enable":true,"limit":3}}};
    Global.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fa-solid fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="main-content-container">

        <div class="main-content-header">
            <header class="navbar-container">
    
    <div class="navbar-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                个人博客
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/archives"  >
                                    
                                        
                                            <i class="fa-regular fa-archive"></i>
                                        
                                        归档
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/tags"  >
                                    
                                        
                                            <i class="fa-regular fa-tag"></i>
                                        
                                        标签
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile drawer -->
    <div class="navbar-drawer">
        <ul class="drawer-navbar-list">
            
                
                
                    <li class="drawer-navbar-item flex-center">
                        <a class="" 
                        href="/archives"  >
                             
                                
                                    <i class="fa-regular fa-archive"></i>
                                
                                归档
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-navbar-item flex-center">
                        <a class="" 
                        href="/tags"  >
                             
                                
                                    <i class="fa-regular fa-tag"></i>
                                
                                标签
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            

        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="main-content-body">

            

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">

            
            
                <div class="article-title">
                    <h1 class="article-title-regular">Java NIO工作原理及代码示例</h1>
                </div>
            
                
            

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="/images/avatar.jpg">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">JustOneBean</span>
                            
                        </div>
                        <div class="meta-info">
                            <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2019-03-14</span>
        <span class="mobile">2019-03-14 00</span>
        <span class="hover-info">创建</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2023-03-22 17:19:16</span>
            <span class="mobile">2023-03-22 17:19</span>
            <span class="hover-info">更新</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/Java/">Java</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/Java/">Java</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content markdown-body">
                <p>简介：本文主要介绍了JAVA NIO中的Buffer, Channel, Selector的工作原理以及使用它们的若干注意事项，最后是利用它们实现服务器和客户端通信的代码实例。</p>
<span id="more"></span>

<h2 id="ByteBuffer"><a href="#ByteBuffer" class="headerlink" title="ByteBuffer"></a>ByteBuffer</h2><h3 id="直接缓冲区和非直接缓冲区"><a href="#直接缓冲区和非直接缓冲区" class="headerlink" title="直接缓冲区和非直接缓冲区"></a>直接缓冲区和非直接缓冲区</h3><p>下面是创建<code>ByteBuffer</code>对象的几种方式</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ByteBuffer <span class="title function_">allocate</span><span class="params">(<span class="type">int</span> capacity)</span></span><br><span class="line"><span class="keyword">static</span> ByteBuffer <span class="title function_">allocateDirect</span><span class="params">(<span class="type">int</span> capacity)</span></span><br><span class="line"><span class="keyword">static</span> ByteBuffer <span class="title function_">wrap</span><span class="params">(<span class="type">byte</span>[] array)</span></span><br><span class="line"><span class="keyword">static</span> ByteBuffer <span class="title function_">wrap</span><span class="params">(<span class="type">byte</span>[] array, <span class="type">int</span> offset, <span class="type">int</span> length)</span>    </span><br></pre></td></tr></table></figure></div>

<p>allocate方式创建的ByteBuffer对象我们称之为非直接缓冲区，这个ByteBuffer对象(和对象包含的缓冲数组)都位于JVM的堆区。wrap方式和allocate方式创建的ByteBuffer没有本质区别，都创建的是非直接缓冲区。</p>
<p>allocateDirect方法创建的ByteBuffer我们称之为直接缓冲区，此时ByteBuffer对象本身在堆区，而缓冲数组位于非堆区， ByteBuffer对象内部存储了这个非堆缓冲数组的地址。在非堆区的缓冲数组可以通过JNI（内部还是系统调用）方式进行IO操作，JNI不受gc影响，机器码执行速度也比较快，同时还避免了JVM堆区与操作系统内核缓冲区的数据拷贝，所以IO速度比非直接缓冲区快。然而allocateDirect方式创建ByteBuffer对象花费的时间和回收该对象花费的时间比较多，所以这个方法适用于创建那些需要重复使用的缓冲区对象。</p>
<h3 id="重要属性和方法"><a href="#重要属性和方法" class="headerlink" title="重要属性和方法"></a>重要属性和方法</h3><p>ByteBuffer对象三个重要属性 position, limit和capacity。其中capacity表示了缓冲区的总容量，始终保持不变，初始时候position 等于 0 , limit 等于 capacity</p>
<h4 id="put：向缓冲区放入数据"><a href="#put：向缓冲区放入数据" class="headerlink" title="put：向缓冲区放入数据"></a>put：向缓冲区放入数据</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> ByteBuffer <span class="title function_">put</span><span class="params">(<span class="type">byte</span> b)</span></span><br><span class="line">ByteBuffer <span class="title function_">put</span><span class="params">(<span class="type">byte</span>[] src)</span></span><br><span class="line">ByteBuffer <span class="title function_">put</span><span class="params">(<span class="type">byte</span>[] src, <span class="type">int</span> offset, <span class="type">int</span> length)</span></span><br></pre></td></tr></table></figure></div>

<p>调用put方法前，limit应该等于capacity，如果不等于，几乎可以肯定我们对缓冲区的操作有误。在put方法中0到position-1的区域表示有效数据,position到limit之间区域表示空闲区域。put方法会从position的当前位置放入数据，每放入一个数据position增加1，当position等于limit（即空闲区域使用完）时还继续放入数据就会抛出BufferUnderflowException异常</p>
<h4 id="get：从缓冲区读取数据"><a href="#get：从缓冲区读取数据" class="headerlink" title="get：从缓冲区读取数据"></a>get：从缓冲区读取数据</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="type">byte</span> <span class="title function_">get</span><span class="params">()</span></span><br><span class="line">ByteBuffer <span class="title function_">get</span><span class="params">(<span class="type">byte</span>[] dst)</span></span><br><span class="line">ByteBuffer <span class="title function_">get</span><span class="params">(<span class="type">byte</span>[] dst, <span class="type">int</span> offset, <span class="type">int</span> length)</span></span><br></pre></td></tr></table></figure></div>

<p>在get方法中， 0到position-1的区域表示已读数据,position到limit之间的区域表示未读取的数据。每读取一个数据position增加1，当position等于limit时继续读取数据就会抛出BufferUnderflowException异常。</p>
<h4 id="flip-：将写模式转换成读模式"><a href="#flip-：将写模式转换成读模式" class="headerlink" title="flip ：将写模式转换成读模式"></a>flip ：将写模式转换成读模式</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">flip</span><span class="params">()</span> &#123;</span><br><span class="line">    limit = position;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="clear：清空缓冲区，将读模式转换写模式"><a href="#clear：清空缓冲区，将读模式转换写模式" class="headerlink" title="clear：清空缓冲区，将读模式转换写模式"></a>clear：清空缓冲区，将读模式转换写模式</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    limit = capacity;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="compact：保留未读取的数据，将读模式转换写模式"><a href="#compact：保留未读取的数据，将读模式转换写模式" class="headerlink" title="compact：保留未读取的数据，将读模式转换写模式"></a>compact：保留未读取的数据，将读模式转换写模式</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ByteBuffer <span class="title function_">compact</span><span class="params">()</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> position();</span><br><span class="line">    <span class="type">int</span> <span class="variable">lim</span> <span class="operator">=</span> limit();</span><br><span class="line">    <span class="keyword">assert</span> (pos &lt;= lim);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rem</span> <span class="operator">=</span> (pos &lt;= lim ? lim - pos : <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    unsafe.copyMemory(ix(pos), ix(<span class="number">0</span>), (<span class="type">long</span>)rem &lt;&lt; <span class="number">0</span>);</span><br><span class="line">    position(rem);</span><br><span class="line">    limit(capacity());</span><br><span class="line">    discardMark();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="mark：保存当前position的位置到mark变量"><a href="#mark：保存当前position的位置到mark变量" class="headerlink" title="mark：保存当前position的位置到mark变量"></a>mark：保存当前position的位置到mark变量</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">mark</span><span class="params">()</span> &#123;</span><br><span class="line">    mark = position;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="rest：将position置为mark变量中的值"><a href="#rest：将position置为mark变量中的值" class="headerlink" title="rest：将position置为mark变量中的值"></a>rest：将position置为mark变量中的值</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">reset</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> mark;</span><br><span class="line">    <span class="keyword">if</span> (m &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidMarkException</span>();</span><br><span class="line">    position = m;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>mark方法和rest方法联合使用可实现从指定位置的重读。</p>
<h4 id="rewind：从头开始重读"><a href="#rewind：从头开始重读" class="headerlink" title="rewind：从头开始重读"></a>rewind：从头开始重读</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">rewind</span><span class="params">()</span> &#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>ByteBuffer对象使用时又很多需要注意的地方，自认为这个API设计的不是很友好。比如一定不能连续两次调用flip和compact方法,flip方法调用以后不能再调用put方法，等等。要避免这些错误，只能在使用ByteBuffer前弄清楚当前缓冲区中0到position-1以及position到limit中数据表示的含义，这才是避免bug的根本办法。</p>
<p>从上面的介绍中我们可以看出，ByteBuffer对象既可以读，也可以写。除非我们能保证在读操作一次性使用完ByteBuffer对象中的所有数据，并且保证写入ByteBuffer对象向中的内容全部写入完成，否则同时用于读写的ByteBuffer对象会造成数据的混乱和错误。<strong>一般来说，我们都会创建两个ByteBuffer对象向，一个用于接收数据，另一个用于发送数据。</strong></p>
<h4 id="其它方法"><a href="#其它方法" class="headerlink" title="其它方法"></a>其它方法</h4><p>ByteBuffer是面向字节的，为方便基本数据类型的读取，ByteBuffer中还提供getInt，putInt，getFloat，putFloat等方法，这些方法方便我们在缓冲区存取单个基本数据类型。如果需要从基本数据类型数组中写入到ByteBuffer中，或者从ByteBuffer中读取到基本数据类型的数组中，那么我们可以通过已创建好的ByteBuffer对象的asXxxBuffer方法创建基本数据类型的Buffer。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> CharBuffer <span class="title function_">asCharBuffer</span><span class="params">()</span></span><br><span class="line"><span class="keyword">abstract</span> DoubleBuffer <span class="title function_">asDoubleBuffer</span><span class="params">()</span></span><br><span class="line"><span class="keyword">abstract</span> FloatBuffer <span class="title function_">asFloatBuffer</span><span class="params">()</span></span><br><span class="line"><span class="keyword">abstract</span> IntBuffer <span class="title function_">asIntBuffer</span><span class="params">()</span></span><br><span class="line"><span class="keyword">abstract</span> LongBuffer <span class="title function_">asLongBuffer</span><span class="params">()</span></span><br></pre></td></tr></table></figure></div>

<p>假设有如下代码</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IntBuffer</span> <span class="variable">intBufferObj</span> <span class="operator">=</span> byteBufferObj.asIntBuffer();</span><br></pre></td></tr></table></figure></div>

<p>此时intBufferObj和byteBufferObj对象共享底层的数组。但是比较坑爹的是两个buffer的position，limit是独立的，这样极易产生bug，需要引起我们注意。</p>
<h3 id="ByteBuffer的编码和解码"><a href="#ByteBuffer的编码和解码" class="headerlink" title="ByteBuffer的编码和解码"></a>ByteBuffer的编码和解码</h3><p>数据传输中我们使用的是ByteBuffer对象作为缓冲区，如果在通道两端我们通信的内容是文本数据，这就涉及到ByteBuffer与CharBuffer的转换。我们可以使用Charset类实现这个转换的功能。</p>
<h4 id="解码示例"><a href="#解码示例" class="headerlink" title="解码示例"></a>解码示例</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">byteBuffer.put(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;-<span class="number">26</span>, -<span class="number">120</span>, -<span class="number">111</span>, -<span class="number">25</span>, -<span class="number">120</span>, -<span class="number">79</span>, -<span class="number">28</span>, -<span class="number">67</span>, -<span class="number">96</span>&#125;);</span><br><span class="line">byteBuffer.flip();</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*对获取utf8的编解码器*/</span></span><br><span class="line"><span class="type">Charset</span> <span class="variable">utf8</span> <span class="operator">=</span> Charset.forName(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="type">CharBuffer</span> <span class="variable">charBuffer</span> <span class="operator">=</span> utf8.decode(byteBuffer);<span class="comment">/*对bytebuffer中的内容解码*/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*array()返回的就是内部的数组引用，编码以后的有效长度是0~limit*/</span></span><br><span class="line"><span class="type">char</span>[] charArr = Arrays.copyOf(charBuffer.array(), charBuffer.limit());</span><br><span class="line">System.out.println(charArr); <span class="comment">/*运行结果：我爱你*/</span></span><br></pre></td></tr></table></figure></div>

<h4 id="编码示例"><a href="#编码示例" class="headerlink" title="编码示例"></a>编码示例</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CharBuffer</span> <span class="variable">charBuffer</span> <span class="operator">=</span> CharBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">charBuffer.append(<span class="string">&quot;我爱你&quot;</span>);</span><br><span class="line">charBuffer.flip();</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*对获取utf8的编解码器*/</span></span><br><span class="line"><span class="type">Charset</span> <span class="variable">utf8</span> <span class="operator">=</span> Charset.forName(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> utf8.encode(charBuffer); <span class="comment">/*对charbuffer中的内容解码*/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*array()返回的就是内部的数组引用，编码以后的有效长度是0~limit*/</span></span><br><span class="line"><span class="type">byte</span>[] bytes = Arrays.copyOf(byteBuffer.array(), byteBuffer.limit());</span><br><span class="line">System.out.println(Arrays.toString(bytes));</span><br><span class="line"><span class="comment">/*运行结果：[-26, -120, -111, -25, -120, -79, -28, -67, -96] */</span></span><br></pre></td></tr></table></figure></div>

<p>我们还可以通过代码中的utf8编解码器分别获取编码器对象和解码器对象</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CharsetEncoder</span> <span class="variable">utf8Encoder</span> <span class="operator">=</span> utf8.newEncoder();</span><br><span class="line"><span class="type">CharsetDecoder</span> <span class="variable">utf8Decoder</span> <span class="operator">=</span> utf8.newDecoder();</span><br></pre></td></tr></table></figure></div>

<p>然后通过下面编码器和解码器提供的方法进行编解码，其中一些方法可以使ByteBuffer和CharBuffer对象循环使用，不必每次都产生一个新的对象。</p>
<h4 id="解码器方法"><a href="#解码器方法" class="headerlink" title="解码器方法"></a>解码器方法</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Convenience method that decodes the remaining content of a single input byte buffer into a newly-allocated character buffer.*/</span></span><br><span class="line">CharBuffer <span class="title function_">decode</span><span class="params">(ByteBuffer in)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Decodes as many bytes as possible from the given input buffer, writing the results to the given output buffer.*/</span></span><br><span class="line">CoderResult <span class="title function_">decode</span><span class="params">(ByteBuffer in, CharBuffer out, <span class="type">boolean</span> endOfInput)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*Decodes one or more bytes into one or more characters.*/</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> CoderResult <span class="title function_">decodeLoop</span><span class="params">(ByteBuffer in, CharBuffer out)</span></span><br></pre></td></tr></table></figure></div>

<h4 id="编码器方法"><a href="#编码器方法" class="headerlink" title="编码器方法"></a>编码器方法</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Convenience method that encodes the remaining content of a single input character buffer into a newly-allocated byte buffer.*/</span></span><br><span class="line">ByteBuffer <span class="title function_">encode</span><span class="params">(CharBuffer in)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Encodes as many characters as possible from the given input buffer, writing the results to the given output buffer.*/</span></span><br><span class="line">CoderResult <span class="title function_">encode</span><span class="params">(CharBuffer in, ByteBuffer out, <span class="type">boolean</span> endOfInput)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Encodes one or more characters into one or more bytes.*/</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> CoderResult <span class="title function_">encodeLoop</span><span class="params">(CharBuffer in, ByteBuffer out)</span></span><br></pre></td></tr></table></figure></div>

<p>注意 <code>encode</code> 和 <code>decode</code> 方法都会改变源 <code>buffer</code> 中的 <code>position</code> 的位置，这点也是容易产生 Bug 的方法。</p>
<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>针对四种不同的应用场景，有四种不同类型的Channel对象。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">应用场景</th>
<th align="center">是否阻塞</th>
</tr>
</thead>
<tbody><tr>
<td align="center">FileChannel</td>
<td align="center">文件</td>
<td align="center">阻塞</td>
</tr>
<tr>
<td align="center">DatagramChannel</td>
<td align="center">UDP协议</td>
<td align="center">阻塞或非阻塞</td>
</tr>
<tr>
<td align="center">SocketChannel</td>
<td align="center">TCP协议</td>
<td align="center">阻塞或非阻塞</td>
</tr>
<tr>
<td align="center">ServerSocketChannel</td>
<td align="center">用于TCP服务器端的监听和链接</td>
<td align="center">阻塞或非阻塞</td>
</tr>
</tbody></table>
<p>Channel 对象的创建都是通过调用内部的open静态方法实现的，此方法是线程安全的。不论哪种类型的 Channel对象，都有read（要理解为从通道中读取，写入缓冲区中）和 write（要理解为从缓冲区中读取数据，写入到通道中）方法，而且read和write方法都只针对ByteBuffer对象。</p>
<p>当我们要获取由通道传输过来的数据时，先调用 channel.read（byteBufferObj）方法，这个方法在内部调用了byteBufferObj 对象的put方法，将通道中的数据写入缓冲区中。当我们要获取由通道传输来的数据时，调用byteBufferObj.flip() ，然后调用 byteBufferObj 的 get 方法获取通道传过来的数据，最后调用 clear 或 compact 方法转换成写模式，为下次 channel.read 做准备。</p>
<p>当我们要向通道发送数据时，先调 channel.write（byteBufferObj）方法,这个方法内部调用了 byteBufferObj 的get方法获取数据，然后将数据写入通道中。当写入完成后调用 clear 或 compact 方法转换成写模式，为下次channel.write写入缓冲区取做准备。</p>
<h3 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h3><p>在文件通道中 read 和 write 方法都是阻塞的，对于 read 方法，除非遇到文件结束，否则会把缓冲区的剩余空间读满再返回。对于 write 方法，会一次性把缓冲区中的内容全部写入到文件中才会返回。</p>
<p>下面的代码展示了 FileChannel 的功能，首先向文本文件中写入 UTF-8 格式的中英文混合字符，然后再读取出来。读写过程中都涉及到编解码问题。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> nioDemo;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">package</span> nioDemo;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.CharBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileChannelDemo</span> &#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123; </span><br><span class="line">         </span><br><span class="line">        <span class="comment">/*创建文件，向文件中写入数据*/</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">/*如果文件不存在，创建该文件,文件后缀是不是文本文件不重要*/</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:/noi_utf8.data&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">                file.createNewFile();</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">/*根据文件输出流创建与这个文件相关的通道*/</span></span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file);</span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">fc</span> <span class="operator">=</span> fos.getChannel();</span><br><span class="line">             </span><br><span class="line">            <span class="comment">/*创建ByteBuffer对象， position = 0, limit = 64*/</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">bb</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">64</span>);</span><br><span class="line">             </span><br><span class="line">            <span class="comment">/*向ByteBuffer中放入字符串UTF-8的字节, position = 17, limit = 64*/</span></span><br><span class="line">            bb.put(<span class="string">&quot;Hello,World 123 \n&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">             </span><br><span class="line">            <span class="comment">/*flip方法  position = 0, limit = 17*/</span></span><br><span class="line">            bb.flip();</span><br><span class="line">             </span><br><span class="line">            <span class="comment">/*write方法使得ByteBuffer的position到 limit中的元素写入通道中*/</span></span><br><span class="line">            fc.write(bb);</span><br><span class="line">             </span><br><span class="line">            <span class="comment">/*clear方法使得position = 0， limit = 64*/</span></span><br><span class="line">            bb.clear();</span><br><span class="line">             </span><br><span class="line">            <span class="comment">/*下面的代码同理*/</span></span><br><span class="line">            bb.put(<span class="string">&quot;你好，世界 456&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            bb.flip();</span><br><span class="line">             </span><br><span class="line">            fc.write(bb);</span><br><span class="line">            bb.clear();</span><br><span class="line">             </span><br><span class="line">            fos.close();</span><br><span class="line">            fc.close();</span><br><span class="line">             </span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">             </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line">        <span class="comment">/*从刚才的文件中读取字符序列*/</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">/*通过Path对象创建文件通道*/</span></span><br><span class="line">            <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;E:/noi_utf8.data&quot;</span>);</span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">fc</span> <span class="operator">=</span> FileChannel.open(path);</span><br><span class="line">             </span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">bb</span> <span class="operator">=</span> ByteBuffer.allocate((<span class="type">int</span>) fc.size()+<span class="number">1</span>);</span><br><span class="line">             </span><br><span class="line">            <span class="type">Charset</span> <span class="variable">utf8</span> <span class="operator">=</span> Charset.forName(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">             </span><br><span class="line">            <span class="comment">/*阻塞模式，读取完成才能返回*/</span></span><br><span class="line">            fc.read(bb);</span><br><span class="line">             </span><br><span class="line">            bb.flip();</span><br><span class="line">            <span class="type">CharBuffer</span> <span class="variable">cb</span> <span class="operator">=</span> utf8.decode(bb);</span><br><span class="line">            System.out.print(cb.toString());</span><br><span class="line">            bb.clear();</span><br><span class="line">             </span><br><span class="line"> </span><br><span class="line">            fc.close();</span><br><span class="line">             </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="ServerSocketChannel"><a href="#ServerSocketChannel" class="headerlink" title="ServerSocketChannel"></a>ServerSocketChannel</h3><p>服务器端用于创建TCP连接的通道，只能对 accept 事件感兴趣。 accept 方法会返回一个已和客户端连接好的SocketChannel 通道，它才服务器是真正传输数据的通道。</p>
<h3 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h3><p>TCP客户端和TCP服务器端都用它来传输数据。</p>
<p>客户端必须调用 connect 方法去连接服务器。在非阻塞通模式中，该方法将当前通道加入到选择器的已注册集合中，然后通过异步方式进行创建TCP连接，然后该方法立刻返回。注意调用该方法后并不表示已经创建好了TCP连接，如果这个方法返回false，稍后必须调用 finishConnect 方法来完成客户端到服务器的TCP连接。在阻塞方式中， connect 方法会阻塞直到创建好了TCP连接。</p>
<p> finishConnect 在非阻塞模式中仅仅是返回连接的状态。返回 true 时，表示连接创建好了。在阻塞模式下，直接调用方法 connect 即可完成连接，不需要使用 finishConnect 。</p>
<p>非阻塞模式下，读写操作要配合选择器一起使用。在阻塞模式下，创建好TCP连接后就可以直接对通道进行读写操作。</p>
<h3 id="DatagramChannel"><a href="#DatagramChannel" class="headerlink" title="DatagramChannel"></a>DatagramChannel</h3><p>connect 方法仅用于客户端到服务器端的连接，连接的作用仅仅是避免每次发送和接受数据时的安全检查，提高发送和接受数据的效率，而不是像TCP连接那样表示握手的意思。客户端通道只有调用了 connect 方法后，才能使用 read 和 write 方法读写数据。</p>
<p>客户端也可以不事先调用 connet 方法，而直接使用 receive 方法和 send 方法来实现数据的收发。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> SocketAddress <span class="title function_">receive</span><span class="params">(ByteBuffer dst)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">send</span><span class="params">(ByteBuffer src, SocketAddress target)</span> </span><br></pre></td></tr></table></figure></div>

<h3 id="服务器端DatagramChannel和SocketChannel的区别"><a href="#服务器端DatagramChannel和SocketChannel的区别" class="headerlink" title="服务器端DatagramChannel和SocketChannel的区别"></a>服务器端DatagramChannel和SocketChannel的区别</h3><p>对于服务器端 DatagramChannel（UDP）和 SocketChannel（TCP）有明显的区别，对于TCP连接，服务器端每创建一个连接就对应一个通道（不同的客户端ip：port 地址对应一个通道），而服务器端UDP的连接始终只有一个通道，所有客户端发送过来的报文都存放于同一个缓冲区中，这显然会降低服务器端的效率，好在  DatagramChannel 对象是线程安全的，可以用多个线程读写同一个 UDP 通道。</p>
<p>服务器端为什么只有一个通道呢？我猜想因为UDP是无状态的，不知道什么时客户端会发送数据，什么时候数据又发送完成，所以服务器端没有办法为每个客户端创建一个通道，就算服务器端根据客户端ip：port为每个客户端创建了通道，服务器端也不知道什么时候该释放这个通道，这就造成了资源的浪费。</p>
<h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><p>Selector 类表示选择器，通过这个类的对象可以选取已就绪的通道和这个通道感兴趣的事件。通过静态open方法创建。</p>
<h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>通道可以通过它的 register 方法，将通道注册到选择器上。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Registers this channel with the given selector, returning a selection key.*/</span></span><br><span class="line">SelectionKey <span class="title function_">register</span><span class="params">(Selector sel, <span class="type">int</span> ops)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* Registers this channel with the given selector, returning a selection key. */</span></span><br><span class="line"><span class="keyword">abstract</span> SelectionKey <span class="title function_">register</span><span class="params">(Selector sel, <span class="type">int</span> ops, Object att)</span></span><br></pre></td></tr></table></figure></div>

<p>这个该方法会返回一个 SeletctKey 对象，但在这里我们通常忽略这个返回值。SeletctionKey 对象内部包含了这个注册的通道和这个通道感兴趣的事件（ops参数），以及附带的对象（由att参数传递），这个附带的对象通常就是和这个通道相关的读写缓冲区。</p>
<h3 id="通道的选择与取消"><a href="#通道的选择与取消" class="headerlink" title="通道的选择与取消"></a>通道的选择与取消</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Selects a set of keys whose corresponding channels are ready for I/O operations. */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">select</span><span class="params">()</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* Selects a set of keys whose corresponding channels are ready for I/O operations.*/</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">long</span> timeout)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* Selects a set of keys whose corresponding channels are ready for I/O operations.*/</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">selectNow</span><span class="params">()</span></span><br></pre></td></tr></table></figure></div>

<p>三个方法的返回值都表示就绪通道的数量。</p>
<p>select() 方法是个阻塞方法，有通道就绪才会返回。</p>
<p>select(long timeout) ，最多阻塞 timeout 毫秒，即使没有通道就绪也会返回，若超时返回，则当前线程中断标志位被设置。若阻塞时间内有通道就绪，就提前返回。</p>
<p>seletor.selectNow()，非阻塞方法。</p>
<p>一个 seletor 对象内部维护了三个集合。</p>
<ol>
<li>已注册集合：表示了所有已注册通道的SelectionKey对象。</li>
<li>就绪集合：表示了所有已就绪通道的SelectionKey对象。</li>
<li>取消集合：表示了所有需要取消注册关系的通道的SelectionKey对象。</li>
</ol>
<p>SelectionKey 的 cancel 方法用于取消通道和选择器的注册关系，这个方法只是把表示当前通道的 SelectionKey 放入取消集合中，下次调用 select 方法时才会真正取消注册关系。</p>
<p>select 方法每次会从已注册的通道集合中删除所有已取消的通道的 SelectionKey，然后清空已取消的通道集合，最后从更新过的已注册通道集合中选出就绪的通道，放入已就绪的集合中。每次调用 select 方法，会向已就绪的集合中放入已就绪通道的 SelectionKey 对象，调用 selectedKeys 方法就会返回这个已就绪通道集合的引用。当我们处理完一个已就绪通道，该通道对应的SelectionKey对象仍然位于已就绪的集合中，这就要求我们处理一个已就绪的通道后就必须手动从已就绪的集合中删除它，否则下次调用 selectedKeys 时，已处理过的通道还存在于这个集合中，导致线程空转。这里也是极易产生Bug的。</p>
<h3 id="通道的写方法注意事项"><a href="#通道的写方法注意事项" class="headerlink" title="通道的写方法注意事项"></a>通道的写方法注意事项</h3><h4 id="1、写方法什么时候就绪？"><a href="#1、写方法什么时候就绪？" class="headerlink" title="1、写方法什么时候就绪？"></a>1、写方法什么时候就绪？</h4><p>写操作的就绪条件为 socket 底层写缓冲区有空闲空间，此时并不代表我们这时有（或者需要将）数据写入通道。而底层写缓冲区绝大部分时间都是有空闲空间的，所以当你注册写事件后，写操作基本一直是就绪的。这就导致只要有一个通道对写事件感兴趣，select 方法几乎总是立刻返回的，但是实际上我们可能没有数据可写的，所以使得调用 select 方法的线程总是空转。对于客户端发送一些数据，客户端返回一些数据的模型，我们可以在读事件完成后，再设置通道对写事件感兴趣，写操作完成后再取消该通道对写事件的兴趣，这样就可以避免上述问题。</p>
<h4 id="2、如何正确的发送数据"><a href="#2、如何正确的发送数据" class="headerlink" title="2、如何正确的发送数据"></a>2、如何正确的发送数据</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(writeBuffer.hasRemaining())&#123;</span><br><span class="line">    channel.write(writeBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>上面发送数据的通常用的代码，当网络状况良好的情况下，这段代码能正常工作。 现在我们考虑一种极端情况，服务器端写事件就绪，我们向底层的写缓冲区写入一些数据后，服务器端到客户端的链路出现问题，服务器端没能把数据发送出去，此时底层的写缓冲区一直处于满的状态，假设 writeBuffer 中仍然还有没发送完的数据就会导致while 循环空转，浪费CPU资源，同时也妨碍这个selector管理的其它通道的读写。</p>
<p>为了解决个问题，我们应该使用下面的方法发送数据</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(writeBuffer.hasRemaining())&#123;</span><br><span class="line">    len = sc.write(writeBuffer);</span><br><span class="line">    <span class="comment">/*说明底层的socket写缓冲已满*/</span></span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>下面这个类，后面的代码都会用到，它只是两个缓冲区的包装</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> nioDemo;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*自定义Buffer类中包含读缓冲区和写缓冲区，用于注册通道时的附加对象*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Buffers</span> &#123;</span><br><span class="line"> </span><br><span class="line">    ByteBuffer readBuffer;</span><br><span class="line">    ByteBuffer writeBuffer;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Buffers</span><span class="params">(<span class="type">int</span> readCapacity, <span class="type">int</span> writeCapacity)</span>&#123;</span><br><span class="line">        readBuffer = ByteBuffer.allocate(readCapacity);</span><br><span class="line">        writeBuffer = ByteBuffer.allocate(writeCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> ByteBuffer <span class="title function_">getReadBuffer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> readBuffer;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> ByteBuffer <span class="title function_">gerWriteBuffer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> writeBuffer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="TCP非阻塞示例"><a href="#TCP非阻塞示例" class="headerlink" title="TCP非阻塞示例"></a>TCP非阻塞示例</h3><p>服务器端代码</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> nioDemo;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.CharBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*服务器端，:接收客户端发送过来的数据并显示，</span></span><br><span class="line"><span class="comment"> *服务器把上接收到的数据加上&quot;echo from service:&quot;再发送回去*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceSocketChannelDemo</span> &#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TCPEchoServer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">/*服务器地址*/</span></span><br><span class="line">        <span class="keyword">private</span> InetSocketAddress localAddress;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TCPEchoServer</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">            <span class="built_in">this</span>.localAddress = <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(port);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">             </span><br><span class="line">            <span class="type">Charset</span> <span class="variable">utf8</span> <span class="operator">=</span> Charset.forName(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">             </span><br><span class="line">            <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">             </span><br><span class="line">            <span class="type">Random</span> <span class="variable">rnd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">/*创建选择器*/</span></span><br><span class="line">                selector = Selector.open();</span><br><span class="line">                 </span><br><span class="line">                <span class="comment">/*创建服务器通道*/</span></span><br><span class="line">                ssc = ServerSocketChannel.open();</span><br><span class="line">                ssc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                 </span><br><span class="line">                <span class="comment">/*设置监听服务器的端口，设置最大连接缓冲数为100*/</span></span><br><span class="line">                ssc.bind(localAddress, <span class="number">100</span>);</span><br><span class="line">                 </span><br><span class="line">                <span class="comment">/*服务器通道只能对tcp链接事件感兴趣*/</span></span><br><span class="line">                ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">                 </span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;server start failed&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; </span><br><span class="line">             </span><br><span class="line">            System.out.println(<span class="string">&quot;server start with address : &quot;</span> + localAddress);</span><br><span class="line">             </span><br><span class="line">            <span class="comment">/*服务器线程被中断后会退出*/</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                 </span><br><span class="line">                <span class="keyword">while</span>(!Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                     </span><br><span class="line">                    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> selector.select();</span><br><span class="line">                    <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"> </span><br><span class="line">                    Set&lt;SelectionKey&gt; keySet = selector.selectedKeys();</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; it = keySet.iterator();</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                     </span><br><span class="line">                    <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">                             </span><br><span class="line">                        key = it.next();</span><br><span class="line">                        <span class="comment">/*防止下次select方法返回已处理过的通道*/</span></span><br><span class="line">                        it.remove();</span><br><span class="line">                         </span><br><span class="line">                        <span class="comment">/*若发现异常，说明客户端连接出现问题,但服务器要保持正常*/</span></span><br><span class="line">                        <span class="keyword">try</span>&#123;</span><br><span class="line">                            <span class="comment">/*ssc通道只能对链接事件感兴趣*/</span></span><br><span class="line">                            <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">                                 </span><br><span class="line">                                <span class="comment">/*accept方法会返回一个普通通道，</span></span><br><span class="line"><span class="comment">                                     每个通道在内核中都对应一个socket缓冲区*/</span></span><br><span class="line">                                <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> ssc.accept();</span><br><span class="line">                                sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                                 </span><br><span class="line">                                <span class="comment">/*向选择器注册这个通道和普通通道感兴趣的事件，同时提供这个新通道相关的缓冲区*/</span></span><br><span class="line">                                <span class="type">int</span> <span class="variable">interestSet</span> <span class="operator">=</span> SelectionKey.OP_READ;                             </span><br><span class="line">                                sc.register(selector, interestSet, <span class="keyword">new</span> <span class="title class_">Buffers</span>(<span class="number">256</span>, <span class="number">256</span>));</span><br><span class="line">                                 </span><br><span class="line">                                System.out.println(<span class="string">&quot;accept from &quot;</span> + sc.getRemoteAddress());</span><br><span class="line">                            &#125;</span><br><span class="line">                             </span><br><span class="line">                             </span><br><span class="line">                            <span class="comment">/*（普通）通道感兴趣读事件且有数据可读*/</span></span><br><span class="line">                            <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">                                 </span><br><span class="line">                                <span class="comment">/*通过SelectionKey获取通道对应的缓冲区*/</span></span><br><span class="line">                                <span class="type">Buffers</span>  <span class="variable">buffers</span> <span class="operator">=</span> (Buffers)key.attachment();</span><br><span class="line">                                <span class="type">ByteBuffer</span> <span class="variable">readBuffer</span> <span class="operator">=</span> buffers.getReadBuffer();</span><br><span class="line">                                <span class="type">ByteBuffer</span> <span class="variable">writeBuffer</span> <span class="operator">=</span> buffers.gerWriteBuffer();</span><br><span class="line">                                 </span><br><span class="line">                                <span class="comment">/*通过SelectionKey获取对应的通道*/</span></span><br><span class="line">                                <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                                 </span><br><span class="line">                                <span class="comment">/*从底层socket读缓冲区中读入数据*/</span></span><br><span class="line">                                sc.read(readBuffer);</span><br><span class="line">                                readBuffer.flip();</span><br><span class="line">                                 </span><br><span class="line">                                <span class="comment">/*解码显示，客户端发送来的信息*/</span></span><br><span class="line">                                <span class="type">CharBuffer</span> <span class="variable">cb</span> <span class="operator">=</span> utf8.decode(readBuffer);</span><br><span class="line">                                System.out.println(cb.array());</span><br><span class="line">                     </span><br><span class="line">                                readBuffer.rewind();</span><br><span class="line"> </span><br><span class="line">                                 </span><br><span class="line">                                <span class="comment">/*准备好向客户端发送的信息*/</span></span><br><span class="line">                                <span class="comment">/*先写入&quot;echo:&quot;，再写入收到的信息*/</span></span><br><span class="line">                                writeBuffer.put(<span class="string">&quot;echo from service:&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                                writeBuffer.put(readBuffer);</span><br><span class="line">                                 </span><br><span class="line">                                readBuffer.clear();</span><br><span class="line">                                 </span><br><span class="line">                                <span class="comment">/*设置通道写事件*/</span></span><br><span class="line">                                key.interestOps(key.interestOps() | SelectionKey.OP_WRITE);</span><br><span class="line">                                                                 </span><br><span class="line">                            &#125;</span><br><span class="line">                             </span><br><span class="line">                            <span class="comment">/*通道感兴趣写事件且底层缓冲区有空闲*/</span></span><br><span class="line">                            <span class="keyword">if</span>(key.isWritable())&#123;</span><br><span class="line">                                 </span><br><span class="line">                                <span class="type">Buffers</span>  <span class="variable">buffers</span> <span class="operator">=</span> (Buffers)key.attachment();</span><br><span class="line">                                 </span><br><span class="line">                                <span class="type">ByteBuffer</span> <span class="variable">writeBuffer</span> <span class="operator">=</span> buffers.gerWriteBuffer();</span><br><span class="line">                                writeBuffer.flip();</span><br><span class="line">                                 </span><br><span class="line">                                <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                                 </span><br><span class="line">                                <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                                <span class="keyword">while</span>(writeBuffer.hasRemaining())&#123;</span><br><span class="line">                                    len = sc.write(writeBuffer);</span><br><span class="line">                                    <span class="comment">/*说明底层的socket写缓冲已满*/</span></span><br><span class="line">                                    <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                                 </span><br><span class="line">                                writeBuffer.compact();</span><br><span class="line">                                 </span><br><span class="line">                                <span class="comment">/*说明数据全部写入到底层的socket写缓冲区*/</span></span><br><span class="line">                                <span class="keyword">if</span>(len != <span class="number">0</span>)&#123;</span><br><span class="line">                                    <span class="comment">/*取消通道的写事件*/</span></span><br><span class="line">                                    key.interestOps(key.interestOps() &amp; (~SelectionKey.OP_WRITE));</span><br><span class="line">                                &#125;</span><br><span class="line">                                 </span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;service encounter client error&quot;</span>);</span><br><span class="line">                            <span class="comment">/*若客户端连接出现异常，从Seletcor中移除这个key*/</span></span><br><span class="line">                            key.cancel();</span><br><span class="line">                            key.channel().close();</span><br><span class="line">                        &#125;</span><br><span class="line"> </span><br><span class="line">                    &#125;</span><br><span class="line">                         </span><br><span class="line">                    Thread.sleep(rnd.nextInt(<span class="number">500</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                 </span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;serverThread is interrupted&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;serverThread selecotr error&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    selector.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;selector close failed&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;server close&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, IOException&#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">TCPEchoServer</span>(<span class="number">8080</span>));</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">100000</span>);</span><br><span class="line">        <span class="comment">/*结束服务器线程*/</span></span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>客户端程序</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> nioDemo;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.CharBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*客户端:客户端每隔1~2秒自动向服务器发送数据，接收服务器接收到数据并显示*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientSocketChannelDemo</span> &#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TCPEchoClient</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">/*客户端线程名*/</span></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">Random</span> <span class="variable">rnd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">         </span><br><span class="line">        <span class="comment">/*服务器的ip地址+端口port*/</span></span><br><span class="line">        <span class="keyword">private</span> InetSocketAddress remoteAddress;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TCPEchoClient</span><span class="params">(String name, InetSocketAddress remoteAddress)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="built_in">this</span>.remoteAddress = remoteAddress;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">/*创建解码器*/</span></span><br><span class="line">            <span class="type">Charset</span> <span class="variable">utf8</span> <span class="operator">=</span> Charset.forName(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">             </span><br><span class="line">            Selector selector;</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                 </span><br><span class="line">                <span class="comment">/*创建TCP通道*/</span></span><br><span class="line">                <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">                 </span><br><span class="line">                <span class="comment">/*设置通道为非阻塞*/</span></span><br><span class="line">                sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                 </span><br><span class="line">                <span class="comment">/*创建选择器*/</span></span><br><span class="line">                selector = Selector.open();</span><br><span class="line">                 </span><br><span class="line">                <span class="comment">/*注册感兴趣事件*/</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">interestSet</span> <span class="operator">=</span> SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br><span class="line">                 </span><br><span class="line">                <span class="comment">/*向选择器注册通道*/</span></span><br><span class="line">                sc.register(selector, interestSet, <span class="keyword">new</span> <span class="title class_">Buffers</span>(<span class="number">256</span>, <span class="number">256</span>));</span><br><span class="line">                 </span><br><span class="line">                <span class="comment">/*向服务器发起连接,一个通道代表一条tcp链接*/</span></span><br><span class="line">                sc.connect(remoteAddress);</span><br><span class="line">                 </span><br><span class="line">                <span class="comment">/*等待三次握手完成*/</span></span><br><span class="line">                <span class="keyword">while</span>(!sc.finishConnect())&#123;</span><br><span class="line">                    ;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                System.out.println(name + <span class="string">&quot; &quot;</span> + <span class="string">&quot;finished connection&quot;</span>);</span><br><span class="line">                 </span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;client connect failed&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">/*与服务器断开或线程被中断则结束线程*/</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line"> </span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(!Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                     </span><br><span class="line">                    <span class="comment">/*阻塞等待*/</span></span><br><span class="line">                    selector.select();</span><br><span class="line">                     </span><br><span class="line">                    <span class="comment">/*Set中的每个key代表一个通道*/</span></span><br><span class="line">                    Set&lt;SelectionKey&gt; keySet = selector.selectedKeys();</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; it = keySet.iterator();</span><br><span class="line">                     </span><br><span class="line">                    <span class="comment">/*遍历每个已就绪的通道，处理这个通道已就绪的事件*/</span></span><br><span class="line">                    <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">                         </span><br><span class="line">                        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> it.next();</span><br><span class="line">                        <span class="comment">/*防止下次select方法返回已处理过的通道*/</span></span><br><span class="line">                        it.remove();</span><br><span class="line">                         </span><br><span class="line">                        <span class="comment">/*通过SelectionKey获取对应的通道*/</span></span><br><span class="line">                        <span class="type">Buffers</span>  <span class="variable">buffers</span> <span class="operator">=</span> (Buffers)key.attachment();</span><br><span class="line">                        <span class="type">ByteBuffer</span> <span class="variable">readBuffer</span> <span class="operator">=</span> buffers.getReadBuffer();</span><br><span class="line">                        <span class="type">ByteBuffer</span> <span class="variable">writeBuffer</span> <span class="operator">=</span> buffers.gerWriteBuffer();</span><br><span class="line">                         </span><br><span class="line">                        <span class="comment">/*通过SelectionKey获取通道对应的缓冲区*/</span></span><br><span class="line">                        <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                         </span><br><span class="line">                        <span class="comment">/*表示底层socket的读缓冲区有数据可读*/</span></span><br><span class="line">                        <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">                            <span class="comment">/*从socket的读缓冲区读取到程序定义的缓冲区中*/</span></span><br><span class="line">                            sc.read(readBuffer);</span><br><span class="line">                            readBuffer.flip();</span><br><span class="line">                            <span class="comment">/*字节到utf8解码*/</span></span><br><span class="line">                            <span class="type">CharBuffer</span> <span class="variable">cb</span> <span class="operator">=</span> utf8.decode(readBuffer);</span><br><span class="line">                            <span class="comment">/*显示接收到由服务器发送的信息*/</span></span><br><span class="line">                            System.out.println(cb.array());</span><br><span class="line">                            readBuffer.clear();</span><br><span class="line">                        &#125;</span><br><span class="line">                         </span><br><span class="line">                        <span class="comment">/*socket的写缓冲区可写*/</span></span><br><span class="line">                        <span class="keyword">if</span>(key.isWritable())&#123;</span><br><span class="line">                            writeBuffer.put((name + <span class="string">&quot;  &quot;</span> + i).getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                            writeBuffer.flip();</span><br><span class="line">                            <span class="comment">/*将程序定义的缓冲区中的内容写入到socket的写缓冲区中*/</span></span><br><span class="line">                            sc.write(writeBuffer);</span><br><span class="line">                            writeBuffer.clear();</span><br><span class="line">                            i++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                     </span><br><span class="line">                    Thread.sleep(<span class="number">1000</span> + rnd.nextInt(<span class="number">1000</span>));</span><br><span class="line">                &#125;</span><br><span class="line">             </span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                System.out.println(name + <span class="string">&quot; is interrupted&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                System.out.println(name + <span class="string">&quot; encounter a connect error&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    selector.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">                    System.out.println(name + <span class="string">&quot; close selector failed&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                    System.out.println(name + <span class="string">&quot;  closed&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">         </span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">remoteAddress</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;192.168.1.100&quot;</span>, <span class="number">8080</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">ta</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">TCPEchoClient</span>(<span class="string">&quot;thread a&quot;</span>, remoteAddress));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">tb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">TCPEchoClient</span>(<span class="string">&quot;thread b&quot;</span>, remoteAddress));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">tc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">TCPEchoClient</span>(<span class="string">&quot;thread c&quot;</span>, remoteAddress));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">td</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">TCPEchoClient</span>(<span class="string">&quot;thread d&quot;</span>, remoteAddress));</span><br><span class="line">         </span><br><span class="line">        ta.start();</span><br><span class="line">        tb.start();</span><br><span class="line">        tc.start();</span><br><span class="line">         </span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/*结束客户端a*/</span></span><br><span class="line">        ta.interrupt();</span><br><span class="line">         </span><br><span class="line">        <span class="comment">/*开始客户端d*/</span></span><br><span class="line">        td.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="UDP示例"><a href="#UDP示例" class="headerlink" title="UDP示例"></a>UDP示例</h3><p>客户端非阻塞模式，服务器端阻塞模式</p>
<p>服务器端代码（服务器端只有一个通道，对应一个读缓冲区，一个写缓冲区，所以使用非阻塞方式容易发生数据混乱）</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> nioDemo;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.CharBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.DatagramChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceDatagramChannelDemo</span> &#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UDPEchoService</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">UDPEchoService</span><span class="params">(<span class="type">int</span> port)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.port = port;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">             </span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">readBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">256</span>);</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">writeBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">256</span>);</span><br><span class="line"> </span><br><span class="line">            <span class="type">DatagramChannel</span> <span class="variable">dc</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                 </span><br><span class="line">                <span class="comment">/*服务器端使用默认的阻塞IO的方式*/</span></span><br><span class="line">                dc = DatagramChannel.open();</span><br><span class="line">                dc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(port));</span><br><span class="line">                 </span><br><span class="line">                System.out.println(<span class="string">&quot;service start&quot;</span>);</span><br><span class="line">                <span class="keyword">while</span>(!Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                     </span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                         </span><br><span class="line">                        <span class="comment">/*先读取客户端发送的消息，直到读取到消息才会返回*/</span></span><br><span class="line">                        <span class="comment">/*只能调用receive方法，因为不知道哪个地址给服务器发信息，没法实现调用connect方法*/</span></span><br><span class="line">                        <span class="comment">/*dc是阻塞的，所以receive方法要等到接收到数据才返回*/</span></span><br><span class="line">                        <span class="type">SocketAddress</span> <span class="variable">clientAddress</span> <span class="operator">=</span> dc.receive(readBuffer);</span><br><span class="line">                        readBuffer.flip();</span><br><span class="line">                        <span class="type">CharBuffer</span> <span class="variable">charBuffer</span> <span class="operator">=</span> Charset.defaultCharset().decode(readBuffer);</span><br><span class="line">                        System.out.println(charBuffer.array());</span><br><span class="line">                         </span><br><span class="line">                        <span class="comment">/*调用send方法向客户端发送的消息，</span></span><br><span class="line"><span class="comment">                         *dc是阻塞的,所以直到send方法把数据全部写入到socket缓冲区才返回*/</span></span><br><span class="line">                        writeBuffer.put(<span class="string">&quot;echo : &quot;</span>.getBytes());</span><br><span class="line">                        readBuffer.rewind();</span><br><span class="line">                        writeBuffer.put(readBuffer);</span><br><span class="line">                        writeBuffer.flip();</span><br><span class="line">                        dc.send(writeBuffer, clientAddress);</span><br><span class="line">                         </span><br><span class="line">                        readBuffer.clear();</span><br><span class="line">                        writeBuffer.clear();</span><br><span class="line">                         </span><br><span class="line">                    &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;receive from or send to client failed&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;server error&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(dc != <span class="literal">null</span>)&#123;</span><br><span class="line">                        dc.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"> </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">UDPEchoService</span>(<span class="number">8080</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>客户端代码</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> nioDemo;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.CharBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.DatagramChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientDatagramChannelDemo</span> &#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UDPEchoClient</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> InetSocketAddress serviceAddress;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">UDPEchoClient</span><span class="params">(String name, InetSocketAddress serviceAddress)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="built_in">this</span>.serviceAddress = serviceAddress;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="type">DatagramChannel</span> <span class="variable">dc</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                 </span><br><span class="line">                <span class="comment">/*每个实际上可以创建多个通道连接同一个服务器地址，</span></span><br><span class="line"><span class="comment">                我们这里为了演示方便，只创建了一个通道*/</span></span><br><span class="line">                dc = DatagramChannel.open();</span><br><span class="line">                 </span><br><span class="line">                <span class="comment">/*客户端采用非阻塞模式*/</span></span><br><span class="line">                dc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"> </span><br><span class="line">                <span class="comment">/*这里的连接不是指TCP的握手连接，因为UDP协议本身不需要连接，</span></span><br><span class="line"><span class="comment">                 *这里连接的意思大概是提前向操作系统申请好本地端口号，以及高速操作系统要发送的目的</span></span><br><span class="line"><span class="comment">                 *连接后的UDP通道可以提高发送的效率，还可以调用read和write方法接收和发送数据</span></span><br><span class="line"><span class="comment">                 *未连接的UDP通道只能调用receive和send方法接收和发送数据*/</span></span><br><span class="line">                dc.connect(serviceAddress);</span><br><span class="line">                 </span><br><span class="line">                <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">                <span class="type">int</span> <span class="variable">interest</span> <span class="operator">=</span> SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br><span class="line">                dc.register(selector, interest, <span class="keyword">new</span> <span class="title class_">Buffers</span>(<span class="number">256</span>, <span class="number">256</span>));</span><br><span class="line">                 </span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(!Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                     </span><br><span class="line">                    selector.select();</span><br><span class="line">                     </span><br><span class="line">                    Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();</span><br><span class="line">                    <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">                         </span><br><span class="line">                        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> it.next();</span><br><span class="line">                        it.remove();</span><br><span class="line">                         </span><br><span class="line">                        <span class="type">Buffers</span> <span class="variable">buffers</span> <span class="operator">=</span> (Buffers)key.attachment();</span><br><span class="line">                         </span><br><span class="line">                        <span class="type">ByteBuffer</span> <span class="variable">readBuffer</span> <span class="operator">=</span> buffers.getReadBuffer();</span><br><span class="line">                        <span class="type">ByteBuffer</span> <span class="variable">writeBuffer</span> <span class="operator">=</span> buffers.gerWriteBuffer();</span><br><span class="line">                         </span><br><span class="line">                        <span class="keyword">try</span>&#123;</span><br><span class="line">                             </span><br><span class="line">                            <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">                                dc.read(readBuffer);</span><br><span class="line">                                readBuffer.flip();</span><br><span class="line">                                <span class="type">CharBuffer</span> <span class="variable">charBuffer</span> <span class="operator">=</span> Charset.defaultCharset().decode(readBuffer);</span><br><span class="line">                                System.out.println(charBuffer.array());</span><br><span class="line">                                readBuffer.clear();</span><br><span class="line">                            &#125;</span><br><span class="line">                             </span><br><span class="line">                            <span class="keyword">if</span>(key.isWritable())&#123;</span><br><span class="line">                                writeBuffer.put((name + (i++)).getBytes());</span><br><span class="line">                                writeBuffer.flip();</span><br><span class="line">                                dc.write(writeBuffer);</span><br><span class="line">                                writeBuffer.clear();</span><br><span class="line">                                 </span><br><span class="line">                                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                         </span><br><span class="line">                        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                            key.cancel();</span><br><span class="line">                            key.channel().close();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                System.out.println(name + <span class="string">&quot;interrupted&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                System.out.println(name + <span class="string">&quot;encounter connect error&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    dc.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    System.out.println(name + <span class="string">&quot;encounter close error&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                    System.out.println(name + <span class="string">&quot;closed&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">         </span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">serviceAddress</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;192.168.1.100&quot;</span>, <span class="number">8080</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="type">UDPEchoClient</span> <span class="variable">clientA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UDPEchoClient</span>(<span class="string">&quot;thread a &quot;</span>, serviceAddress);</span><br><span class="line">        <span class="type">UDPEchoClient</span> <span class="variable">clientB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UDPEchoClient</span>(<span class="string">&quot;thread b &quot;</span>, serviceAddress);</span><br><span class="line">        <span class="type">UDPEchoClient</span> <span class="variable">clientC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UDPEchoClient</span>(<span class="string">&quot;thread c &quot;</span>, serviceAddress);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(clientA).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(clientB).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(clientC).start();</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2><p><a class="link"   target="_blank" rel="noopener" href="http://www.importnew.com/26334.html" >堆外内存之 DirectByteBuffer 详解 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/billluffy/article/details/78036998" >SocketChannel—各种注意点 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/" >JDK 8 API 文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>

            </div>

            
                <div class="post-copyright-info">
                    <div class="article-copyright-info-container">
    <ul>
        <li><strong>标题:</strong> Java NIO工作原理及代码示例</li>
        <li><strong>作者:</strong> JustOneBean</li>
        <li><strong>创建于:</strong> 2019-03-14 00:00:00</li>
        
            <li>
                <strong>更新于:</strong> 2023-03-22 17:19:16
            </li>
        
        <li>
            <strong>链接:</strong> https://just-girl.github.io/2019/03/14/Java NIO工作原理及代码示例/
        </li>
        <li>
            <strong>版权声明:</strong> 本文章采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0</a> 进行许可。
        </li>
    </ul>
</div>

                </div>
            

            
                <ul class="post-tags-box">
                    
                        <li class="tag-item">
                            <a href="/tags/Java/">#Java</a>&nbsp;
                        </li>
                    
                </ul>
            

            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                            rel="prev"
                            href="/2019/03/15/Ubuntu%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"
                            >
                                <span class="left arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-left"></i>
                                </span>
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">Ubuntu网络配置</span>
                                    <span class="post-nav-item">上一篇</span>
                                </span>
                            </a>
                        </div>
                    
                    
                        <div class="article-next">
                            <a class="next"
                            rel="next"
                            href="/2019/03/14/npm%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/"
                            >
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">npm设置代理</span>
                                    <span class="post-nav-item">下一篇</span>
                                </span>
                                <span class="right arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-right"></i>
                                </span>
                            </a>
                        </div>
                    
                </div>
            


            
        </div>

        
            <div class="toc-content-container">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <div class="toc-title">此页目录</div>
        <div class="page-title">Java NIO工作原理及代码示例</div>
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#ByteBuffer"><span class="nav-text">ByteBuffer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E7%BC%93%E5%86%B2%E5%8C%BA%E5%92%8C%E9%9D%9E%E7%9B%B4%E6%8E%A5%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-text">直接缓冲区和非直接缓冲区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E8%A6%81%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="nav-text">重要属性和方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#put%EF%BC%9A%E5%90%91%E7%BC%93%E5%86%B2%E5%8C%BA%E6%94%BE%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="nav-text">put：向缓冲区放入数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#get%EF%BC%9A%E4%BB%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="nav-text">get：从缓冲区读取数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#flip-%EF%BC%9A%E5%B0%86%E5%86%99%E6%A8%A1%E5%BC%8F%E8%BD%AC%E6%8D%A2%E6%88%90%E8%AF%BB%E6%A8%A1%E5%BC%8F"><span class="nav-text">flip ：将写模式转换成读模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#clear%EF%BC%9A%E6%B8%85%E7%A9%BA%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%8C%E5%B0%86%E8%AF%BB%E6%A8%A1%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%86%99%E6%A8%A1%E5%BC%8F"><span class="nav-text">clear：清空缓冲区，将读模式转换写模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#compact%EF%BC%9A%E4%BF%9D%E7%95%99%E6%9C%AA%E8%AF%BB%E5%8F%96%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%B0%86%E8%AF%BB%E6%A8%A1%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%86%99%E6%A8%A1%E5%BC%8F"><span class="nav-text">compact：保留未读取的数据，将读模式转换写模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mark%EF%BC%9A%E4%BF%9D%E5%AD%98%E5%BD%93%E5%89%8Dposition%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%88%B0mark%E5%8F%98%E9%87%8F"><span class="nav-text">mark：保存当前position的位置到mark变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rest%EF%BC%9A%E5%B0%86position%E7%BD%AE%E4%B8%BAmark%E5%8F%98%E9%87%8F%E4%B8%AD%E7%9A%84%E5%80%BC"><span class="nav-text">rest：将position置为mark变量中的值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rewind%EF%BC%9A%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E9%87%8D%E8%AF%BB"><span class="nav-text">rewind：从头开始重读</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E5%AE%83%E6%96%B9%E6%B3%95"><span class="nav-text">其它方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ByteBuffer%E7%9A%84%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81"><span class="nav-text">ByteBuffer的编码和解码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="nav-text">解码示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="nav-text">编码示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E7%A0%81%E5%99%A8%E6%96%B9%E6%B3%95"><span class="nav-text">解码器方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E7%A0%81%E5%99%A8%E6%96%B9%E6%B3%95"><span class="nav-text">编码器方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Channel"><span class="nav-text">Channel</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#FileChannel"><span class="nav-text">FileChannel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ServerSocketChannel"><span class="nav-text">ServerSocketChannel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SocketChannel"><span class="nav-text">SocketChannel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DatagramChannel"><span class="nav-text">DatagramChannel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AFDatagramChannel%E5%92%8CSocketChannel%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">服务器端DatagramChannel和SocketChannel的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Selector"><span class="nav-text">Selector</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C"><span class="nav-text">注册</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E9%81%93%E7%9A%84%E9%80%89%E6%8B%A9%E4%B8%8E%E5%8F%96%E6%B6%88"><span class="nav-text">通道的选择与取消</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E9%81%93%E7%9A%84%E5%86%99%E6%96%B9%E6%B3%95%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">通道的写方法注意事项</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%86%99%E6%96%B9%E6%B3%95%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%B0%B1%E7%BB%AA%EF%BC%9F"><span class="nav-text">1、写方法什么时候就绪？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE"><span class="nav-text">2、如何正确的发送数据</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="nav-text">代码示例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%A4%BA%E4%BE%8B"><span class="nav-text">TCP非阻塞示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UDP%E7%A4%BA%E4%BE%8B"><span class="nav-text">UDP示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E5%86%85%E5%AE%B9"><span class="nav-text">参考内容</span></a></li></ol>

    </div>
</div>
            </div>
        
    </div>
</div>


                

            </div>
            
            

        </div>

        <div class="main-content-footer">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info">
            &copy;
            
              <span>2018</span>
              -
            
            2023&nbsp;&nbsp;<i class="fa-solid fa-cog fa-spin fa-spin-reverse"></i>&nbsp;&nbsp;<a href="/">JustOneBean</a>
        </div>
        
        <div class="theme-info info-item">
            <span class="powered-by-container">由 <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" href="https://hexo.io">Hexo</a> 驱动</span>
                <br>
            <span class="theme-version-container">主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.1.3</a>
        </div>
        
        
        
        
        
        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="article-tools-list">
        <!-- TOC aside toggle -->
        
            <li class="right-bottom-tools page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-side-tools-container">
        <div class="side-tools-container">
    <ul class="hidden-tools-list">
        <li class="right-bottom-tools tool-font-adjust-plus flex-center">
            <i class="fa-regular fa-magnifying-glass-plus"></i>
        </li>

        <li class="right-bottom-tools tool-font-adjust-minus flex-center">
            <i class="fa-regular fa-magnifying-glass-minus"></i>
        </li>

        <li class="right-bottom-tools tool-expand-width flex-center">
            <i class="fa-regular fa-expand"></i>
        </li>

        <li class="right-bottom-tools tool-dark-light-toggle flex-center">
            <i class="fa-regular fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="right-bottom-tools tool-scroll-to-top flex-center">
                <i class="fa-regular fa-arrow-up"></i>
            </li>
        

        <li class="right-bottom-tools tool-scroll-to-bottom flex-center">
            <i class="fa-regular fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="visible-tools-list">
        <li class="right-bottom-tools toggle-tools-list flex-center">
            <i class="fa-regular fa-cog fa-spin"></i>
        </li>
        
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fa-solid fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fa-solid fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    


</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/layouts/navbarShrink.js"></script>

<script src="/js/tools/scrollTopBottom.js"></script>

<script src="/js/tools/lightDarkSwitch.js"></script>



    
<script src="/js/tools/localSearch.js"></script>




    
<script src="/js/tools/codeBlock.js"></script>




    
<script src="/js/layouts/lazyload.js"></script>






  
<script src="/js/libs/Typed.min.js"></script>

  
<script src="/js/plugins/typed.js"></script>








<div class="post-scripts pjax">
    
        
<script src="/js/tools/tocToggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/layouts/toc.js"></script>

<script src="/js/plugins/tabs.js"></script>

    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax',
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            Global.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            Global.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            Global.refresh();
        });
    });
</script>




</body>
</html>
